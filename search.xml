<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CentOS下的运维操作</title>
      <link href="/2020/11/09/CentOS%E4%B8%8B%E7%9A%84%E8%BF%90%E7%BB%B4%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/11/09/CentOS%E4%B8%8B%E7%9A%84%E8%BF%90%E7%BB%B4%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ul><li><a href="https://www.jianshu.com/p/215eea897e08" target="_blank" rel="noopener">Centos7部署jar包开机自启</a><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2></li><li><a href="https://blog.csdn.net/yaozhiwei1019/article/details/84954569" target="_blank" rel="noopener">Centos7下mysql大小写敏感问题</a><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2></li><li><a href="https://blog.csdn.net/baidu_30000217/article/details/51558408" target="_blank" rel="noopener">Centos7下配置Redis开机自启动</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis流水号生成</title>
      <link href="/2020/11/09/Redis%E6%B5%81%E6%B0%B4%E5%8F%B7%E7%94%9F%E6%88%90/"/>
      <url>/2020/11/09/Redis%E6%B5%81%E6%B0%B4%E5%8F%B7%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h2 id="一、场景-生成具有一定规则的编码。"><a href="#一、场景-生成具有一定规则的编码。" class="headerlink" title="一、场景:生成具有一定规则的编码。"></a>一、场景:生成具有一定规则的编码。</h2><p>在工作中，想必都接触过这样一个场景：生成具有一定规则的编码。</p><p>比如，合同编号。要求格式为&lt;HT前缀&gt;&lt;4位年&gt;&lt;2位月&gt;&lt;2位类型&gt;&lt;N位流水号&gt;。</p><p>前面都好说，只有这个流水号，很容易就出现重复、跨越等问题。<br>如何解决呢？其实办法也有好多种，能想到的最多就是加锁。无论是synchronized关键字、还是Lock锁、Zookeeper锁、Redis锁等，都是通过阻塞其它请求，即同步阻塞模式，一次只处理一个流水号生成请求，以达到唯一性目的。<br>那么有没有同步非阻塞模式呢？答案是有的，且使用起来也比较简单，即采用Redis的自增特性。</p><h2 id="二、技术方案：利用Redis的原子操作incr命令"><a href="#二、技术方案：利用Redis的原子操作incr命令" class="headerlink" title="二、技术方案：利用Redis的原子操作incr命令"></a>二、技术方案：利用Redis的原子操作incr命令</h2><p>Redis Incr 命令将 key 中储存的数字值增一。<br>如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。<br>如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。<br>本操作的值限制在 64 位(bit)有符号数字表示之内。 </p><pre class=" language-text"><code class="language-text">127.0.0.1:6379> set num 10OK127.0.0.1:6379> incr num(integer) 11127.0.0.1:6379> get num    # 数字值在 Redis 中以字符串的形式保存"11"</code></pre><h2 id="二、存储形式"><a href="#二、存储形式" class="headerlink" title="二、存储形式"></a>二、存储形式</h2><p>可使用string类型存储，也可以使用hash存储，都可以。还是那句话，根据业务场景不同，做不同的适应处理。脱离业务谈实践，就是耍流氓。</p><p>string类型存储好理解，那hash存储适用于哪些场景呢？比如，存在这样一个业务场景：系统是多租户的，每个租户都需要生成合同编号，后台需要实时查看所有租户的流水号情况。那么此时，就需要把Redis中所有的流水号信息取出来。</p><p>如果要使用string类型存储，那么在key的定义上，势必就要加上租户的标识来区分。然后通过scan也好，循环也好，找到所有租户的流水号信息，比较繁琐。</p><p>如果使用hash存储，则只需在value对应的key上，加上租户标识来区分，key值则是统一的<htcode>。无论租户使用怎样的流水号生成、循环规则，只需调整其Redis中value对应的key值规则即可。此时，查找Redis中所有的流水号信息则变得异常方便，把此key值hash表的值全部拿到，即找到了所有租户的流水号信息。</htcode></p><p>所以说，代码实现还是要看具体业务场景，只有业务场景明确了，才能根据具体的业务场景，来做不同的代码实现。</p><h2 id="三、关于key"><a href="#三、关于key" class="headerlink" title="三、关于key"></a>三、关于key</h2><p>比如合同编号，可以定义为&lt;4位年&gt;&lt;2位月&gt;<htcode>。这里key的定义与自身业务场景有很大关系。举个例子，假设业务规定，流水号以年为单位循环，那么，key的定义最好就只有年和固定后缀，即&lt;4位年&gt;<htcode>；如果以月未单位循环，那么，key则需要带上月份以区分不同月份的数据，即&lt;4位年&gt;&lt;2位月&gt;<htcode>。</htcode></htcode></htcode></p><h2 id="四、实现"><a href="#四、实现" class="headerlink" title="四、实现"></a>四、实现</h2><p>实现非常简单，以string存储类型为例，只需调用 redisTemplate.opsForValue().increment(key, delta) 方法即可。<br>注：本例只专注于实现流水号生成，不做具体合同编号按照规则拼装的逻辑。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>runner<span class="token punctuation">.</span>RunWith<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>SpringBootTest<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>core<span class="token punctuation">.</span>RedisTemplate<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>junit4<span class="token punctuation">.</span>SpringRunner<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>CountDownLatch<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicInteger<span class="token punctuation">;</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token punctuation">(</span>webEnvironment <span class="token operator">=</span> SpringBootTest<span class="token punctuation">.</span>WebEnvironment<span class="token punctuation">.</span>RANDOM_PORT<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CodeGeneratorTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> CountDownLatch cd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">2001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> RedisTemplate<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> redisTemplate<span class="token punctuation">;</span>    <span class="token keyword">private</span> AtomicInteger atomicInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">single</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token string">"index"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">concurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 两千个线程，等待全部创建完成后，再同时执行</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 当前线程阻塞等待</span>                    cd<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token string">"index"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cd<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                cd<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> 3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            cd<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">long</span> currentTimeMillis <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前用时："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> currentTimeMillis<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"index"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">%</span> <span class="token number">2000</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            index <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"index"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RS485通信协议(二)</title>
      <link href="/2020/07/06/RS485/RS485%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE(%E4%BA%8C)/"/>
      <url>/2020/07/06/RS485/RS485%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h2 id="RS485通信协议"><a href="#RS485通信协议" class="headerlink" title="RS485通信协议"></a>RS485通信协议</h2><p>RS-485总线技术只是规定了接口的电气标准，并没有规定RS-485接口的电缆，插件以及通信协议，只是OSI规范中物理层的一个标准，由于RS-485总线采用差分平衡传输方式，一般使用的电缆建议采用屏蔽双绞线，使得485+与485-两两双绞，外面采用屏蔽层屏蔽外部电磁干扰，但是在现场实施施工中，有人采用平行线也是可以适用于RS-485总线的电缆，只是抗干扰能力较差，传输距离不远且通信质量不稳定，一般都是建议采用屏蔽双绞线。而接口定义形式，由于RS-485总线一般都是用到485+，485-以及GND三根线，没有硬性规定接口定义形式，一般市面上多见的接口形式有RJ45接口，工业接线端子接口，DB9串口接线端子以及RJ11电话线接口等。一般而言，采用工业接线端子更为合适，因为如果需要接入终端电阻的话，采用工业接线端子是很好接入的，而且接入屏蔽双绞线也是工业接线端子更加方便。</p><p>由于RS-485总线并没有规定通信协议，有很多厂家自己推出基于RS-485总线的通信协议，其中最为著名的是由modicon公司推出的Modbus协议，该协议具有两个版本，一个是Modbus RTU和Modbus ASCII两种帧报文格式，该内容我们会在其他文章内详细描述，我们现在讨论基于RS-485总线通信的协议的一些基本原则以及相关情况。</p><p>由于RS-485总线支持点对多点通信模式，而其没有数据冲突检测解决机制，所以数据冲突的问题都是依靠主机来解决，通过主机对整个系统进行全方位的控制，避免数据冲突的产生，一般而言，由于必须通过主机进行控制以避免数据冲突，基于RS-485总线通信只能支持一主多从的通信方式，在现实生活中，老师在课堂讲课的模式其实就是一种一主多从的通信方式，下面我们按照老师课堂授课的比喻来说明RS-485总线通信协议的一些基本原则。</p><p>由于RS-485总线支持一主多从的通信模式，主机需要能够识别下位多个从机设备，所以从机设备必须具备一个在485网络中的唯一的地址码，就像班级中给学生分配学号一样，学生的姓名可能会有重复，但是学号必须是该班级内唯一的。而老师只需要叫唤学生的学号要求学生回答问题或者做相应的动作等。 同样的道理，485通信主机通过呼叫485通信从机的地址码来控制485通信从机的相关动作。</p><p>485通信网络开始通信的时候，就会对整个网络的设备进行轮询，也就是对485通信从机进行逐个的询问，确认网络中是否存在该设备以及该设备是否能够正常运转。就像老师在正式授课之前会对班级进行点名，确认是否有人缺课，一旦有人缺课做上标识以保证在课堂提问的时候不会点到缺课的学号以免浪费时间。</p><p>485通信主机下发指令是以广播形式发送，485通信从机接收到相关指令，将指令中的地址码与自己的地址码对应，发现是下发给自己的指令则立即执行相关指令，执行完相关指令之后发送相应的状态代码给485通信主机，示意其可以继续下一条指令。否则丢弃该指令，静默等待485通信主机的下一条指令。同样的道理，当老师向某个学生提问的时候，其他学生在此期间是不能出声，只有被提问的学生回答问题，当学生回答完问题之后，就说回答完毕，然后大家静待老师的下一个提问或者授课。</p><p>一般而言，老师授课都是一个人在课堂，但是有些特殊情况是需要两个或者两个以上的老师同时在一个课堂授课，这样就需要一个协调的机制来协调多个老师的授课。而在485通信网络中，也有可能存在多个RS-485通信主机共存于同一个RS-485通信网络中，在这种情况下，深圳市国科伟业通信技术有限公司开发出相应的485共享器用于满足这些需求，485共享器分为两种，抢占式模式以及优先级模式，抢占式模式就是先到先得，就像老师在授课的时候，谁在授课的时候其他老师是不能打断他的授课的，只有在他将该段内容讲完之后，停顿一定时间之后，其他老师才可以开始自己的授课，同样的也是先到先得，谁先开口，谁就授课，直到该段内容讲完之后再重新争取控制权。优先级模式则是定义相应的优先级，比如系主任的优先级高于普通老师的优先级，即使在老师正常授课的时候，系主任说：这里我插一句，则老师的授课自动停止，等待系主任讲完之后再重新抢夺控制权（注：485共享器并不带有存储功能，只能是多个主机重新抢夺控制权，而不是原有中断485通信主机的重新接续原有的指令，原有的通信直接失败）。</p><p>还有就是485通信线路问题，当传输距离较远的时候或者外部干扰过大导致噪音太大，485通信信号会有一定的衰减，就像教室较大以及教室外面比较吵闹的情况，后面的学生并不能清楚的听到相关的内容，在中间增加一个485中继器，将衰减的485信号重新整形还原放大，使得距离较远的485通信从机能够识别485信号。还有就是当教室较大，可能会在教室里面产生混音，通过在教室合理放置多个喇叭，就像485总线连接为星型拓扑结构，产生了信号反射导致通信质量不稳定，使用485集线器将各条485总线相互隔离，独立驱动可以有效的解决类似问题。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RS485 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RS485 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RS485总线几种拓扑结构(三)</title>
      <link href="/2020/07/06/RS485/RS485%E6%80%BB%E7%BA%BF%E5%87%A0%E7%A7%8D%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84(%E4%B8%89)/"/>
      <url>/2020/07/06/RS485/RS485%E6%80%BB%E7%BA%BF%E5%87%A0%E7%A7%8D%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<h2 id="RS485总线几种拓扑结构"><a href="#RS485总线几种拓扑结构" class="headerlink" title="RS485总线几种拓扑结构"></a>RS485总线几种拓扑结构</h2><p>RS-485总线布线规范规定其必须是总线式拓扑结构，也就是要是手牵手菊花链布线方式，但是在现场实际施工过程中，现场RS-485设备的分布不会总是按照线性分布，而可能是零散的分布在不同的位置上或者是呈网格状分布，也有可能呈树形分布，在这种情况下，采用总线式拓扑结构布线不仅浪费线材，拓扑结构也更加复杂，容易造成RS-485总线系统的通信质量不稳定。一般需要借助一些相应的设备布设成星形拓扑结构或者树形拓扑结构，方便现场布线施工以及后期现场维护工作。现将RS-485总线的几种拓扑结构以图示的方式表示出来，与大家共享。</p><p>1.总线式拓扑结构，总线式拓扑结构是RS-485总线的布线规范，总线式拓扑结构其实就是一种特殊的树形拓扑结构，只不过总线式拓扑结构的分支线路距离非常短，在RS-485总线布线中，建议分支距离不要超过0.5米，一般都是建议直接手牵手菊花链的连接，不留分支，这样可以保证没有信号反射的问题。而所谓的手牵手菊花链连接方式就是：A,B,C三台RS-485设备，A设备的485+接入B设备的485+，B设备的485+再连接C设备的485+，有更多设备的话，以此类推，485-的接线方式和485+的接线方式一样。<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/bus.png" alt=""></p><p>2.星形拓扑结构，RS-485总线支持点对多点通信方式，即一个主控485设备控制多个从控485设备，而主控设备多放置于中心位置，如果按照总线式拓扑结构布线的话，485线路需要围绕主控485设备布线，布线方式复杂且浪费线材，利用485集线器布设成星形拓扑结构则布线结构简单，施工以及维护都会非常方便。<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/star.png" alt=""></p><p>3.树形拓扑结构，在现场布线情况下，RS-485设备可能分布在某个主干线的两边，如果采用手牵手的布线方式，则会来回往复的走线，形成浪费且布线结构复杂，布设成树形拓扑结构是比较合理的。树形拓扑结构域总线式拓扑结构的区别在于树形拓扑结构的分支距离比较长，RS-485总线一旦分支距离较长的话，非常容易形成信号反射，从而导致通信不稳定，利用485中继器做隔离，可以有效的保证RS-485总线通信的稳定性。<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/tree.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RS485 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RS485 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RS485总线技术概述(一)</title>
      <link href="/2020/07/06/RS485/RS485%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0(%E4%B8%80)/"/>
      <url>/2020/07/06/RS485/RS485%E6%80%BB%E7%BA%BF%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="RS485总线技术概述"><a href="#RS485总线技术概述" class="headerlink" title="RS485总线技术概述"></a>RS485总线技术概述</h2><p>现场总线概念是由国际电工委员会（International Electrotechnical Commission简称IEC)与1984年提出，具体定义如下：现场总线是一种应用于生产现场，在现场设备和控制装置之间以及现场设备之间实行双向、串行、多节点的数字通信技术。而RS-485又称为EIA-485是由美国电子工业协议（Electronic Industries Association简称EIA)于1983年在RS-422的基础上提出，RS-232/485串口只规定了接口的电气标准，没有规定接口的插件，电缆以及使用的协议，只是OSI规范中物理层的一个标准。严格意义来讲，RS-485总线是现场总线技术的鼻祖，但是其严格意义上来讲并不是现场总线。</p><p>理解RS-485总线需要从RS-232串口开始，现在的RS-232串口基本上都是基于RS-232C标准定义的，其接口定义有DB9以及DB25两种接口定义，现在基本上都是采用DB9接口。RS-232串口定义如下：1.载波检测，2.接收数据，3.发送数据，4.数据终端准备就绪，5.信号地，6.调制解调器就绪，7.请求发送，8.允许发送，9.振铃提示。现在由于计算机处理能力的增强，握手之类的处理基本上交由软件来处理，只需要采用2，3，5（RXD,TXD,GND)三根线就可以正常通信。RS-232串口采用单端非差分电路平衡传输方式传输数据，收发数据线路共用接地线，也就是说其收发数据(RXD,TXD)的表示是针对地线(GND)而言的。当数据线的电平低于-3V的时候，其为逻辑“1”，高于+3V的时候，其为逻辑“0”。所以RS-232串口并不能抑制共模干扰以及共地噪音，从而决定RS-232串口的通信距离较短，并且RS-232串口只能针对点对点通信，不能支持多点组网的通信模式。</p><p>由于工业现场通信节点众多，相互之间距离较远且外部电磁环境复杂，针对工业网络通信人们需要一种采用最少的连线互联各个通信节点，并且具备一定抑制外部干扰的通信方式来完成工业现场的通信任务。针对RS-232存在的缺点，EIA提出了RS-422/485标准，其支持点对多点通信，通信速率最大可以支持110Kbps，通信距离最远可达1200米（通过增加485中继器通信距离可以延长至6000米）。</p><p>EIA232,EIA422,EIA485技术参数：</p><table><thead><tr><th align="left">规范</th><th align="left">EIA-232</th><th align="left">EIA-422</th><th align="left">EIA-485</th></tr></thead><tbody><tr><td align="left">最大传输距离</td><td align="left">15m</td><td align="left">1200m（110kbps)</td><td align="left">1200m（110kbps)</td></tr><tr><td align="left">最大传输速度</td><td align="left">20Kbps</td><td align="left">10Mbps(12m)</td><td align="left">10Mbps(12m)</td></tr><tr><td align="left">驱动器最小输出</td><td align="left">±5V</td><td align="left">±2V</td><td align="left">±1.5V</td></tr><tr><td align="left">驱动器最大输出</td><td align="left">±15V</td><td align="left">±10V</td><td align="left">±6V</td></tr><tr><td align="left">最大驱动器数量</td><td align="left">1</td><td align="left">1</td><td align="left">32单位负载</td></tr><tr><td align="left">最大接收器数量</td><td align="left">1</td><td align="left">10</td><td align="left">32单位负载</td></tr><tr><td align="left">接收器敏感度</td><td align="left">±3V</td><td align="left">±0.2V</td><td align="left">±0.2V</td></tr><tr><td align="left">传输方式</td><td align="left">单端</td><td align="left">差分</td><td align="left">差分</td></tr><tr><td align="left">RS-485总线由于其采用差分平衡电路，能够极大的抑制噪音以及不受节点之间的接地电平差异的影响，具有较强的抗干扰能力以及较远的传输距离。差分平衡电路相应原理如下：在RS-485总线的两条信号线路上（485+，485-）上一根导线的电压值是另外一根导线的电压取反值，接收器的输入电压为两根导线的差值，其差值的正负表示相应的逻辑“1”和“0”（485+电压低于485-，则为逻辑“1”，反之则为逻辑“0”），其接收器最小敏感度可以达到200mV。由于RS-485总线上的两条信号线传递方向相反，大小相同的电流，当噪音电压对其形成干扰的时候，往往都是同时施加于两条信号线路上，并且施加的效果一致，而由于接收器的输入电压为两根导线的差值，其在某一条导线上的噪声电压会被另外一条导线上的噪声电压相互抵消（比如485+上的电压为+1V，485-上的电压为-1V，差值为2V，当噪声电压影响他们使其电压都上升1V，那么485+的电压为+2V,485-的电压则为0V,其差值仍然为2V，这样噪声电压就被抵消了）。同样的道理，由于RS-485总线两根导线的取值是485+，485-的差值，不同节点的接地线的电平差值并不会对差分电路造成任何影响。</td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>RS-485总线接线：485+，485-两条信号线应该在同一条双绞线中，并且互为双绞（比如采用网络作为485线路时，只能是蓝，蓝白或者绿，绿白这样连接,而不能绿，蓝），相互之间不能调换。在RS-485总线首尾各接一个120Ω电阻，成为一个60Ω并联终端电阻，当终端电阻等于电缆的特征阻抗时，可以削弱乃至消除信号的反射。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RS485 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RS485 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>485总线布线规范(四)</title>
      <link href="/2020/07/06/RS485/RS485%E6%80%BB%E7%BA%BF%E5%B8%83%E7%BA%BF%E8%A7%84%E8%8C%83(%E5%9B%9B)/"/>
      <url>/2020/07/06/RS485/RS485%E6%80%BB%E7%BA%BF%E5%B8%83%E7%BA%BF%E8%A7%84%E8%8C%83(%E5%9B%9B)/</url>
      
        <content type="html"><![CDATA[<h2 id="485总线布线规范"><a href="#485总线布线规范" class="headerlink" title="485总线布线规范"></a>485总线布线规范</h2><p>RS-485总线由于其支持设备广泛，设计结构简单，布线成本低廉，抗干扰能力强，在工业现场数据通信领域得到了极其广泛使用，但是在现场施工需要注意若干事项，防止出现相关问题，避免后期的维护成本增加。</p><p>拓扑结构问题：RS-485总线规范规定，RS-485总线需要按照总线式拓扑结构布线，在总线连接上要采用菊花链手牵手方式布线，就等于是要求从主机开始，下面的从设备用RS-485总线像人与人握手相连一样连接在一起，等于是采用一条RS-485总线将所有485设备链接在一起。但是在工业现场中，相应的RS-485设备分布并不一定呈现出线性分布情况，也有可能是网格状或者散乱的分布在现场，如果采用手牵手菊花链方式连接，布线会非常复杂且耗费线材增加成本，所以很多时候人们会采用星型拓扑结构或者树形拓扑结构布线，但是不经过相应设备（星型拓扑结构需要485集线器，树形拓扑结构需要485中继器，相关拓扑结构可以参阅RS-485总线几种拓扑结构）则会出现通信不稳定的情况。所以RS-485总线布线一定需要按照手牵手菊花链方式拓扑结构连接，如果需要连接星型拓扑结构或者树形拓扑结构，则需要借助相应设备。</p><p>RS-485总线接地问题：在RS-485总线布线规范中，要求RS-485总线单点可靠接地，也就是说整个RS-485总线有且仅有一个点接地，但是必须是可靠接地。可靠接地其实有两个意思：1.接地的地电平较为稳定，一般建议接在主机上面或者计算机的地线上。2.整条总线的地线必须保证有可靠的连接，而在现场施工情况下，这点很容易被忽略，一般而言，由于RS-485总线采用的是手牵手连接方式，一般都是将线材剪断与485设备连接（相关页面可以参考RS-485总线几种拓扑结构相关图示），而大家一般都是采用屏蔽层线路作为地线，但是在做接地的时候，大多数人都不会将屏蔽层做连接，那实际而言，屏蔽层是分成了很多段且相互之间是没有良好连接的，这样的地线接地其实可能会适得其反的。所以一旦接地就必须将地线做良好的连接且单点可靠接地，否则宁可不接地。</p><p>线材问题：在RS-485总线布线规范中，要求485+，485-两根导线要互为双绞，且需要带有屏蔽层保护信号线不被外部环境干扰。在现场施工中，由于网线使用非常广泛，很多人采用网线作为485通信线路的线材，由于网线有八根线且单根的线径较细，采用网线作为RS-485总线的线材存在一定的浪费且通信质量不能得到保障。建议采用专用的屏蔽双绞线做为RS-485线路的线材，推荐采用0.5毫米以上线径的线材。另外，需要采购纯铜的线材，因为现在市场上的线材鱼龙混杂，很多奸商利用铁铝合金外层镀铜冒充铜线出售，这些合金线材容易折断且电阻大，对于通信质量有很大的影响，先提供一个鉴别的小窍门：将线材截断之后，对着光线看，如果截断面为铜色，则应该为纯铜线，如果为银白色，那就肯定是劣质线材，建议不要采购。</p><p>通信距离问题:RS-485总线规范标准表明，RS-485总线在通信速率110Kbps的情况下，其通信距离可以达到1200米。但是这个是在理想状态下测定的，RS-485通信距离还受总线负载情况，外部干扰情况以及线材的优劣是相关因素。通信距离与通信线材线径粗细优劣，负载数量以及通信速率成反比，当通信速率越高，负载数量越多以及通信线材越细，RS-485总线的通信距离就越短。如果需要延长RS-485总线通信距离，可以通过增加485中继器或者通过相应的设备转换为网络线路（利用串口服务器的串口转网络功能）或者光纤线路（利用光纤Modem的串口转光纤功能）进行远距离传输。</p><p>RS-485总线负载问题：在485总线标准中，RS-485总线的负载能力是32个单位，现有的普通485芯片负载能力一般是32个，但是最新的芯片负载能力可以达到128单位，最高可以达到400单位。所以一个485网络中的485设备数量并不一定是限制在32单位之内，其网络的最大数量是由标识485设备的地址占用的字节长度有关，而485网络的单条485总线的芯片相关，但是可以通过485集线器扩展出多条485总线来增加485网络的负载数量。建议在一条485总线上的负载数量不要超过30台485设备，因为RS-485总线上的设备一旦出现问题（如短路），就有可能会导致整个485线路上的所有设备都不能正常工作，将单条总线上的设备数量减少，可以有效的降低故障率，比如假定设备无差错的概率为99.9%，当总线上有128个设备的时候，其无差错的概率为99.9%的128次方，其整条总线无差错概率为87.98%，而通过四路的485集线器将其分割为四路单独的485总线，那每条总线的无差错概率则为99.9%的32次方，其单条总线的出错概率为96.85%，通过将大的485总线进行分割，可以有效的增强485总线的稳定性。</p><p>电阻问题：RS-485总线一般都是使用屏蔽双绞线作为通信线材，由于使用的线材质量不一，有可能造成阻抗不匹配，导致数据通信不稳定。在此建议使用120欧姆电阻匹配阻抗，保证通信稳定性。120欧姆电阻的接线方式是在RS-485总线上首尾各接一个120欧姆电阻，电阻并联在485+，485-上。提请注意的是：由于并接120欧姆电阻会导致整个RS-485总线负载能力降低，只有在阻抗不匹配的情况下才考虑并接120欧姆电阻，即一般在排除其他通信不稳定的因素下，才考虑并接电阻。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RS485 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RS485 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThingsBoard网关之ModbusRPC请求</title>
      <link href="/2020/06/19/Thingsboard/ThingsBoard%E7%BD%91%E5%85%B3%E4%B9%8BModbusRPC%E8%AF%B7%E6%B1%82/"/>
      <url>/2020/06/19/Thingsboard/ThingsBoard%E7%BD%91%E5%85%B3%E4%B9%8BModbusRPC%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<p>之前模拟了Modbus设备的数据采集，这次来模拟下Modbus下的RPC请求。</p><h2 id="1-模拟一个空调设备，采用ModbusTCP"><a href="#1-模拟一个空调设备，采用ModbusTCP" class="headerlink" title="1.模拟一个空调设备，采用ModbusTCP"></a>1.模拟一个空调设备，采用ModbusTCP</h2><p>使用ModbusSlave模拟设备，设备地址1，分配4个寄存器：</p><ul><li>寄存器1:模式</li><li>寄存器2:开关状态</li><li>寄存器3,4:温度（这里用2个寄存器存浮点型数据）<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/20200619093414.png" alt=""></li></ul><p>网关配置文件：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"server"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"tcp"</span><span class="token punctuation">,</span>    <span class="token property">"host"</span><span class="token operator">:</span> <span class="token string">"10.49.0.66"</span><span class="token punctuation">,</span>    <span class="token property">"port"</span><span class="token operator">:</span> <span class="token number">502</span><span class="token punctuation">,</span>    <span class="token property">"timeout"</span><span class="token operator">:</span> <span class="token number">35</span><span class="token punctuation">,</span>    <span class="token property">"method"</span><span class="token operator">:</span> <span class="token string">"socket"</span><span class="token punctuation">,</span>    <span class="token property">"byteOrder"</span><span class="token operator">:</span> <span class="token string">"BIG"</span><span class="token punctuation">,</span>    <span class="token property">"devices"</span><span class="token operator">:</span> <span class="token punctuation">[</span>     <span class="token punctuation">{</span>        <span class="token property">"unitId"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token property">"deviceName"</span><span class="token operator">:</span> <span class="token string">"CountSensor"</span><span class="token punctuation">,</span>        <span class="token property">"attributesPollPeriod"</span><span class="token operator">:</span> <span class="token number">5000</span><span class="token punctuation">,</span>        <span class="token property">"timeseriesPollPeriod"</span><span class="token operator">:</span> <span class="token number">5000</span><span class="token punctuation">,</span>        <span class="token property">"sendDataOnlyOnChange"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token property">"timeseries"</span><span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">{</span>            <span class="token property">"byteOrder"</span><span class="token operator">:</span> <span class="token string">"BIG"</span><span class="token punctuation">,</span>            <span class="token property">"tag"</span><span class="token operator">:</span> <span class="token string">"count"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"16int"</span><span class="token punctuation">,</span>            <span class="token property">"functionCode"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>            <span class="token property">"objectsCount"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>            <span class="token property">"address"</span><span class="token operator">:</span> <span class="token number">0</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token property">"byteOrder"</span><span class="token operator">:</span> <span class="token string">"BIG"</span><span class="token punctuation">,</span>            <span class="token property">"tag"</span><span class="token operator">:</span> <span class="token string">"status"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"16int"</span><span class="token punctuation">,</span>            <span class="token property">"functionCode"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>            <span class="token property">"objectsCount"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>            <span class="token property">"address"</span><span class="token operator">:</span> <span class="token number">1</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token property">"byteOrder"</span><span class="token operator">:</span> <span class="token string">"BIG"</span><span class="token punctuation">,</span>            <span class="token property">"tag"</span><span class="token operator">:</span> <span class="token string">"temperature"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"32float"</span><span class="token punctuation">,</span>            <span class="token property">"functionCode"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>            <span class="token property">"objectsCount"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>            <span class="token property">"address"</span><span class="token operator">:</span> <span class="token number">2</span>          <span class="token punctuation">}</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token property">"rpc"</span><span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">{</span>            <span class="token property">"tag"</span><span class="token operator">:</span> <span class="token string">"setValue"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"16int"</span><span class="token punctuation">,</span>            <span class="token property">"functionCode"</span><span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span>            <span class="token property">"objectsCount"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>            <span class="token property">"address"</span><span class="token operator">:</span> <span class="token number">1</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token property">"tag"</span><span class="token operator">:</span> <span class="token string">"getValue"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"16int"</span><span class="token punctuation">,</span>            <span class="token property">"functionCode"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>            <span class="token property">"objectsCount"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>            <span class="token property">"address"</span><span class="token operator">:</span> <span class="token number">1</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token property">"tag"</span><span class="token operator">:</span> <span class="token string">"setTemperature"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"32float"</span><span class="token punctuation">,</span>            <span class="token property">"functionCode"</span><span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span>            <span class="token property">"objectsCount"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>            <span class="token property">"address"</span><span class="token operator">:</span> <span class="token number">2</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token property">"tag"</span><span class="token operator">:</span> <span class="token string">"getTemperature"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"32float"</span><span class="token punctuation">,</span>            <span class="token property">"functionCode"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>            <span class="token property">"objectsCount"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>            <span class="token property">"address"</span><span class="token operator">:</span> <span class="token number">2</span>          <span class="token punctuation">}</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="2-打开ModbusSlave的Connection，启动网关"><a href="#2-打开ModbusSlave的Connection，启动网关" class="headerlink" title="2.打开ModbusSlave的Connection，启动网关"></a>2.打开ModbusSlave的Connection，启动网关</h2><p>可以看到设备数据已经上来：<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/20200619094731.png" alt=""></p><h2 id="3-创建仪表盘"><a href="#3-创建仪表盘" class="headerlink" title="3.创建仪表盘"></a>3.创建仪表盘</h2><p>先新建一个实体设备，指向CountSensor。添加开关控件及数值控件。<br>注意控件中的高级设置，Rpc get value method，Rpc set value method的值要与网关中rpc配置方法名一致。<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/20200619095856.png" alt=""></p><p><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/20200619095919.png" alt=""></p><p>整个仪表盘如下图：<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/20200619100510.png" alt=""></p><h2 id="4-控制模拟"><a href="#4-控制模拟" class="headerlink" title="4.控制模拟"></a>4.控制模拟</h2><ol><li><p>点击开关控制Round Switch，可看到仪表盘状态值的改变<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/20200619100642.png" alt=""></p></li><li><p>控制温度，发现没有效果，查看网关日志，发现如下错误：</p><pre class=" language-text"><code class="language-text">""2020-06-19 10:15:09" - ERROR - [modbus_connector.py] - modbus_connector - 290 - required argument is not a float"Traceback (most recent call last):File "D:\ProgramFilesData\Motrix\thingsboard-gateway-2.3.1.1\thingsboard_gateway\connectors\modbus\modbus_connector.py", line 278, in server_side_rpc_handler self.__process_rpc_request(content, rpc_command_config)File "D:\ProgramFilesData\Motrix\thingsboard-gateway-2.3.1.1\thingsboard_gateway\connectors\modbus\modbus_connector.py", line 298, in __process_rpc_request rpc_command_config["payload"] = self.__devices[content["device"]]["downlink_converter"].convert(File "D:\ProgramFilesData\Motrix\thingsboard-gateway-2.3.1.1\thingsboard_gateway\connectors\modbus\bytes_modbus_downlink_converter.py", line 75, in convert builder_functions[lower_type](value)File "D:\ProgramFiles\Python\Python38\lib\site-packages\pymodbus\payload.py", line 251, in add_32bit_float p_string = self._pack_words(fstring, value)File "D:\ProgramFiles\Python\Python38\lib\site-packages\pymodbus\payload.py", line 79, in _pack_words value = pack("!{}".format(fstring), value)struct.error: required argument is not a float</code></pre></li></ol><p>报错说传入的参数不是一个float值，于是我重新控制，在网关中断点看到了传入的参数是一个str：<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/20200619101500.png" alt=""></p><p>应该是上层的问题,于是查看下控制请求的参数，发现传参时就是个str：<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/20200619103212.png" alt=""></p><p><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/20200619101145.png" alt=""><br>找到问题那就好改了，在knob.directive.js中将控件值转成float:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">turn</span><span class="token punctuation">(</span>ratio<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>minValue <span class="token operator">+</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>maxValue <span class="token operator">-</span> vm<span class="token punctuation">.</span>minValue<span class="token punctuation">)</span><span class="token operator">*</span>ratio<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>ctx<span class="token punctuation">.</span>decimals<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>canvasBar<span class="token punctuation">.</span>value <span class="token operator">!=</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            canvasBar<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">updateColor</span><span class="token punctuation">(</span>canvasBar<span class="token punctuation">.</span><span class="token function">getValueColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        value <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">onValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/20200619110310.png" alt=""></p><p><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/20200619110322.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ThingsBoard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThingsBoard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TB网关测试问题记录</title>
      <link href="/2020/06/15/Thingsboard/TB%E7%BD%91%E5%85%B3%E6%B5%8B%E8%AF%95%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/06/15/Thingsboard/TB%E7%BD%91%E5%85%B3%E6%B5%8B%E8%AF%95%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Modbus网关配置"><a href="#一、Modbus网关配置" class="headerlink" title="一、Modbus网关配置"></a>一、Modbus网关配置</h1><p>1.attributes/timeseries下面的参数需要加上”byteOrder”: “BIG”</p><p>2.同时采集多个设备，要修改设备地址，值对应devices配置下的unitId</p><p>3.Modbus多主机多从机是否可行？<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/20200615164134.png" alt=""></p><ul><li><a href="https://www.konnad.com/product/serial-to-serial-converter/" target="_blank" rel="noopener">康耐德串口转换器</a></li><li><a href="http://bbs.gongkong.com/d/201407/570336_1.shtml" target="_blank" rel="noopener">modbus代理</a>,<a href="https://item.taobao.com/item.htm?spm=a230r.1.14.16.52932ade35mdEM&amp;id=40352800001&amp;ns=1&amp;abbucket=9#detail" target="_blank" rel="noopener">代理设备</a><br><a href="https://v.youku.com/v_show/id_XMTQxNjI3NjkxMg==.html?spm=a2h0c.8166622.PhoneSokuUgc_1.dtitle" target="_blank" rel="noopener">视频</a></li></ul><p>4.使用knob控制控件时，发送rpc请求时，请求参数是string,导致网关解析时无法解析,转换成所需要的数值类型即可</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">turn</span><span class="token punctuation">(</span>ratio<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>minValue <span class="token operator">+</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>maxValue <span class="token operator">-</span> vm<span class="token punctuation">.</span>minValue<span class="token punctuation">)</span><span class="token operator">*</span>ratio<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>ctx<span class="token punctuation">.</span>decimals<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>canvasBar<span class="token punctuation">.</span>value <span class="token operator">!=</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            canvasBar<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">updateColor</span><span class="token punctuation">(</span>canvasBar<span class="token punctuation">.</span><span class="token function">getValueColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        value <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">onValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ThingsBoard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThingsBoard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThingsBoard网关之Modbus设备模拟采集</title>
      <link href="/2020/06/11/Thingsboard/ThingsBoard%E7%BD%91%E5%85%B3%E4%B9%8BModbus%E6%A8%A1%E6%8B%9F%E8%AE%BE%E5%A4%87/"/>
      <url>/2020/06/11/Thingsboard/ThingsBoard%E7%BD%91%E5%85%B3%E4%B9%8BModbus%E6%A8%A1%E6%8B%9F%E8%AE%BE%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<p>本篇介绍下如何使用ModbusSlave/ModbusPoll模拟ModbusRTU与ModbusTCP协议并与TB的Python网关对接。</p><h1 id="1-准备工具"><a href="#1-准备工具" class="headerlink" title="1.准备工具"></a>1.准备工具</h1><p>1.ModbusPoll(链接: <a href="https://pan.baidu.com/s/1cX_jow-G8cmQNaYpAZ42fg" target="_blank" rel="noopener">https://pan.baidu.com/s/1cX_jow-G8cmQNaYpAZ42fg</a> 提取码: p2gk)</p><p>2.ModbusSlave（链接: <a href="https://pan.baidu.com/s/1Fq5O5a-EuWhUBlaNUa98OQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1Fq5O5a-EuWhUBlaNUa98OQ</a> 提取码: 95x7）</p><p>3.虚拟com端口工具VSPD（链接: <a href="https://pan.baidu.com/s/14nN79wXnh8tVYhhn6N3iNQ" target="_blank" rel="noopener">https://pan.baidu.com/s/14nN79wXnh8tVYhhn6N3iNQ</a> 提取码: f6p5）</p><h1 id="2-ModbusRTU协议模拟"><a href="#2-ModbusRTU协议模拟" class="headerlink" title="2.ModbusRTU协议模拟"></a>2.ModbusRTU协议模拟</h1><h2 id="2-1本地ModbusRTU模拟"><a href="#2-1本地ModbusRTU模拟" class="headerlink" title="2.1本地ModbusRTU模拟"></a>2.1本地ModbusRTU模拟</h2><p>1.虚拟两个com端口,COM7,COM8<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/vspd1.png" alt=""><br>2.打开ModbusSlave,点击setup-&gt;slave(从机)definition配置从端，如图：<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/201807231339436.png" alt=""><br>3.打开ModbusPoll,点击read/write(主机)definition配置主端，如图：<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/20180723133942973.png" alt=""><br>以上配置的是10个寄存器从机设备ID为1但只读取前4个寄存器的数据，可根据自己的需要设置。后面为了简便，只配置了一个寄存器。<br>4.接下来分别点击”connection”进行连接，注意修改连接界面的端口，因为我只用到了RTU模式，所以其他选项如波特率9600,比特位8，校验位1，无等价位等可以保持不变，然后点击确定进行连接，未连接成功窗口第二行会给出提示信息。<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/modbusrtuconnection.png" alt=""><br>5.通讯开始，主机端显示：TX=发送命令次数，Err=错误次数，ID=从机ID，F=功能号，SR=轮询间隔时间。使用ModbusSlave工具栏的”Display-&gt;Communication Traffic按钮，可以显示出当前发送命令和接受的数据。<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/modbusrtuconnection2.png" alt=""></p><h2 id="2-2-连接thingsBoard-gateway"><a href="#2-2-连接thingsBoard-gateway" class="headerlink" title="2.2.连接thingsBoard-gateway"></a>2.2.连接thingsBoard-gateway</h2><p>1.我的网关是装在树莓派中的，所以需要用到其他转换器，整体的连接是：</p><p>电脑COM3端口–&gt;USB转485转换器–&gt;485转TTL转换器–&gt;树莓派串口<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/lijie.jpg" alt=""></p><p>2.将ModbusSlave的端口指向COM3</p><p>3.配置tb_gateway.yaml与modbus_serial.json;在tb_gateway.yaml中将连接配置指向modbus_serial.json</p><p>tb_gateway.yaml中内容如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">thingsboard</span><span class="token punctuation">:</span>  <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">"ip"</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">1883</span>  <span class="token key atrule">remoteConfiguration</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">security</span><span class="token punctuation">:</span>    <span class="token key atrule">accessToken</span><span class="token punctuation">:</span> <span class="token string">"token"</span><span class="token key atrule">storage</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> memory  <span class="token key atrule">read_records_count</span><span class="token punctuation">:</span> <span class="token number">100</span>  <span class="token key atrule">max_records_count</span><span class="token punctuation">:</span> <span class="token number">100000</span><span class="token comment" spellcheck="true">#  type: file</span><span class="token comment" spellcheck="true">#  data_folder_path: ./data/</span><span class="token comment" spellcheck="true">#  max_file_count: 10</span><span class="token comment" spellcheck="true">#  max_read_records_count: 10</span><span class="token comment" spellcheck="true">#  max_records_per_file: 10000</span><span class="token key atrule">connectors</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> Modbus Connector    <span class="token key atrule">type</span><span class="token punctuation">:</span> modbus    <span class="token key atrule">configuration</span><span class="token punctuation">:</span> modbus_serial.json</code></pre><p>modbus_serial.json中内容如下：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"server"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Modbus Default Server"</span><span class="token punctuation">,</span>    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"serial"</span><span class="token punctuation">,</span>    <span class="token property">"method"</span><span class="token operator">:</span> <span class="token string">"rtu"</span><span class="token punctuation">,</span>    <span class="token property">"port"</span><span class="token operator">:</span> <span class="token string">"/dev/ttyAMA0"</span><span class="token punctuation">,</span>    <span class="token property">"baudrate"</span><span class="token operator">:</span> <span class="token number">9600</span><span class="token punctuation">,</span>    <span class="token property">"timeout"</span><span class="token operator">:</span> <span class="token number">35</span><span class="token punctuation">,</span>    <span class="token property">"devices"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        <span class="token property">"unitId"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token property">"deviceName"</span><span class="token operator">:</span> <span class="token string">"VuritalDevice"</span><span class="token punctuation">,</span>        <span class="token property">"attributesPollPeriod"</span><span class="token operator">:</span> <span class="token number">5000</span><span class="token punctuation">,</span>        <span class="token property">"timeseriesPollPeriod"</span><span class="token operator">:</span> <span class="token number">5000</span><span class="token punctuation">,</span>        <span class="token property">"sendDataOnlyOnChange"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token property">"timeseries"</span><span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">{</span>            <span class="token property">"byteOrder"</span><span class="token operator">:</span> <span class="token string">"BIG"</span><span class="token punctuation">,</span>            <span class="token property">"tag"</span><span class="token operator">:</span> <span class="token string">"count"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"16int"</span><span class="token punctuation">,</span>            <span class="token property">"functionCode"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>            <span class="token property">"registerCount"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>            <span class="token property">"address"</span><span class="token operator">:</span> <span class="token number">0</span>          <span class="token punctuation">}</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后在TB平台上可以看到遥测值在更新</p><p><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/viratuldevice.png" alt=""></p><h1 id="3-ModbusTCP协议模拟"><a href="#3-ModbusTCP协议模拟" class="headerlink" title="3.ModbusTCP协议模拟"></a>3.ModbusTCP协议模拟</h1><h2 id="3-1本地ModbusTCP模拟"><a href="#3-1本地ModbusTCP模拟" class="headerlink" title="3.1本地ModbusTCP模拟"></a>3.1本地ModbusTCP模拟</h2><p>修改上面Poll/Slave的连接信息，将Connection选择Modbus TCP/IP，点击连接后可看到传输的数据</p><p><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/20200611141355.png" alt=""></p><p><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/20200611142128.png" alt=""></p><h2 id="3-2连接thingsBoard-gateway"><a href="#3-2连接thingsBoard-gateway" class="headerlink" title="3.2连接thingsBoard-gateway"></a>3.2连接thingsBoard-gateway</h2><p>配置tb_gateway.yaml与modbus_serial.json;在tb_gateway.yaml中将连接配置指向modbus.json。</p><p>tb_gateway.yaml中内容如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">thingsboard</span><span class="token punctuation">:</span>  <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token string">"ip"</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">1883</span>  <span class="token key atrule">remoteConfiguration</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">security</span><span class="token punctuation">:</span>    <span class="token key atrule">accessToken</span><span class="token punctuation">:</span> <span class="token string">"token"</span><span class="token key atrule">storage</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> memory  <span class="token key atrule">read_records_count</span><span class="token punctuation">:</span> <span class="token number">100</span>  <span class="token key atrule">max_records_count</span><span class="token punctuation">:</span> <span class="token number">100000</span><span class="token comment" spellcheck="true">#  type: file</span><span class="token comment" spellcheck="true">#  data_folder_path: ./data/</span><span class="token comment" spellcheck="true">#  max_file_count: 10</span><span class="token comment" spellcheck="true">#  max_read_records_count: 10</span><span class="token comment" spellcheck="true">#  max_records_per_file: 10000</span><span class="token key atrule">connectors</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> Modbus Connector    <span class="token key atrule">type</span><span class="token punctuation">:</span> modbus    <span class="token key atrule">configuration</span><span class="token punctuation">:</span> modbus.json</code></pre><p>modbus.json内容如下：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"server"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"tcp"</span><span class="token punctuation">,</span>    <span class="token property">"host"</span><span class="token operator">:</span> <span class="token string">"10.49.0.66"</span><span class="token punctuation">,</span>    <span class="token property">"port"</span><span class="token operator">:</span> <span class="token number">502</span><span class="token punctuation">,</span>    <span class="token property">"timeout"</span><span class="token operator">:</span> <span class="token number">35</span><span class="token punctuation">,</span>    <span class="token property">"method"</span><span class="token operator">:</span> <span class="token string">"socket"</span><span class="token punctuation">,</span>    <span class="token property">"byteOrder"</span><span class="token operator">:</span> <span class="token string">"BIG"</span><span class="token punctuation">,</span>    <span class="token property">"devices"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        <span class="token property">"unitId"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token property">"deviceName"</span><span class="token operator">:</span> <span class="token string">"TCPDevice"</span><span class="token punctuation">,</span>        <span class="token property">"attributesPollPeriod"</span><span class="token operator">:</span> <span class="token number">5000</span><span class="token punctuation">,</span>        <span class="token property">"timeseriesPollPeriod"</span><span class="token operator">:</span> <span class="token number">5000</span><span class="token punctuation">,</span>        <span class="token property">"sendDataOnlyOnChange"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token property">"attributes"</span><span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">{</span>            <span class="token property">"byteOrder"</span><span class="token operator">:</span> <span class="token string">"BIG"</span><span class="token punctuation">,</span>            <span class="token property">"tag"</span><span class="token operator">:</span> <span class="token string">"count"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"16int"</span><span class="token punctuation">,</span>            <span class="token property">"functionCode"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>            <span class="token property">"objectsCount"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>            <span class="token property">"address"</span><span class="token operator">:</span> <span class="token number">0</span>          <span class="token punctuation">}</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token property">"timeseries"</span><span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">{</span>            <span class="token property">"byteOrder"</span><span class="token operator">:</span> <span class="token string">"BIG"</span><span class="token punctuation">,</span>            <span class="token property">"tag"</span><span class="token operator">:</span> <span class="token string">"count"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"16int"</span><span class="token punctuation">,</span>            <span class="token property">"functionCode"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>            <span class="token property">"objectsCount"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>            <span class="token property">"address"</span><span class="token operator">:</span> <span class="token number">0</span>          <span class="token punctuation">}</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token property">"rpc"</span><span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">{</span>            <span class="token property">"tag"</span><span class="token operator">:</span> <span class="token string">"setValue"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"bits"</span><span class="token punctuation">,</span>            <span class="token property">"functionCode"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>            <span class="token property">"objectsCount"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>            <span class="token property">"address"</span><span class="token operator">:</span> <span class="token number">31</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token property">"tag"</span><span class="token operator">:</span> <span class="token string">"getValue"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"bits"</span><span class="token punctuation">,</span>            <span class="token property">"functionCode"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>            <span class="token property">"objectsCount"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>            <span class="token property">"address"</span><span class="token operator">:</span> <span class="token number">31</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token property">"tag"</span><span class="token operator">:</span> <span class="token string">"setCPUFanSpeed"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"32int"</span><span class="token punctuation">,</span>            <span class="token property">"functionCode"</span><span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">,</span>            <span class="token property">"objectsCount"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>            <span class="token property">"address"</span><span class="token operator">:</span> <span class="token number">33</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            <span class="token property">"tag"</span><span class="token operator">:</span><span class="token string">"getCPULoad"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"32int"</span><span class="token punctuation">,</span>            <span class="token property">"functionCode"</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>            <span class="token property">"objectsCount"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>            <span class="token property">"address"</span><span class="token operator">:</span> <span class="token number">35</span>          <span class="token punctuation">}</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后在TB平台上能看到设备的遥测值：</p><p><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/20200611142757.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ThingsBoard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThingsBoard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modbus消息帧</title>
      <link href="/2020/06/10/Modbus/Modbus%E6%B6%88%E6%81%AF%E5%B8%A7/"/>
      <url>/2020/06/10/Modbus/Modbus%E6%B6%88%E6%81%AF%E5%B8%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Modbus消息帧"><a href="#一、Modbus消息帧" class="headerlink" title="一、Modbus消息帧"></a>一、Modbus消息帧</h1><h2 id="串口通信消息帧"><a href="#串口通信消息帧" class="headerlink" title="串口通信消息帧"></a>串口通信消息帧</h2><p>在串口传输模式中（ASCII或RTU），传输设备以将Modbus消息转为有起点和终点的帧，这就允许接收的设备在消息起始处开始工作，读地址分配信息，判断哪一个设备被选中（广播方式则传给所有设备），判知何时信息已完成。部分的消息也能侦测到并且错误能设置为返回结果。</p><h3 id="1-ASCII帧"><a href="#1-ASCII帧" class="headerlink" title="1.ASCII帧"></a>1.ASCII帧</h3><p>使用ASCII模式，消息以冒号（:）字符（ASCII码 3AH）开始，以回车换行符结束（ASCII码 0DH,0AH）。 </p><p>其它域可以使用的传输字符是十六进制的0…9,A…F。网络上的设备不断侦测“:”字符，当有一个冒号接收到时，每个设备都解码下个域（地址域）来判断是否发给自己的。<br>消息中字符间发送的时间间隔最长不能超过1秒，否则接收的设备将认为传输错误。一个典型消息帧如下所示：</p><table><thead><tr><th>起始位</th><th>设备地址</th><th>功能代码</th><th>数据</th><th>LRC校验</th><th>结束符</th></tr></thead><tbody><tr><td>1个字符</td><td>2个字符</td><td>2个字符</td><td>n个字符</td><td>2个字符</td><td>2个字符</td></tr></tbody></table><h3 id="2-RTU帧"><a href="#2-RTU帧" class="headerlink" title="2.RTU帧"></a>2.RTU帧</h3><p>使用RTU模式，消息发送至少要以3.5个字符时间的停顿间隔开始。在网络波特率下多样的字符时间，这是最容易实现的(如下图的T1-T2-T3-T4所示)。传输的第一个域是设备地址。可以使用的传输字符是十六进制的0…9,A…F。网络设备不断侦测网络总线，包括停顿间隔时间内。当第一个域（地址域）接收到，每个设备都进行解码以判断是否发往自己的。在最后一个传输字符之后，一个至少3.5个字符时间的停顿标定了消息的结束。一个新的消息可在此停顿后开始。 </p><p>整个消息帧必须作为一连续的流转输。如果在帧完成之前有超过1.5个字符时间的停顿时间，接收设备将刷新不完整的消息并假定下一字节是一个新消息的地址域。同样地，如果一个新消息在小于3.5个字符时间内接着前个消息开始，接收的设备将认为它是前一消息的延续。这将导致一个错误，因为在最后的CRC域的值不可能是正确的。一典型的消息帧如下所示：<br>起始位 | 设备地址 |  功能代码 | 数据 |CRC校验 |结束符<br>-|-|-|-|-|-<br>T1-T2-T3-T4|1个字节|1个字节|0-255个字节| 2个字节 |T1-T2-T3-T4</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>现有一ModbusRTU协议的<a href="https://detail.tmall.com/item.htm?spm=a220m.1000858.1000725.16.3c3b2273XzOQlq&amp;id=608656701016&amp;skuId=4444637882468&amp;areaId=320400&amp;user_id=2431690912&amp;cat_id=2&amp;is_b=1&amp;rn=04e8f81fdd3ceab14b06ca213feb860d" target="_blank" rel="noopener">温湿度传感器</a><br>1.03功能读取数据，06功能写入设置数据<br>2.数据格式：9600，N，8,1（9600bps，无校验，8位数据位，1位停止位）<br>3.协议格式说明（数据都是16进制）:<br>4.读操作</p><table>            <tbody><tr>                <td></td>                <td>设备地址</td>                <td>功能码</td>                <td>数据地址</td>                <td colspan="2">读取数据个数</td>                <td>16CRC码（低前高后）</td>            </tr>            <tr>                <td>主机命令</td>                <td>设备地址</td>                <td>03</td>                <td>00 00</td>                <td colspan="2">00 02</td>                <td>CRC0 CRC1</td>            </tr>            <tr>                <td></td>                <td>设备地址</td>                <td>功能码</td>                <td>数据字节</td>                <td>温度</td>                <td>湿度</td>                <td>16CRC码（低前高后）</td>            </tr>            <tr>                <td>丛机返回</td>                <td>设备地址</td>                <td>03</td>                <td>04</td>                <td>T_hi T_lo</td>                <td>R_hi R_lo</td>                <td>CRC0 CRC1</td>            </tr></tbody></table>现在传感器的通讯设备地址为01，此时CRC0=C4,CRC1=0B,那么此时发送命令如下：发送：01 03 00 00 00 02 C4 0B返回：01 03 04 00 F8 01 77 3A 7400 F8为温度，转化为十进制为24801 77为湿度，转化为十进制为3755.写操作<table>            <tbody><tr>                <td></td>                <td>设备地址</td>                <td>功能码</td>                <td>数据地址</td>                <td>新地址</td>                <td>16CRC码（低前高后）</td>            </tr>            <tr>                <td>主机命令</td>                <td>设备地址</td>                <td>06</td>                <td>00 0F</td>                <td>00 09</td>                <td>CRC0 CRC1</td>            </tr>            <tr>                <td></td>                <td>设备地址</td>                <td>功能码</td>                <td>数据地址</td>                <td>新地址</td>                <td>16CRC码（低前高后）</td>            </tr>            <tr>                <td>丛机返回</td>                <td>设备地址</td>                <td>06</td>                <td>00 0F</td>                <td>00 09</td>                <td>CRC0 CRC1</td>            </tr></tbody></table>如果将01地址修改为09地址：发送： 01 06 00 0F 00 09 79 CF返回： 01 06 00 0F 00 09 79 CF<h2 id="TCP协议消息帧"><a href="#TCP协议消息帧" class="headerlink" title="TCP协议消息帧"></a>TCP协议消息帧</h2><p>Modbus TCP的协议构成可以分为， 报文头， 功能码， 数据码 这几个部分</p><table>            <tbody><tr>                <td>结构</td>                <td width="150px">名称</td>                <td width="100px">长度</td>                <td>示例</td>                <td>备注</td>            </tr>            <tr>                <td rowspan="4">报头文</td>                <td>事务处理标识符</td>                <td>2个字节</td>                <td>97<br>79</td>                <td>客户机发起，服务器复制，用于事务处理配对，可以自行设定</td>            </tr>            <tr>                <td>协议标识符</td>                <td>2个字节</td>                <td>00<br>00</td>                <td>客户机发起，服务器复制，表示该协议是TCP协议，是固定值，不可以更改</td>            </tr>            <tr>                <td>长度标识符</td>                <td>2个字节</td>                <td>00<br>06</td>                <td>表示该数据帧中，从本子节到最后一个字节的字节个数，根据当前数据帧的情况设定</td>            </tr>                <tr>                <td>单元标识符</td>                <td>1个字节</td>                <td>03</td>                <td>客户机发起，服务器复制，这是一个站点号，在多设备通讯时，用来表示该数据的来源于哪个设备或者该数据要去往哪个设备</td>            </tr>            <tr>                <td>功能码</td>                <td>功能码</td>                <td>1个字节</td>                <td>05</td>                <td>05表示对线圈进行写操作</td>            </tr>            <tr>                <td rowspan="2">数据码</td>                <td>线圈地址</td>                <td>2个字节</td>                <td>00<br>10</td>                <td>表示对地址为17的线圈进行操作</td>            </tr>            <tr>                <td>操作命令</td>                <td>2个字节</td>                <td>FF<br>00</td>                <td>FF 00 表示将该线圈置1，00 00 表示将该线圈置0</td>            </tr></tbody></table><h2 id="ModbusTCP消息帧与串行链路消息帧的区别"><a href="#ModbusTCP消息帧与串行链路消息帧的区别" class="headerlink" title="ModbusTCP消息帧与串行链路消息帧的区别"></a>ModbusTCP消息帧与串行链路消息帧的区别</h2><p>MODBUS TCP和MODBUS RTU的差别不是很大。二者相同的地方是应用数据单元是一致的。差别是MODBUS TCP是传输在TCP/IP网络上的，多了一个报文头，少了CRC校验，采用TCP的502端口，RTU多了设备地址和CRC校验。<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/modbustcp.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Modbus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Modbus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modbus介绍</title>
      <link href="/2020/06/09/Modbus/Modbus%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/06/09/Modbus/Modbus%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介-Modbus是一种通信协议-用于不同厂商之间的设备交换数据"><a href="#1-简介-Modbus是一种通信协议-用于不同厂商之间的设备交换数据" class="headerlink" title="1.简介:Modbus是一种通信协议,用于不同厂商之间的设备交换数据"></a>1.简介:Modbus是一种通信协议,用于不同厂商之间的设备交换数据</h2><p>Modbus是一种串行通信协议，是Modicon公司（现在的施耐德电气 Schneider Electric）于1979年为使用可编程逻辑控制器（PLC）通信而发表。<br>Modbus已经成为工业领域通信协议的业界标准，并且现在是工业电子设备之间常用的连接方式。<br>Modbus在工业环境下很流行，因为它是公开发布而免版税的。它是为工业应用开发的，与其他标准相比，它相对易于部署和维护，除了要传输的数据格式的大小外，几乎没有其他限制。</p><h2 id="2-Modbus与RS485、RS232、RS422之间的关系"><a href="#2-Modbus与RS485、RS232、RS422之间的关系" class="headerlink" title="2.Modbus与RS485、RS232、RS422之间的关系"></a>2.Modbus与RS485、RS232、RS422之间的关系</h2><h3 id="2-1-1-什么是RS485"><a href="#2-1-1-什么是RS485" class="headerlink" title="2.1.1.什么是RS485"></a>2.1.1.什么是RS485</h3><p>通讯协议主要是实现两个设备之间的数据交换功能，通讯协议分硬件层协议和软件层协议。硬件层协议决定数据如何传输问题，比如要在设备1向设备2发送0x63，0x63的二进制数为0110 0011，这8个二进制数从设备1传输到设备2，涉及到1怎么传，0怎么传的问题，这就是硬件层要解决的问题。<br>RS485就是硬件层协议，同类的还有RS232，SPI，IIC等。</p><h3 id="2-1-2-RS485电气特性"><a href="#2-1-2-RS485电气特性" class="headerlink" title="2.1.2.RS485电气特性"></a>2.1.2.RS485电气特性</h3><p>RS485的电气特性：</p><ul><li>逻辑“1”以两线之间电压差+（2-6）V表示；</li><li>逻辑“0”以两线之间电压差-（2-6）V表示；<br>接口信号电平比RS232（3-15V）降低了，就不容易损坏接口电路的芯片，且该电平与TTL电平兼容，可方便与TTL电路连接。</li></ul><p>RS485标准只对接口的电气特性做出决定，而不涉及接插件、电缆、协议；因此用户需要再RS485应用的网络基础上建立自己的应用层通信协议。<br>而Modbus就是应用层协议的一种，还有其他协议，如电表的645协议，也可用自己制定简单的通讯协议。</p><h3 id="2-2-Modbus与RS485"><a href="#2-2-Modbus与RS485" class="headerlink" title="2.2.Modbus与RS485"></a>2.2.Modbus与RS485</h3><p>Modbus与RS485在OSI模型中的位置：<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/20200615155318.png" alt=""></p><p>上面说了，Modbus其实只是一种通信协议（软件），就像汉语和英语一样，就是一种交流语言，一种机器之间的交流语言。那么交流就要有沟通的桥梁或者说传输的介质（硬件），不同的介质（硬件平台）具有不同的电气特性和连接方式，比如RS232，RS485；<br>如果把Modbus比作英语，RS232比作印度人，RS485比作美国人，印度人之间讲英语时，理解为基于RS232的modbus通信，美国人之间讲英语时，理解为基于RS485的modbus通信。<br>总的来说，Modbus需要通过多种类型的物理介质进行通信，例如：</p><ul><li><p>串行RS232</p></li><li><p>串行RS485</p></li><li><p>串行RS422</p></li><li><p>以太网<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/Modbus-Communication-Physical-Media.gif" alt=""></p><p>最初的Modbus接口在RS-232串行通信上运行，但是大多数后来的Modbus实现使用RS-485，因为它允许：距离更长，速度更快，单个多点网络可接多个设备。<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/0910022P4-5.jpg" alt=""></p><h2 id="3-Modbus通信协议"><a href="#3-Modbus通信协议" class="headerlink" title="3.Modbus通信协议"></a>3.Modbus通信协议</h2><p>串行端口和以太网存在多种版本的Modbus协议，最常见的是:</p></li><li><p>Modbus RTU</p></li><li><p>Modbus ASCII</p></li><li><p>Modbus TCP</p><p>Modbus RTU,Modbus ASCII所用的物理硬件接口都是串行（Serial）通讯口（RS485，RS232，RS422），而Modbus TCP则是为了顺应当今世界发展潮流，什么都可以用Ethernet网或者Internet来连接，传送数据。所以有了Modbus TCP模式，该模式的硬件接口就是<strong>以太网</strong>（Ethernet）口了，也就是我们电脑上一般用的网络口。<br>Modbu还有一个扩展版本Modbus Plus（Modbus+或者MB+），该协议是Modicon专有的，和Modbus不同。它需要一个专门的协处理器来处理类似HDLC的高速令牌旋转。它使用1Mbit/s的双绞线，并且每个节点都有转换隔离装置，是一种采用转换/边缘触发而不是电压/水平触发的装置。连接Modbus Plus到计算机需要特别的接口，通常是支持ISA（SA85），PCI或者PMCIA总线的板卡。<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/Modbus-Different-Types.jpg" alt=""></p><h2 id="4-Modbus通信方式：主-从模式"><a href="#4-Modbus通信方式：主-从模式" class="headerlink" title="4.Modbus通信方式：主-从模式"></a>4.Modbus通信方式：主-从模式</h2><p>Modbus串行链路协议是一个主-从协议。<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/20170510133926081.png" alt=""></p><ul><li>至少且只有1个主机，其他都是从机</li><li>不管任何时候，从机都不能主动向主机发送数据</li><li>主机具有访问从机的权限，从机不可主动访问从机，任何一次数据交换，都要由主机发起</li></ul><p>在同一时刻，只有一个主节点连接于总线，一个或多个子节点 (最大编号为 247 ) 连接于同一个串行总线。子节点之间从不会互相通信。<br>主节点有两种方式与子节点发出请求：</p><p>（1） 单播模式：点对点发送，主节点发送请求，子节点回应。</p><p>（2） 广播模式：广播发送，主节点发送，子节点不回应。<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/Modbus-Message-Architecture.jpg" alt=""><br>Modbus设备使用Master-Slave（Ethernet称为Client-Server）技术进行通信，其中只有一个设备（Master 或Server）可以请求数据（称为查询）。</p><p>其他设备（Slaves或Clients）通过将请求的数据提供给主服务器或执行查询中请求的操作来进行响应。</p><p>从站是任何外围设备，例如I / O传感器，阀门，网络驱动器或其他测量类型的设备，它们处理信息并使用Modbus将其响应消息发送到主设备。</p><p>主机可以寻址单个从机或向所有从机发起广播消息。从站将分别对所有寻址到它们的消息查询返回响应，但不响应广播消息。</p><p>从站不会自行回复消息，而仅响应从主站发送的消息查询。</p><p>对于使用以太网的协议（例如Modbus TCP），任何设备都可以发出Modbus命令，因此所有设备都可以充当主设备，尽管通常只有一个设备充当主设备。</p><p><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/Modbus-Master-Query-and-Reply.gif" alt=""></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Modbus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Modbus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS中byte转String乱码</title>
      <link href="/2020/04/23/JS%E4%B8%ADbyte%E8%BD%ACString%E4%B9%B1%E7%A0%81/"/>
      <url>/2020/04/23/JS%E4%B8%ADbyte%E8%BD%ACString%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>项目中遇到一个问题，在JS中将byte数组转化为String的时候，有中文的情况下会出现乱码问题：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">decodeToString</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> String<span class="token punctuation">.</span>fromCharCode<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>String<span class="token punctuation">,</span> payload<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面这个方法，在没有中文的情况下是没有问题的，如果有中文则会出现乱码。<br>更换方法：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">utf8ByteToUnicodeStr</span><span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> unicodeStr <span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> pos <span class="token operator">&lt;</span> utf8Bytes<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">var</span> flag<span class="token operator">=</span> utf8Bytes<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> unicode <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>flag <span class="token operator">></span><span class="token operator">></span><span class="token operator">></span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            unicodeStr<span class="token operator">+</span><span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pos <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>flag <span class="token operator">&amp;</span><span class="token number">0xFC</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0xFC</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>            unicode <span class="token operator">=</span> <span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x3</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>            unicode <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">24</span><span class="token punctuation">;</span>            unicode <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">18</span><span class="token punctuation">;</span>            unicode <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">;</span>            unicode <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span>            unicode <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            unicodeStr<span class="token operator">+</span><span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span>unicode<span class="token punctuation">)</span> <span class="token punctuation">;</span>            pos <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>flag <span class="token operator">&amp;</span><span class="token number">0xF8</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0xF8</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>            unicode <span class="token operator">=</span> <span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">24</span><span class="token punctuation">;</span>            unicode <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">18</span><span class="token punctuation">;</span>            unicode <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">;</span>            unicode <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span>            unicode <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            unicodeStr<span class="token operator">+</span><span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span>unicode<span class="token punctuation">)</span> <span class="token punctuation">;</span>            pos <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>flag <span class="token operator">&amp;</span><span class="token number">0xF0</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0xF0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>            unicode <span class="token operator">=</span> <span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0xF</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">18</span><span class="token punctuation">;</span>            unicode <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">;</span>            unicode <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span>            unicode <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            unicodeStr<span class="token operator">+</span><span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span>unicode<span class="token punctuation">)</span> <span class="token punctuation">;</span>            pos <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>flag <span class="token operator">&amp;</span><span class="token number">0xE0</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0xE0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>            unicode <span class="token operator">=</span> <span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x1F</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">;</span><span class="token punctuation">;</span>            unicode <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span>            unicode <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            unicodeStr<span class="token operator">+</span><span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span>unicode<span class="token punctuation">)</span> <span class="token punctuation">;</span>            pos <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>flag <span class="token operator">&amp;</span><span class="token number">0xC0</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0xC0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//110</span>            unicode <span class="token operator">=</span> <span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span>            unicode <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            unicodeStr<span class="token operator">+</span><span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span>unicode<span class="token punctuation">)</span> <span class="token punctuation">;</span>            pos <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>            unicodeStr<span class="token operator">+</span><span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span>utf8Bytes<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pos <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> unicodeStr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 问题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL8连接配置</title>
      <link href="/2020/04/07/MySQL8%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/04/07/MySQL8%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-连接驱动类改为”com-mysql-cj-jdbc-Driver”"><a href="#1-连接驱动类改为”com-mysql-cj-jdbc-Driver”" class="headerlink" title="1.连接驱动类改为”com.mysql.cj.jdbc.Driver”"></a>1.连接驱动类改为”com.mysql.cj.jdbc.Driver”</h2><p>在之前的驱动类(com.mysql.jdbc.Driver.class)下有这样一段：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>意思就是要更换驱动类</p><h2 id="2-连接url参数配置"><a href="#2-连接url参数配置" class="headerlink" title="2.连接url参数配置"></a>2.连接url参数配置</h2><p>需要再url中指明编码格式，SSL，时区等信息<br>完整配置：</p><pre class=" language-yaml"><code class="language-yaml"> <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>3306/test<span class="token punctuation">?</span>useUnicode=true<span class="token important">&amp;characterEncoding</span>=utf<span class="token punctuation">-</span>8<span class="token important">&amp;useSSL</span>=false<span class="token important">&amp;serverTimezone</span>=GMT%2B8</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud之application.properties和bootstrap.properties区别</title>
      <link href="/2020/04/03/SpringCloud%E4%B9%8Bapplication-properties%E5%92%8Cbootstrap-properties%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/04/03/SpringCloud%E4%B9%8Bapplication-properties%E5%92%8Cbootstrap-properties%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="一、执行顺序"><a href="#一、执行顺序" class="headerlink" title="一、执行顺序"></a>一、执行顺序</h1><ul><li>bootstrap.yml（bootstrap.properties）先加载，application.yml（application.properties）后加载<br>bootstrap.yml（bootstrap.properties）:用来程序引导时执行，应用于更加早期配置信息读取，如可以使用来配置application.yml中使用到参数等<br>application.yml（application.properties): 应用程序特有配置信息，可以用来配置后续各个模块中需使用的公共参数等。</li></ul><h1 id="二、加载原理"><a href="#二、加载原理" class="headerlink" title="二、加载原理"></a>二、加载原理</h1><p>Spring中有上下文一说的，也叫Application Context。Application Context又是有父子关系的，所以必须要理解ApplicationContext是什么。<br>SpringCloud启动时，会先创建一个BootstrapContext，然后创建一个ApplicationContext，BootstrapContext是ApplicationContext的父上下文，<br>Bootstrap负责从外部源加载配置并解析，这两个上下文共用一个从外部获取的Environment。Bootstrap配置具有较高的优先级，不会被本地配置覆盖。<br>Bootstrap典型的应用场景是使用SpringConfig，这个时候你需要把配置信息配在bootstrap里面。Bootstrap属于引导配置，Application属于应用配置。</p><h1 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h1><ul><li>当使用外部配置中心服务的时候，你应该在 bootstrap.yml 里面指定 <code>名称</code> 或 <code>服务地址</code>，如使用Nacos配置中心：<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span><span class="token key atrule">application</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> auth<span class="token punctuation">-</span>service<span class="token key atrule">cloud</span><span class="token punctuation">:</span>  <span class="token key atrule">nacos</span><span class="token punctuation">:</span>    <span class="token key atrule">config</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> 127.0.0.1<span class="token punctuation">:</span><span class="token number">8848</span></code></pre></li><li>一些加密/解密的信息</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle中实现ID自增</title>
      <link href="/2020/03/23/Oracle%E4%B8%AD%E5%AE%9E%E7%8E%B0ID%E8%87%AA%E5%A2%9E/"/>
      <url>/2020/03/23/Oracle%E4%B8%AD%E5%AE%9E%E7%8E%B0ID%E8%87%AA%E5%A2%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="一、自增列"><a href="#一、自增列" class="headerlink" title="一、自增列"></a>一、自增列</h1><p>自增列是数据库中值随插入的每个行自动增加的一列。它最常用于主键或 ID 字段，这样每次增加一行时，不用指该字段的值，它就会自动增加，而且是唯一的。</p><p>当在 MySQL 中定义列时，我们可以指定一个名为 AUTO_INCREMENT 的参数。然后，每当将新值插入此表中时，放入此列的值比最后一个值加 1。</p><p>但很不幸，Oracle 没有 AUTO_INCREMENT 功能。 那要如何在Oracle中做到这一点呢？</p><h1 id="二、在Oracle11中设置自增字段"><a href="#二、在Oracle11中设置自增字段" class="headerlink" title="二、在Oracle11中设置自增字段"></a>二、在Oracle11中设置自增字段</h1><p>Oracle里的序列（SEQUENCE），可间接实现自增主键的作用。<br>序列（Sequence），又叫序列生成器，用于提供一系列的数字，开发人员使用序列生成唯一键。每次访问序列，序列按照一定的规律增加或者减少。<br>序列的定义存储在SYSTEM表空间中，序列不像表，它不会占用磁盘空间。<br>序列独立于事务，每次事务的提交和回滚都不会影响序列。</p><h2 id="1-创建序列"><a href="#1-创建序列" class="headerlink" title="1.创建序列"></a>1.创建序列</h2><pre class=" language-oraclesqlplus"><code class="language-oraclesqlplus">CREATE SEQUENCE TEST_ID_SEQINCREMENT BY 1START WITH 1MINVALUE 1 MAXVALUE 999999999NOCYCLENOCACHEORDER; </code></pre><p>SEQUENCE说明：</p><ol><li>INCREMENT BY: 用于指定序列增量（默认值：1），如果指定的是正整数，则序列号自动递增，如果指定的是负数，则自动递减。</li><li>START WITH  : 用于指定序列生成器生成的第一个序列号，当序列号顺序递增时默认值为序列号的最小值，当序列号顺序递减时默认值为序列号的最大值。</li><li>MINVALUE    : 用于指定序列生成器可以生成的最小序列号（必须小于或等于 START WITH，并且必须小于 MAXVALUE），默认值为 NOMINVALUE。</li><li>MAXVALUE    : 用于指定序列生成器可以生成的组大序列号（必须大于或等于 START WITH，并且必须大于 MINVALUE），默认为 NOMAXVALUE。</li><li>CYCLE or NOCYCLE : 用于指定在达到序列的最大值或最小值之后是否继续生成序列号，默认为 NOCYCLE。</li><li>CACHE or NOCACHE : 用于指定在内存中可以预分配的序列号个数（默认值：20）。</li><li>ORDER or NOORDER : 设置是否按照请求的顺序产生序列<br>如果需要删除序列，可以使用下面的命令：<pre class=" language-oraclesqlplus"><code class="language-oraclesqlplus">DROP SEQUENCE TEST_ID_SEQ;</code></pre>到这一步其实就已经可以实现字段自增，只要插入的时候，将 ID 的值设置为序列的下一个值 TEST_ID_SEQ.NEXTVAL 就可以了：<br>先创建测试表：<pre class=" language-oraclesqlplus"><code class="language-oraclesqlplus">CREATE TABLE "TEST" ( ID NUMBER(11) PRIMARY KEY, NAME VARCHAR2(50BYTE) NOT NULL);</code></pre>插入数据：<pre class=" language-oraclesqlplus"><code class="language-oraclesqlplus">SQL> INSERT INTO "TEST" ("ID", "NAME") VALUES (TEST_ID_SEQ.NEXTVAL, 'name1');SQL> INSERT INTO "TEST" ("ID", "NAME") VALUES (TEST_ID_SEQ.NEXTVAL, 'name2');SQL> INSERT INTO "TEST" ("ID", "NAME") VALUES (TEST_ID_SEQ.NEXTVAL, 'name3');SQL> SELECT * FROM "TEST";</code></pre></li></ol><p>ID   NAME</p><hr><p>100 name1<br>101 name2<br>102 name3</p><pre><code>为了简化插入操作，我们还可以创建一个触发器，当将数据插入到 "TEST" 表的时候，自动将最新的 ID 插入进去。## 2.创建触发器```oraclesqlplusCREATE OR REPLACE TRIGGER TEST_ID_SEQBEFORE INSERT ON "TEST"FOR EACH ROWBEGIN  SELECT TEST_ID_SEQ.NEXTVAL  INTO :NEW."ID"  FROM DUAL;END;</code></pre><p>插入数据：</p><pre class=" language-oraclesqlplus"><code class="language-oraclesqlplus">SQL> INSERT INTO "TEST" ("ID", "NAME") VALUES (NULL, 'name4');SQL> INSERT INTO "TEST" ("ID", "NAME") VALUES (NULL, 'name5');SQL> INSERT INTO "TEST" ("ID", "NAME") VALUES (NULL, 'name6');SQL> SELECT * FROM "TEST";ID   NAME---  ------100 name1101 name2102 name3103 name4104 name5105 name6</code></pre><h2 id="3-在MyBatis中运用"><a href="#3-在MyBatis中运用" class="headerlink" title="3.在MyBatis中运用"></a>3.在MyBatis中运用</h2><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>edp.davinci.dao.UserMapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>insert<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.test.Test<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--如果使用了触发器就不需要这一步--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selectKey</span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.lang.Long<span class="token punctuation">"</span></span> <span class="token attr-name">order</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>BEFORE<span class="token punctuation">"</span></span> <span class="token attr-name">keyProperty</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select TEST_ID_SEQ.NEXTVAL as id from dual     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selectKey</span><span class="token punctuation">></span></span>    insert "TEST"    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>trim</span> <span class="token attr-name">prefix</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(<span class="token punctuation">"</span></span> <span class="token attr-name">suffix</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>)<span class="token punctuation">"</span></span> <span class="token attr-name">suffixOverrides</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>,<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        ID,        NAME    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>trim</span><span class="token punctuation">></span></span>    values    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>trim</span> <span class="token attr-name">prefix</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span> (<span class="token punctuation">"</span></span> <span class="token attr-name">suffix</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>)<span class="token punctuation">"</span></span> <span class="token attr-name">suffixOverrides</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>,<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        #{ID, jdbcType=BIGINT},        #{NAME, jdbcType=VARCHAR}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>trim</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span></code></pre><h2 id="4-性能"><a href="#4-性能" class="headerlink" title="4.性能"></a>4.性能</h2><p>在数据库操作中，触发器的使用耗费系统资源相对较大。如果对于表容量相对较小的表格我们可以忽略触发器带来的性能影响。</p><p>考虑到大表操作的性能问题，需要尽可能的减少触发器的使用。对于以上操作，就可以抛弃触发器的使用，直接手动调用序列函数即可，但这样可能在程序维护上稍微带来一些不便。</p><h1 id="三、在Oracle12c中设置自增字段"><a href="#三、在Oracle12c中设置自增字段" class="headerlink" title="三、在Oracle12c中设置自增字段"></a>三、在Oracle12c中设置自增字段</h1><p>在 Oracle 12c 中设置自增字段就简单多了，因为 Oracle 12c 提供了 IDENTITY 属性:</p><pre class=" language-oraclesqlplus"><code class="language-oraclesqlplus">CREATE TABLE "TEST" (    ID NUMBER(11) GENERATED BY DEFAULT ON NULL AS IDENTITY,    NAME VARCHAR2(50BYTE) NOT NULL);</code></pre><p>这样就搞定了！和 MySQL 一样简单！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRLF导致shell脚本报错</title>
      <link href="/2020/03/11/CRLF%E5%AF%BC%E8%87%B4shell%E8%84%9A%E6%9C%AC%E6%8A%A5%E9%94%99/"/>
      <url>/2020/03/11/CRLF%E5%AF%BC%E8%87%B4shell%E8%84%9A%E6%9C%AC%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h1 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h1><p>开发的时候在Windows环境中打包了一个rpm包，放到CentOS去执行的时候，当运行start.sh文件的时候，一直报错 “No such file or directory”。</p><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>Linux和Windows文本文件的行结束标志不同。在Linux中，文本文件用”/n”表示回车换行，而Windows用”/r/n”表示回车换行。<br>有时候在Windows编写shell脚本时需要注意这个，否则shell脚本会报”No such file or directory”或”command not found line x”之类的错误。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><ol><li>在CentOS中，直接使用vi编辑器重新编写shell脚本</li><li>使用dos2unix工具将DOS格式文本文件转换成Unix格式或Linux格式</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> 问题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keycloak配置</title>
      <link href="/2020/03/01/Keycloak%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/03/01/Keycloak%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Keycloak切换MySQL数据库"><a href="#Keycloak切换MySQL数据库" class="headerlink" title="Keycloak切换MySQL数据库"></a>Keycloak切换MySQL数据库</h1><p>Keycloak默认使用嵌入式关系数据库H2，真实生产环境肯定是不符合要求的，在其官方文档中有这么一段话：</p><blockquote><p>We highly recommend that you replace it with a more production ready external database.<br>  The H2 database is not very viable in high concurrency situations and should not be used in a cluster either.</p></blockquote><p>下面列出Keycloak配置MySQL的步骤。</p><a id="more"></a><h2 id="MySQL配置"><a href="#MySQL配置" class="headerlink" title="MySQL配置"></a>MySQL配置</h2><h3 id="下载JDBC驱动，将驱动安装到Keycloak中"><a href="#下载JDBC驱动，将驱动安装到Keycloak中" class="headerlink" title="下载JDBC驱动，将驱动安装到Keycloak中"></a>下载JDBC驱动，将驱动安装到Keycloak中</h3><ol><li><p>下载JDBC驱动，可从官网或maven仓库直接下载，不再赘述。我下载的版本是 <code>mysql-connector-java-8.0.19.jar</code></p></li><li><p>在keycloak-9.0.0\modules\system\layers\base下新建目录com\mysql\main,将上面下载的jar包放入此目录。<br>目录名称可随意修改，不过官方推荐使用包路径作为目录。</p><blockquote><p>The convention is use the Java package name of the JDBC driver for the name of the directory structure. For PostgreSQL, create the directory org/postgresql/main.</p></blockquote></li><li><p>在jar包同级目录下新建文件module.xml，文件内容如下:</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>urn:jboss:module:1.3<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mysql<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource-root</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql-connector-java-8.0.19.jar<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>javax.api<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>javax.transaction.api<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span></code></pre><p>其中name应为包名，后文配置数据源过程中会用到此name。dependencies包含可能会用到的依赖项。</p><h3 id="在Keycloak配置文件中声明使用下载的MySQL驱动"><a href="#在Keycloak配置文件中声明使用下载的MySQL驱动" class="headerlink" title="在Keycloak配置文件中声明使用下载的MySQL驱动"></a>在Keycloak配置文件中声明使用下载的MySQL驱动</h3></li><li><p>编辑standalone.xml,位置在keycloak-9.0.0\standalone\configuration\standalone.xml(若为集群模式编辑standalone-ha.xml)，<br>寻找drivers标签，默认有一个h2数据库的配置，我们要在同级增加一个mysql的配置，内容如下：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>driver</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span> <span class="token attr-name">module</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mysql<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xa-datasource-class</span><span class="token punctuation">></span></span>com.mysql.cj.jdbc.MysqlXADataSource<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xa-datasource-class</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>driver</span><span class="token punctuation">></span></span></code></pre><p>module即为之前module.xml中定义的name，此处的name为driver的名称，在接下来的数据源配置中会使用到。<br>此处注意，xa-datasource-class的路径可能会随着JDBC版本变化而变化，可从jar包中寻找到正确的路径。</p></li><li><p>向上寻找datasources标签，默认此处有两项datasource，我们注释掉名称为KeycloakDS的数据源，并加上mysql的。<br>注意不要把ExampleDS也注释掉，启动会报错的。新增内容如下：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>datasource</span> <span class="token attr-name">jndi-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java:jboss/datasources/KeycloakDS<span class="token punctuation">"</span></span> <span class="token attr-name">pool-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>KeycloakDS<span class="token punctuation">"</span></span> <span class="token attr-name">enabled</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">use-java-context</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>connection-url</span><span class="token punctuation">></span></span>jdbc:mysql://localhost:3306/keycloak<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>connection-url</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>driver</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>driver</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pool</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>max-pool-size</span><span class="token punctuation">></span></span>20<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>max-pool-size</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pool</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>security</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user-name</span><span class="token punctuation">></span></span>root<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user-name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>password</span><span class="token punctuation">></span></span>root<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>password</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>security</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>datasource</span><span class="token punctuation">></span></span></code></pre><p>driver处对应上面定义driver标签中的name。其余项目见文知意，根据具体项目修改即可，此处需要手工建立keycloak库。</p></li><li><p>寻找name为connectionsJpa的spi标签，此标签内可定义诸多数据源选项，例如showsql，formatsql等等，可根据需要修改。支持的配置项详见官方文档。</p></li><li><p>配置完成，启动对应的bat或shell文件，通过数据库工具可以看到自动新建了93张表。</p></li></ol><h1 id="Keycloak远程访问"><a href="#Keycloak远程访问" class="headerlink" title="Keycloak远程访问"></a>Keycloak远程访问</h1><p>keycloak使用JBoss服务器作为容器，而JBoss服务器由于一些安全问题默认是不允许外部访问的（比如远程连接），只允许本机访问，即localhost，<br>所以要想远程连接keycloak，就要更改一下设置。配置外网访问有下面两种方式。</p><ol><li>启动keycloak的时候在后面加上参数 -b  0.0.0.0<pre><code>./standalone.bat -b 0.0.0.0</code></pre></li><li>修改keycloak/standalone/configuration/standalone.xml中修改一些配置来启动远程连接,找到<code>interfaces</code>标签，修改为下面的内容<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>interfaces</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>interface</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>management<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>inet-address</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${jboss.bind.address.management:127.0.0.1}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>interface</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>interface</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>public<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>inet-address</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${jboss.bind.address:0.0.0.0}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>interface</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>interfaces</span><span class="token punctuation">></span></span></code></pre></li></ol><p>```</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 单点登录(SSO) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Keycloak </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OAuth2协议-授权模式详解</title>
      <link href="/2020/01/13/OAuth2%E5%8D%8F%E8%AE%AE-%E6%8E%88%E6%9D%83%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/01/13/OAuth2%E5%8D%8F%E8%AE%AE-%E6%8E%88%E6%9D%83%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-OAuth-2-0"><a href="#什么是-OAuth-2-0" class="headerlink" title="什么是 OAuth 2.0"></a>什么是 OAuth 2.0</h1><p>OAuth 2.0 是一个行业的标准授权协议。<br>OAuth 2.0 专注于简化客户端开发人员，同时为 Web 应用程序，桌面应用程序，手机和客厅设备提供特定的授权流程。<br>下面我们对OAuth2的4中授权模式进行详细的介绍。主要参考资料<a href="http://www.rfcreader.com/#rfc6749" target="_blank" rel="noopener">RFC6749</a></p><a id="more"></a><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>在详细讲解OAuth 2.0之前，需要了解几个专用名词。</p><blockquote><p>（1）Third-party application：第三方应用程序，本文中又称”客户端”（client），使用资源所有者的授权代表资源所有者发起对受保护资源的请求的应用程序。如：web网站，移动应用等。<br> （2）HTTP service：HTTP服务提供商，本文中简称”服务提供商”。<br> （3）Resource Owner：资源所有者，本文中又称”用户”（user）。<br> （4）User Agent：用户代理，帮助资源所有者与客户端沟通的工具，一般为 web 浏览器，移动 APP 等。<br> （5）Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器。<br> （6）Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</p></blockquote><h1 id="OAuth思路"><a href="#OAuth思路" class="headerlink" title="OAuth思路"></a>OAuth思路</h1><p>OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。<br>“客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。<br>“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。<br>例如：假如我想要在 coding.net 这个网站上用 github.com 的账号登录。那么 coding 相对于 github 就是一个客户端。而我们用什么操作的呢？浏览器，这就是一个用户代理。当从 github 的授权服务器获得 token 后，coding 是需要请求 github 账号信息的，从哪请求？从 github 的资源服务器。</p><h1 id="协议流程"><a href="#协议流程" class="headerlink" title="协议流程"></a>协议流程</h1><p><img src="http://nblog.oss-cn-shanghai.aliyuncs.com/20200113/oauth2-roles.jpg" alt=""></p><blockquote><pre><code>+--------+                               +---------------+  |        |--(A)- Authorization Request -&gt;|   Resource    |  |        |                               |     Owner     |  |        |&lt;-(B)-- Authorization Grant ---|               |  |        |                               +---------------+  |        |  |        |                               +---------------+  |        |--(C)-- Authorization Grant --&gt;| Authorization |  | Client |                               |     Server    |  |        |&lt;-(D)----- Access Token -------|               |  |        |                               +---------------+  |        |  |        |                               +---------------+  |        |--(E)----- Access Token ------&gt;|    Resource   |  |        |                               |     Server    |  |        |&lt;-(F)--- Protected Resource ---|               |  +--------+                               +---------------+</code></pre></blockquote><ul><li>(A) Client 请求 Resource Owner 的授权。授权请求可以直接向 Resource Owner 请求，也可以通过 Authorization Server 间接的进行。</li><li>(B) Client 获得授权许可。</li><li>(C) Client 向 Authorization Server 请求访问令牌。</li><li>(D) Authorization Server 验证授权许可，如果有效则颁发访问令牌。</li><li>(E) Client 通过访问令牌从 Resource Server 请求受保护资源。</li><li>(F) Resource Server 验证访问令牌，有效则响应请求。<br>不难看出来，上面六个步骤之中，B是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。<br>下面一一讲解客户端获取授权的四种模式。<h1 id="授权模式"><a href="#授权模式" class="headerlink" title="授权模式"></a>授权模式</h1><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2>一个客户端想要获得授权，就需要先到服务商那注册你的应用。一般需要你提供下面这些信息：<ul><li>应用名称</li><li>应用网站</li><li>重定向 URI 或回调 URL（redirect_uri），重定向 URI 是服务商在用户授权（或拒绝）应用程序之后重定向用户的地址，因此也是用于处理授权代码或访问令牌的应用程序的一部分。</li><li>客户端标识 client_id</li><li>客户端密钥 client_secret<br>client_id 用来表识客户端（公开），client_secret 用来验证客户端身份（保密）。<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。</li><li>授权码模式（authorization code）：服务器与客户端配合使用。</li><li>隐式模式（implicit）：用于移动应用程序或 Web 应用程序（在用户设备上运行的应用程序）。</li><li>密码模式（resource owner password credentials）：资源所有者和客户端之间具有高度信任时（例如，客户端是设备的操作系统的一部分，或者是一个高度特权应用程序），以及当其他授权许可类型（例如授权码）不可用时被使用。</li><li>客户端模式（client credentials）：当客户端代表自己表演（客户端也是资源所有者）或者基于与授权服务器事先商定的授权请求对受保护资源的访问权限时，客户端凭据被用作为授权许可。<h3 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h3>授权码模式（authorization code）是功能最完整、流程最严密的授权模式。<br>它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。<pre class=" language-text"><code class="language-text">  +----------+  | Resource |  |   Owner  |  |          |  +----------+       ^       |      (B)  +----|-----+          Client Identifier      +---------------+  |         -+----(A)-- & Redirection URI ---->|               |  |  User-   |                                 | Authorization |  |  Agent  -+----(B)-- User authenticates --->|     Server    |  |          |                                 |               |  |         -+----(C)-- Authorization Code ---<|               |  +-|----|---+                                 +---------------+    |    |                                         ^      v   (A)  (C)                                        |      |    |    |                                         |      |    ^    v                                         |      |  +---------+                                      |      |  |         |>---(D)-- Authorization Code ---------'      |  |  Client |          & Redirection URI                  |  |         |                                             |  |         |<---(E)----- Access Token -------------------'</code></pre></li></ul></li></ul><p>（A）用户访问客户端，后者将前者导向认证服务器。</p><p>（B）用户选择是否给予客户端授权。</p><p>（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。</p><p>（D）客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</p><p>（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。<br>具体说明，这里以 coding 和 github 为例。当我想在 coding 上通过 github 账号登录时：</p><h4 id="1-Get请求"><a href="#1-Get请求" class="headerlink" title="1.Get请求"></a>1.<code>Get请求</code></h4><blockquote><p><a href="https://github.com/login/oauth/authorize" target="_blank" rel="noopener">https://github.com/login/oauth/authorize</a>?<br>   response_type=code&amp;<br>   client_id=xxx&amp;<br>   redirect_uri=<a href="https://coding.net/api/oauth/github/callback&amp;" target="_blank" rel="noopener">https://coding.net/api/oauth/github/callback&amp;</a><br>   scope=user:email</p></blockquote><table><thead><tr><th align="left">字段</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">response_type</td><td align="left">必须，固定为 code，表示这是一个授权码请求。</td></tr><tr><td align="left">client_id</td><td align="left">必须，在 github 注册获得的客户端 ID。</td></tr><tr><td align="left">redirect_uri</td><td align="left">可选，通过客户端注册的重定向 URI（一般要求且与注册时一致）。</td></tr><tr><td align="left">scope</td><td align="left">可选，请求资源范围，多个空格隔开。</td></tr><tr><td align="left">state</td><td align="left">必须，可选（推荐），如果存在，原样返回给客户端。</td></tr><tr><td align="left">返回值</td><td align="left"></td></tr><tr><td align="left">字段</td><td align="left">描述</td></tr><tr><td align="left">:—</td><td align="left">:—:</td></tr><tr><td align="left">code</td><td align="left">必须。授权码</td></tr><tr><td align="left">state</td><td align="left">如果出现在请求中，必须包含。</td></tr><tr><td align="left">#### 2.<code>Post请求获取令牌token</code>，当获取到授权码 code 后，客户端需要用它获取访问令牌：</td><td align="left"></td></tr></tbody></table><blockquote><p><a href="https://github.com/login/oauth/access_token" target="_blank" rel="noopener">https://github.com/login/oauth/access_token</a>?<br>   client_id=xxx&amp;<br>   client_secret=xxxx&amp;<br>   grant_type=authorization_code&amp;<br>   code=xxx&amp;<br>   redirect_uri=<a href="https://coding.net/api/oauth/github/callback" target="_blank" rel="noopener">https://coding.net/api/oauth/github/callback</a></p></blockquote><table><thead><tr><th align="left">字段</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">client_id</td><td align="left">必须，客户端标识。</td></tr><tr><td align="left">client_secret</td><td align="left">必须，客户端密钥。</td></tr><tr><td align="left">grant_type</td><td align="left">必须，固定为 authorization_code／refresh_token。</td></tr><tr><td align="left">code</td><td align="left">必须，上一步获取到的授权码。</td></tr><tr><td align="left">redirect_uri</td><td align="left">必须，完成授权后的回调地址，与注册时一致。</td></tr><tr><td align="left">返回值：</td><td align="left"></td></tr></tbody></table><blockquote><p>{<br>   “access_token”:”a14afef0f66fcffce3e0fcd2e34f6ff4”,<br>   “token_type”:”bearer”,<br>   “expires_in”:3920,<br>   “refresh_token”:”5d633d136b6d56a41829b73a424803ec”<br>}</p></blockquote><table><thead><tr><th align="left">字段</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">access_token</td><td align="left">这个就是最终获取到的令牌。</td></tr><tr><td align="left">token_type</td><td align="left">令牌类型，常见有 bearer/mac/token（可自定义）。</td></tr><tr><td align="left">expires_in</td><td align="left">失效时间。</td></tr><tr><td align="left">refresh_token</td><td align="left">刷新令牌，用来刷新 access_token。</td></tr><tr><td align="left">获取资源服务器资源，拿着 access_token 就可以获取账号的相关信息了。</td><td align="left"></td></tr></tbody></table><h3 id="隐式模式"><a href="#隐式模式" class="headerlink" title="隐式模式"></a>隐式模式</h3><p>该方式一般用于移动客户端或网页客户端。隐式授权类似于授权码授权，不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p><pre class=" language-text"><code class="language-text">      +----------+      | Resource |      |  Owner   |      |          |      +----------+           ^           |          (B)      +----|-----+          Client Identifier     +---------------+      |         -+----(A)-- & Redirection URI --->|               |      |  User-   |                                | Authorization |      |  Agent  -|----(B)-- User authenticates -->|     Server    |      |          |                                |               |      |          |<---(C)--- Redirection URI ----<|               |      |          |          with Access Token     +---------------+      |          |            in Fragment      |          |                                +---------------+      |          |----(D)--- Redirection URI ---->|   Web-Hosted  |      |          |          without Fragment      |     Client    |      |          |                                |    Resource   |      |     (F)  |<---(E)------- Script ---------<|               |      |          |                                +---------------+      +-|--------+        |    |       (A)  (G) Access Token        |    |        ^    v      +---------+      |         |      |  Client |      |         |      +---------+   Note: The lines illustrating steps (A) and (B) are broken into two   parts as they pass through the user-agent.</code></pre><p>它的步骤如下:</p><p>（A）客户端将用户导向认证服务器。</p><p>（B）用户决定是否给于客户端授权。</p><p>（C）假设用户给予授权，认证服务器将用户导向客户端指定的”重定向URI”，并在URI的Hash部分包含了访问令牌。</p><p>（D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。</p><p>（E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。</p><p>（F）浏览器执行上一步获得的脚本，提取出令牌。</p><p>（G）浏览器将令牌发给客户端。<br>同样以 coding 和 github 为例： </p><blockquote><p><a href="https://github.com/login/oauth/authorize" target="_blank" rel="noopener">https://github.com/login/oauth/authorize</a>?<br>   response_type=token&amp;<br>   client_id=xxx&amp;<br>   redirect_uri=<a href="https://coding.net/api/oauth/github/callback&amp;" target="_blank" rel="noopener">https://coding.net/api/oauth/github/callback&amp;</a><br>   scope=user:email</p></blockquote><table><thead><tr><th align="left">字段</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">response_type</td><td align="left">必须。固定为 token</td></tr><tr><td align="left">client_id</td><td align="left">必须。当客户端被注册时，有授权服务器分配的客户端标识。</td></tr><tr><td align="left">redirect_uri</td><td align="left">可选。由客户端注册的重定向URI。</td></tr><tr><td align="left">scope</td><td align="left">可选。请求可能的作用域。</td></tr><tr><td align="left">state</td><td align="left">可选(推荐)。任何需要被传递到客户端请求的URI客户端的状态。</td></tr><tr><td align="left">返回值：</td><td align="left"></td></tr><tr><td align="left">字段</td><td align="left">描述</td></tr><tr><td align="left">:—</td><td align="left">:—</td></tr><tr><td align="left">access_token</td><td align="left">必须。授权服务器分配的访问令牌。</td></tr><tr><td align="left">token_type</td><td align="left">必须。令牌类型。该值大小写不敏感。</td></tr><tr><td align="left">redirect_uri</td><td align="left">可选。表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</td></tr><tr><td align="left">scope</td><td align="left">可选。表示权限范围，如果与客户端申请的范围一致，此项可省略。</td></tr><tr><td align="left">state</td><td align="left">如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</td></tr><tr><td align="left">通过上面的步骤拿到token后就可以进行后续自己想要的操作了。</td><td align="left"></td></tr><tr><td align="left">### 密码模式</td><td align="left"></td></tr><tr><td align="left">密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。</td><td align="left"></td></tr></tbody></table><p>在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p><pre class=" language-text"><code class="language-text">      +----------+      | Resource |      |  Owner   |      |          |      +----------+           v           |    Resource Owner          (A) Password Credentials           |           v      +---------+                                  +---------------+      |         |>--(B)---- Resource Owner ------->|               |      |         |         Password Credentials     | Authorization |      | Client  |                                  |     Server    |      |         |<--(C)---- Access Token ---------<|               |      |         |    (w/ Optional Refresh Token)   |               |      +---------+                                  +---------------+</code></pre><p>它的步骤如下：</p><p>（A）用户向客户端提供用户名和密码。</p><p>（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。</p><p>（C）认证服务器确认无误后，向客户端提供访问令牌。</p><p>B步骤中，客户端发出的POST请求</p><blockquote><p><a href="https://oauth.example.com/token?grant_type=password&amp;username=USERNAME&amp;password=PASSWORD&amp;client_id=CLIENT_ID" target="_blank" rel="noopener">https://oauth.example.com/token?grant_type=password&amp;username=USERNAME&amp;password=PASSWORD&amp;client_id=CLIENT_ID</a></p></blockquote><table><thead><tr><th align="left">字段</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">grant_type</td><td align="left">必须。固定为 password。</td></tr><tr><td align="left">username</td><td align="left">必须。UTF-8 编码的资源拥有者用户名。</td></tr><tr><td align="left">password</td><td align="left">必须。UTF-8 编码的资源拥有者密码。</td></tr><tr><td align="left">scope</td><td align="left">可选。授权范围。</td></tr><tr><td align="left">返回值：</td><td align="left"></td></tr></tbody></table><blockquote><p>{<br>   “access_token”  : “…”,<br>   “token_type”    : “…”,<br>   “expires_in”    : “…”,<br>   “refresh_token” : “…”,<br>}</p></blockquote><p>如果授权服务器验证成功，那么将直接返回令牌 token，改客户端已被授权。</p><h3 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h3><p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。<br>这种模式只需要提供 client_id 和 client_secret 即可获取授权。一般用于后端 API 的相关操作。</p><pre class=" language-text"><code class="language-text">      +---------+                                  +---------------+      |         |                                  |               |      |         |>--(A)- Client Authentication --->| Authorization |      | Client  |                                  |     Server    |      |         |<--(B)---- Access Token ---------<|               |      |         |                                  |               |      +---------+                                  +---------------+</code></pre><p>它的步骤如下：</p><p>（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。</p><p>（B）认证服务器确认无误后，向客户端提供访问令牌。</p><p><code>POST 请求</code> 客户端凭证</p><blockquote><p><a href="https://oauth.example.com/token?grant_type=client_credentials&amp;username=USERNAME&amp;password=PASSWORD&amp;client_id=CLIENT_ID" target="_blank" rel="noopener">https://oauth.example.com/token?grant_type=client_credentials&amp;username=USERNAME&amp;password=PASSWORD&amp;client_id=CLIENT_ID</a></p></blockquote><table><thead><tr><th align="left">字段</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">grant_type</td><td align="left">必须。固定为 client_credentials。</td></tr><tr><td align="left">scope</td><td align="left">可选。授权的作用域。</td></tr><tr><td align="left">返回值：</td><td align="left"></td></tr></tbody></table><blockquote><p>  {<br>      “access_token”  : “…”,<br>      “token_type”    : “…”,<br>      “expires_in”    : “…”,<br>    }</p></blockquote><h3 id="刷新更新（POST请求）"><a href="#刷新更新（POST请求）" class="headerlink" title="刷新更新（POST请求）"></a>刷新更新（<code>POST请求</code>）</h3><pre class=" language-text"><code class="language-text">   +--------+                                           +---------------+   |        |--(A)------- Authorization Grant --------->|               |   |        |                                           |               |   |        |<-(B)----------- Access Token -------------|               |   |        |               & Refresh Token             |               |   |        |                                           |               |   |        |                            +----------+   |               |   |        |--(C)---- Access Token ---->|          |   |               |   |        |                            |          |   |               |   |        |<-(D)- Protected Resource --| Resource |   | Authorization |   | Client |                            |  Server  |   |     Server    |   |        |--(E)---- Access Token ---->|          |   |               |   |        |                            |          |   |               |   |        |<-(F)- Invalid Token Error -|          |   |               |   |        |                            +----------+   |               |   |        |                                           |               |   |        |--(G)----------- Refresh Token ----------->|               |   |        |                                           |               |   |        |<-(H)----------- Access Token -------------|               |   +--------+           & Optional Refresh Token        +---------------+</code></pre><p>上面获取的access_token是有时效性的，再token失效前，我们需要去刷新token</p><blockquote><p><a href="https://github.com/login/oauth/access_token" target="_blank" rel="noopener">https://github.com/login/oauth/access_token</a>?<br>   client_id=xxx&amp;<br>   client_secret=xxxx&amp;<br>   redirect_uri=<a href="https://coding.net/api/oauth/github/callback&amp;" target="_blank" rel="noopener">https://coding.net/api/oauth/github/callback&amp;</a><br>   grant_type=refresh_token&amp;<br>   refresh_token=xxx</p></blockquote><table><thead><tr><th align="left">字段</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">client_id</td><td align="left">必须</td></tr><tr><td align="left">client_secret</td><td align="left">必须</td></tr><tr><td align="left">redirect_uri</td><td align="left">必须</td></tr><tr><td align="left">grant_type</td><td align="left">必须，固定为 refresh_token</td></tr><tr><td align="left">refresh_token</td><td align="left">必须，上面获取到的 refresh_token</td></tr></tbody></table><blockquote><p>注意refresh_token 只有在 access_token 过期时才能使用，并且只能使用一次。当换取到的 access_token 再次过期时，使用新的 refresh_token 来换取 access_token</p></blockquote><blockquote><p>友情链接：<br><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a><br><a href="https://deepzz.com/post/what-is-oauth2-protocol.html" target="_blank" rel="noopener">https://deepzz.com/post/what-is-oauth2-protocol.html</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OAuth2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oauth2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OAuth2-类比讲解什么是OAuth2</title>
      <link href="/2020/01/13/OAuth2-%E7%B1%BB%E6%AF%94%E8%AE%B2%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AFOAuth2/"/>
      <url>/2020/01/13/OAuth2-%E7%B1%BB%E6%AF%94%E8%AE%B2%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AFOAuth2/</url>
      
        <content type="html"><![CDATA[<h1 id="OAuth2简介"><a href="#OAuth2简介" class="headerlink" title="OAuth2简介"></a>OAuth2简介</h1><p><a href="https://oauth.net/2/" target="_blank" rel="noopener">OAuth2.0</a>是目前最流行的授权机制，用来授权第三方应用，获取用户数据。<br>官方的定义：</p><blockquote><p>An open protocol to allow secure authorization in a simple and standard method from web, mobile and desktop applications.</p></blockquote><p>一个允许从Web、移动和桌面应用程序简单和标准方法进行安全授权的开放协议。</p><blockquote><p>The OAuth 2.0 authorization framework enables third-party applications to obtain limited access to a web service.</p></blockquote><p>OAuth 2.0 授权框架使第三方应用程序能够获得对 Web 服务的有限访问权限。<br>从官网的解释就可以知道它可以完成如下两件事：</p><ol><li>对你的应用站点进行安全授权</li><li>使第三方应用程序能够获得对 Web 服务的有限访问权限<br>下面我们通过一个简单的类比，来理解下，OAuth 2.0 到底是什么。</li></ol><a id="more"></a><h1 id="快递员问题"><a href="#快递员问题" class="headerlink" title="快递员问题"></a>快递员问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ol><li>我住在一个大型的居民小区。</li><li>小区有门禁系统。</li><li>进入的时候需要输入密码。</li><li>我经常网购和外卖，每天都有快递员来送货。我必须找到一个办法，让快递员通过门禁系统，进入小区。</li><li>如果我把自己的密码，告诉快递员，他就拥有了与我同样的权限，这样好像不太合适。万一我想取消他进入小区的权力，也很麻烦，我自己的密码也得跟着改了，还得通知其他的快递员。<br>有没有一种办法，让快递员能够自由进入小区，又不必知道小区居民的密码，而且他的唯一权限就是送货，其他需要密码的场合，他都没有权限？<h2 id="授权机制设计"><a href="#授权机制设计" class="headerlink" title="授权机制设计"></a>授权机制设计</h2>于是，我设计了一套授权机制。</li><li>第一步，门禁系统的密码输入器下面，增加一个按钮，叫做”获取授权”。快递员需要首先按这个按钮，去申请授权。</li><li>第二步，他按下按钮以后，屋主（也就是我）的手机就会跳出对话框：有人正在要求授权。系统还会显示该快递员的姓名、工号和所属的快递公司。<br>我确认请求属实，就点击按钮，告诉门禁系统，我同意给予他进入小区的授权。</li><li>第三步，门禁系统得到我的确认以后，向快递员显示一个进入小区的令牌（access token）。令牌就是类似密码的一串数字，只在短期内（比如七天）有效。</li><li>第四步，快递员向门禁系统输入令牌，进入小区。<br>有人可能会问，为什么不是远程为快递员开门，而要为他单独生成一个令牌？这是因为快递员可能每天都会来送货，第二天他还可以复用这个令牌。另外，有的小区有多重门禁，快递员可以使用同一个令牌通过它们。<h1 id="互联网场景"><a href="#互联网场景" class="headerlink" title="互联网场景"></a>互联网场景</h1>我们把上面的例子搬到互联网，就是 OAuth 的设计了。<br>首先，居民小区就是储存用户数据的网络服务。比如，微信储存了我的好友信息，获取这些信息，就必须经过微信的”门禁系统”。<br>其次，快递员（或者说快递公司）就是第三方应用，想要穿过门禁系统，进入小区。<br>最后，我就是用户本人，同意授权第三方应用进入小区，获取我的数据。</li></ol><p><strong>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</strong></p><h1 id="令牌（Token）与密码（Password）"><a href="#令牌（Token）与密码（Password）" class="headerlink" title="令牌（Token）与密码（Password）"></a>令牌（Token）与密码（Password）</h1><p>令牌与密码的作用是一样的，都可以进入系统，但是有三点差异。<br>（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p><p>（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</p><p>（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p><p>上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。<br><strong>注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。 这也是为什么令牌的有效期，一般都设置得很短的原因。</strong><br>OAuth 2.0 对于如何颁发令牌的细节，规定得非常详细。具体来说，一共分成四种授权类型（authorization grant），即四种颁发令牌的方式，适用于不同的互联网场景。右面会具体介绍这四种类型。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OAuth2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oauth2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高频使用的Git命令集合</title>
      <link href="/2019/12/28/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/%E9%AB%98%E9%A2%91%E4%BD%BF%E7%94%A8%E7%9A%84Git%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/"/>
      <url>/2019/12/28/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/%E9%AB%98%E9%A2%91%E4%BD%BF%E7%94%A8%E7%9A%84Git%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>汇总下我在项目中高频使用的git命令及姿势</p><a id="more"></a><p>不是入门文档，官方文档肯定比我全面，这里是结合实际业务场景输出</p><p>使用的 Git版本：git version 2.24.0</p><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p>查看日志，常规操作，必备</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 输出概要日志,这条命令等同于</span><span class="token comment" spellcheck="true"># git log --pretty=oneline --abbrev-commit</span><span class="token function">git</span> log --oneline<span class="token comment" spellcheck="true"># 指定最近几个提交可以带上 - + 数字</span><span class="token function">git</span> log --oneline -5<span class="token comment" spellcheck="true"># 提供类似 GUI 工具的 log 展示</span><span class="token function">git</span> log --graph --date<span class="token operator">=</span>relative --pretty<span class="token operator">=</span>tformat:<span class="token string">'%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%an %ad)%Creset'</span></code></pre><p><img src="/images/2019/12/28/6b96a520-2987-11ea-9c54-0994549fb268.png" alt="image.png"></p><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>查看工作区状态的东东，不如GUI直观，但是命令行也有一些用的</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 等同 git status --long,查看当前工作区暂存区变动</span><span class="token function">git</span> status<span class="token comment" spellcheck="true"># 概要信息 (--short)</span><span class="token function">git</span> status -s<span class="token comment" spellcheck="true"># 查询工作区中是否有stash存在（暂存的东西）,有则提醒该工作区有几个 stash</span><span class="token function">git</span> status  --show-stash</code></pre><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p>用来切换到对应记录的,可以基于分支,提交,标签。</p><p>切提交和标签一般用来热修复或者老版本需要加新特性。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 分支切换</span><span class="token function">git</span> checkout dev <span class="token comment" spellcheck="true"># local branch</span><span class="token comment" spellcheck="true"># 切换远程分支</span><span class="token function">git</span> checkout origin/test <span class="token comment" spellcheck="true"># remote branch</span><span class="token comment" spellcheck="true"># 基于远程分支创建本地分支，并跟踪对应来自 'origin' 的远程分支</span><span class="token function">git</span> checkout --track origin/feature-test <span class="token comment" spellcheck="true"># new local branch wih remote branch</span><span class="token comment" spellcheck="true"># 基于本地分支开出新分支</span><span class="token function">git</span> checkout -b testbranch <span class="token comment" spellcheck="true"># new local branch with current branch</span><span class="token comment" spellcheck="true"># 彻底丢弃某个文件的改动</span><span class="token function">git</span> checkout -- <span class="token function">file</span><span class="token comment" spellcheck="true"># 放弃本地所有改动</span><span class="token function">git</span> checkout <span class="token keyword">.</span><span class="token comment" spellcheck="true"># 切换上一个分支</span><span class="token function">git</span> checkout -</code></pre><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>天天打交道的命令，这里说一些很常见的姿势</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 新修改的内容,添加到上次提交中,减少提交的日志</span><span class="token comment" spellcheck="true"># --no-edit:是跳过进入编辑器，直接提交</span><span class="token comment" spellcheck="true"># git commit --amend这条命令等同于</span><span class="token comment" spellcheck="true"># $ git reset --soft HEAD^</span><span class="token comment" spellcheck="true"># $ ... do something  tree ...</span><span class="token comment" spellcheck="true"># $ git commit -c ORIG_HEAD</span><span class="token function">git</span> commit --amend --no-edit<span class="token comment" spellcheck="true"># 跳过校验直接提交,包括任何 githooks</span><span class="token function">git</span> commit --no-verify -m <span class="token string">"xxx"</span><span class="token comment" spellcheck="true"># 带提交概要信息</span><span class="token function">git</span> commit -m <span class="token string">"xxx"</span><span class="token comment" spellcheck="true"># 指定目录格式提交</span><span class="token comment" spellcheck="true"># -t &lt;file>, --template=&lt;file></span><span class="token comment" spellcheck="true"># 也可以从全局或者项目级别指定提交的模板文件</span><span class="token comment" spellcheck="true"># git config [--global] commit.template xxx</span><span class="token comment" spellcheck="true"># 现在一般都是 用社区的npm规范包，commitizen 和 commitlint 来规范提交</span><span class="token function">git</span> commit -t templateFile<span class="token comment" spellcheck="true"># 提交信息从文件读取,可以结合上面的一起用</span><span class="token function">git</span> commit -F</code></pre><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>不得不说，代码回滚中这个命令也是用的很多，而且是 –hard</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 硬性回滚,简单粗暴，直接抛弃回滚之后改动(log 还是有保留，内容不要而已)</span><span class="token function">git</span> reset --hard commit_sha1<span class="token comment" spellcheck="true"># 软性回滚, 跟 rebase 常规用法差不多的效果，可以把提交的东西丢回暂存区和工作区，</span><span class="token comment" spellcheck="true"># HEAD 的指向改变会对应的 commit,之后再考虑怎么 commit</span><span class="token function">git</span> reset --soft commit_sha1<span class="token comment" spellcheck="true"># 软回滚一个版本,可以理解为撤销最近一次的 commit</span><span class="token function">git</span> reset --soft HEAD~1<span class="token comment" spellcheck="true"># 清除暂存区但保留工作区变动。</span><span class="token function">git</span> reset --mixed commit_sha1<span class="token comment" spellcheck="true"># 保留工作区和暂存区之间的差异。</span><span class="token function">git</span> reset --merge commit_sha1<span class="token comment" spellcheck="true"># 保留工作区和HEAD之间的差异</span><span class="token function">git</span> reset --keep commit_sha1</code></pre><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p>一般用于master 的代码回滚，因为多人在上面协作，</p><p>revert 可以平稳的回滚代码,但却保留提交记录,不会让协作的人各种冲突！</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 回滚到某个 commit</span><span class="token function">git</span> revert commit-sha1</code></pre><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>变基在项目中算是很频繁的，为什么这么说。</p><p>比如你开发一个新的 feature, 遵循最小化代码提交的理念。</p><p>在整个功能开发完毕的时侯，会有非常多的 commit，用 rebase 可以让我们的commit记录很干净</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 带 -i 可以进入交互模式，效果如下</span><span class="token function">git</span> rebase -i git-sha1<span class="token operator">|</span>branch<span class="token punctuation">(</span>HEAD<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 若是中间毫无冲突，变基则一步到位，否则需要逐步调整。</span><span class="token function">git</span> rebase --continue <span class="token comment" spellcheck="true"># 提交变更后继续变基下一步</span><span class="token function">git</span> rebase --skip <span class="token comment" spellcheck="true"># 引起冲突的commits会被丢弃，continue提示没有需要改动的也可以用这个跳过</span><span class="token function">git</span> rebase --abort <span class="token comment" spellcheck="true"># 若是变基改残废了，但是走到一半，可以彻底回滚变基之前的状态</span></code></pre><p><img src="/images/2019/12/28/1e114c90-2989-11ea-9c54-0994549fb268.png" alt="image.png"></p><ul><li>pick: 是保留该 commit(采用)</li><li>edit: 一般你提交的东西多了,可以用这个把东东拿回工作区拆分更细的 commit</li><li>reword: 这个可以重新修改你的 commit msg</li><li>squash: 内容保留，把提交信息往上一个 commit 合并进去</li><li>fixup: 保留变动内容，但是抛弃 commit msg</li><li>drop: 用的比较少，无用的改动你会提交么！！！</li></ul><p>突然发现截图还有几个新的行为，估计是新版本带来的，从字面上就可以看出来大体的意思, 就是把回滚和打标签这些放到变基中简化操作</p><blockquote><p>温馨提示</p></blockquote><ul><li>本地提交之前，最好把基准点变为需要合并的分支，这样提交 PR/MR 的时侯就不会冲突(本地来解决冲突)</li><li>不要在公共分支上变基！！！一变其他协作者基本都一堆冲突！除非你们有很清晰的分支管理机制</li></ul><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># --ff 是指fast-forward命令,当使用ff模式进行合并时，将不会创造一个新的commit节点。</span><span class="token comment" spellcheck="true"># --no-ff,保留合并分支的提交记录,一般主干用的比较多.</span><span class="token comment" spellcheck="true"># --ff-only 除非当前HEAD节点为最新节点或者能够用ff模式进行合并，否则拒绝合并并返回一个失败状态。</span><span class="token comment" spellcheck="true"># --squash 则类似 rebase squash,可以把合并多个 commit 变成一个</span><span class="token function">git</span> merge --no-ff branchName</code></pre><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>git pull中用的最多是带–rebase(-r)的方式(变基形式拉取合并代码),保持分支一条线。</p><p>默认的pull会走ff模式,多数情况会产生新的commit,部分参数与 merge提供一致。</p><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>当本地分支存在，远程分支不存在的时侯，可以这样推送关联的远程分支</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 这样会直接新建一个同名的远程分支</span><span class="token function">git</span> push origin localbranch <span class="token comment" spellcheck="true"># 删除远程分支(--delete)</span><span class="token function">git</span> push -d origin branchName<span class="token comment" spellcheck="true"># 推送所有标签</span><span class="token function">git</span> push --tags<span class="token comment" spellcheck="true"># 推送 commit 关联的 tags</span><span class="token function">git</span> push --follow-tags<span class="token comment" spellcheck="true"># 强制推送(--force)</span><span class="token function">git</span> push -f origin branchName <span class="token comment" spellcheck="true"># 一般合理的项目，主干都做了分支保护,不会允许强推行为</span><span class="token comment" spellcheck="true"># 有时候真的需要强推的时侯,但可不可以柔和一点呢？</span><span class="token comment" spellcheck="true"># 就是当前远程分支和你本地一致,没有别人提交的情况下可以强推</span><span class="token comment" spellcheck="true"># --force-with-lease: 若是远程有人提交，此次强推失败，反之成功</span><span class="token function">git</span> push --force-with-lease</code></pre><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>这个东西用在你需要考虑维护多个地方仓库的时侯会考虑，或者修改仓库源的时侯</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 常规关联本地 git init 到远程仓库的姿势</span><span class="token function">git</span> remote add origin url<span class="token comment" spellcheck="true"># 新增其他上游仓</span><span class="token function">git</span> remote add github url<span class="token comment" spellcheck="true"># 修改推送源</span><span class="token function">git</span> remote set-url  origin<span class="token punctuation">(</span>或者其他上游域<span class="token punctuation">)</span> url</code></pre><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>该命令用的最多的就是删除本地分支，重命名分支，删除远程分支了</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 分支删除，拷贝，重命名，参数若是大写就等同多了--force，强制执行</span><span class="token comment" spellcheck="true"># -c, --copy : 复制分支，</span><span class="token comment" spellcheck="true"># -C：等同于 --copy --force</span><span class="token comment" spellcheck="true"># -d, --delete: 删除分支</span><span class="token comment" spellcheck="true"># -m, --move：移动或者重命名分支</span><span class="token function">git</span> branch -d branchName<span class="token function">git</span> branch -M oldBranch newNameBranch<span class="token comment" spellcheck="true"># 手动指定它的当前分支的上游分支,两个写法一致的</span><span class="token comment" spellcheck="true"># 有关联一般也有取消关联，--unset-upstream</span><span class="token function">git</span> branch --set-upstream-to<span class="token operator">=</span>origin/xxx <span class="token function">git</span> branch --set-upstream-to origin xxx</code></pre><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p>暂存用的最多时侯就是你撸代码撸到一半，突然说有个紧急 BUG 要修正。</p><p>或者别人在你这里需要帮忙排查代码，你这时候也会用到。</p><p>强烈建议给每个 stash 添加描述信息！！！</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 缓存当前工作区的内容到stashName, save 这个现在不怎么推荐用，图方便也能用</span><span class="token comment" spellcheck="true"># -a|--all: 除了未跟踪的文件，其他变动的文件都会保存</span><span class="token comment" spellcheck="true"># -u|--include-untracked：包括没有添加到暂存区的文件</span><span class="token function">git</span> stash save stashName<span class="token function">git</span> stash -u save stashName<span class="token comment" spellcheck="true"># 现在基本推荐用 push,因为有 pop，语义上和维护上更清晰</span><span class="token comment" spellcheck="true"># 上面有的参数，它也有，还有-m 来备注这个 stash 的大概情况</span><span class="token function">git</span> stash push -m <span class="token string">"更改了 xx"</span> <span class="token comment" spellcheck="true"># 有保存那肯定也有取用的</span><span class="token comment" spellcheck="true"># pop: 取会删除对应的保存记录</span><span class="token comment" spellcheck="true"># apply: 取但保留记录</span><span class="token comment" spellcheck="true"># 0就是--index,这个东西哪里来的呢？</span><span class="token function">git</span> stash apply stash@<span class="token punctuation">{</span>0<span class="token punctuation">}</span><span class="token function">git</span> stash pop stash@<span class="token punctuation">{</span>0<span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 查看stash 保存记录</span><span class="token comment" spellcheck="true"># eg: stash@{0}: On dev: 测试</span><span class="token function">git</span> stash list<span class="token comment" spellcheck="true"># 只想删除暂存记录怎么办：</span><span class="token comment" spellcheck="true"># clear : 清空所有 stash</span><span class="token comment" spellcheck="true"># drop: 清除指定的 stash</span><span class="token function">git</span> stash <span class="token function">clear</span> <span class="token comment" spellcheck="true"># 慎用！</span><span class="token function">git</span> stash drop stash@<span class="token punctuation">{</span>0<span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 想看 stash 做了什么改动，类似简化版的git diff</span><span class="token function">git</span> stash show stash@<span class="token punctuation">{</span>0<span class="token punctuation">}</span></code></pre><h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><p>这个命令的强大之处，是记录了所有行为，包括你 rebase,merge, reset 这些</p><p>当我们不小心硬回滚的时侯,或变基错了都可以在这里找到行为之前的commit，然后回滚。</p><p>当然这个时间回溯也只在本地有用，你推送到远程分支的破坏性改动,该凉还是得凉。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 最近五次行为,不带-n 则默认所有</span><span class="token function">git</span> reflog -5</code></pre><h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><p>这个东西你可以理解为你去买橘子，你会专门挑一些符合心意的橘子放到购物篮中。你可以从多个分支同时挑取部分需要的 commit 合并到同一个地方去，是不是贼骚。这货和变基有点类似，但是仅仅类似，挑过来的 commit 若是没有冲突则追加。有冲突会中断，解决后 –continue</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在当前分支挑其他分支的 commit，把那部分的变动那过来</span><span class="token function">git</span> cherry-pick commit-sha1<span class="token comment" spellcheck="true"># 支持一次性拿多个</span><span class="token function">git</span> cherry-pick master~4 master~2<span class="token comment" spellcheck="true"># 支持区间, 区间中间是 .. </span><span class="token function">git</span> cherry-pick startGitSha1<span class="token punctuation">..</span>endGitSha1<span class="token comment" spellcheck="true"># --continue：继续 pick,一般有冲突解决后才需要这样</span><span class="token comment" spellcheck="true"># --skip：跳过这次进入队列下一次行为 </span><span class="token comment" spellcheck="true"># --abort : 完全放弃 pick，恢复 pick 之前的状态</span><span class="token comment" spellcheck="true"># --quit: 未冲突的自动变更，冲突的不要，退出这次 pick</span><span class="token comment" spellcheck="true"># 这几个状态跟变基差不多,解决冲突继续，跳过处理，放弃这次pick,不输出错误</span></code></pre><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p>这个命令在旧的版本用的比较最多的姿势是为了重新索引.gitignore 的范围</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 删除某个文件的索引</span><span class="token comment" spellcheck="true"># --cache 不会删除硬盘中的文件，只是 git 索引(缓存)的关系！！！</span><span class="token function">git</span> <span class="token function">rm</span> --cache -- <span class="token function">file</span><span class="token comment" spellcheck="true"># 递归清除全部所有索引(也可以理解为缓存吧),这个姿势适合重新让.gitignore 新范围生效</span><span class="token function">git</span> <span class="token function">rm</span> -r --cached <span class="token keyword">.</span>  <span class="token function">git</span> add <span class="token keyword">.</span><span class="token function">git</span> commit -m <span class="token string">"xxx"</span></code></pre><h3 id="git-rev-parse"><a href="#git-rev-parse" class="headerlink" title="git rev-parse"></a>git rev-parse</h3><p>这个估计一般人用的不是很多，可以通过这个快速获取部分git 仓库的信息</p><p>我在弄脚本的时侯就会从这里拿东西</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 获取最新有效的commit</span><span class="token comment" spellcheck="true"># --short：显示七位的 sha1,不带就是全部</span><span class="token comment" spellcheck="true"># --verify: 校验是否有效commit</span><span class="token comment" spellcheck="true"># HEAD: 当前分支的head 指向</span><span class="token function">git</span> rev-parse --short HEAD --verify<span class="token comment" spellcheck="true"># 显示仓库的绝对路径</span><span class="token function">git</span> rev-parse --show-toplevel <span class="token comment" spellcheck="true">#eg: /Users/linqunhe/Code/aozhe/thinking-ui</span><span class="token comment" spellcheck="true"># 显示版本库.git 目录所在的位置</span><span class="token function">git</span> rev-parse --git-dir<span class="token comment" spellcheck="true"># 显示所有关联引用的 git sha1</span><span class="token function">git</span> rev-parse --all</code></pre><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>对于这个命令，在终端比对用的不是很频繁，除了少量改动的时侯可能会用这个看看。</p><p>其他情况下我更倾向于用 GUI 工具来看，因为比对更加直观。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>git 的常用命令其实很好掌握，很多命令都有 Linux 的影子。</p><p>列出来的命令都是高频使用的，或许有一些更骚的姿势没有摸索到。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThingsBoard PE版破解</title>
      <link href="/2019/12/23/Thingsboard/ThingsBoard-PE%E7%89%88%E7%A0%B4%E8%A7%A3/"/>
      <url>/2019/12/23/Thingsboard/ThingsBoard-PE%E7%89%88%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://thingsboard.io/" target="_blank" rel="noopener">ThingsBoard是一款开源的IOT平台</a>，有CE,PE两个版本，PE版需要付费，功能也更加丰富。为了体验下PE版的功能，尝试着对<br>PE版进行破解。</p><a id="more"></a><ol><li><p>按照<a href="https://thingsboard.io/docs/user-guide/install/pe/windows/" target="_blank" rel="noopener">官方文档</a>进行安装，跳过步骤中的填写license部分</p></li><li><p>启动服务，当然此时是无法访问的。查看日志thingsboard.log发现最后有如下提示</p><pre><code> 2019-12-24 09:14:50,056 [main] ERROR o.t.s.d.s.BasicSubscriptionService - License secret is not provided! 2019-12-24 09:14:50,057 [main] ERROR o.t.s.d.s.BasicSubscriptionService - Please provide license.secret property value in thingsboard.yml or set TB_LICENSE_SECRET environment variable! 2019-12-24 09:14:50,156 [Shutdown Thread] INFO  o.t.s.d.s.BasicSubscriptionService - Terminating application due to critical License Error GENERAL_ERROR(300), exit code [-1]...</code></pre><p>这里提示<code>BasicSubscriptionService</code>这个类中进行了license的检验，但是上面没有显示改类包路径，无法精确定位到改类的位置。</p></li><li><p>为了精确定位<code>BasicSubscriptionService</code>这个类的位置，对<code>conf/logback.xml</code>进行修改，将日志长度改大一点</p><pre><code>&lt;encoder&gt;   &lt;pattern&gt;%d{ISO8601} [%thread] %-5level %logger{255} - %msg%n&lt;/pattern&gt;&lt;/encoder&gt;</code></pre></li><li><p>再次重启服务，查看日志</p><pre><code>2019-12-24 09:32:58,495 [main] ERROR org.thingsboard.server.dao.subscription.BasicSubscriptionService - License secret is not provided!2019-12-24 09:32:58,497 [main] ERROR org.thingsboard.server.dao.subscription.BasicSubscriptionService - Please provide license.secret property value in thingsboard.yml or set TB_LICENSE_SECRET environment variable!2019-12-24 09:32:58,504 [Shutdown Thread] INFO  org.thingsboard.server.dao.subscription.BasicSubscriptionService - Terminating application due to critical License Error GENERAL_ERROR(300), exit code [-1]...</code></pre><p>发现<code>org.thingsboard.server.dao.subscription.BasicSubscriptionService</code>这个类是再dao包下，解压<code>lib/thingsboard.jar</code>，找到依赖的<code>dao-2.4.2PE.jar</code>，解压找到<code>BasicSubscriptionService</code><br>最后发现检查license的地方在这里:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@PostConstruct</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>licenseSecret<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"License secret is not provided!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Please provide license.secret property value in thingsboard.yml or set TB_LICENSE_SECRET environment variable!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">doExit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> LicenseErrorCode<span class="token punctuation">.</span>GENERAL_ERROR<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>           <span class="token keyword">try</span> <span class="token punctuation">{</span>               <span class="token keyword">this</span><span class="token punctuation">.</span>tbLicenseClient <span class="token operator">=</span> TbLicenseClient<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">licenseSecret</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>licenseSecret<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">releaseDate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"2019-09-13"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token keyword">this</span><span class="token punctuation">.</span>tbLicenseClient<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> var3<span class="token punctuation">)</span> <span class="token punctuation">{</span>               log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Failed to init license client"</span><span class="token punctuation">,</span> var3<span class="token punctuation">)</span><span class="token punctuation">;</span>               LicenseErrorCode licenseErrorCode <span class="token operator">=</span> var3 <span class="token keyword">instanceof</span> <span class="token class-name">LicenseException</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>LicenseException<span class="token punctuation">)</span>var3<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getErrorCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> LicenseErrorCode<span class="token punctuation">.</span>GENERAL_ERROR<span class="token punctuation">;</span>               <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">doExit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> licenseErrorCode<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span></code></pre></li><li><p>尝试重写该类中方法，将验证license那部分去掉。然后将新的<code>BasicSubscriptionService.class</code>替换掉之前的代码。<br>打开CE版的源码，在<code>dao</code>模块下新建<code>subscription</code>包，对照<code>dao-2.4.2PE.jar</code>中的内容，将<code>SubscriptionService</code>,<code>InstallSubscriptionService</code>,<code>BasicSubscriptionService</code>这3个类中的内容完全复制过来,<br>再重写<code>BasicSubscriptionService</code>中的方法，最后内容如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Value<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Profile<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Service<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>thingsboard<span class="token punctuation">.</span>server<span class="token punctuation">.</span>common<span class="token punctuation">.</span>data<span class="token punctuation">.</span>id<span class="token punctuation">.</span>TenantId<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>thingsboard<span class="token punctuation">.</span>server<span class="token punctuation">.</span>common<span class="token punctuation">.</span>data<span class="token punctuation">.</span>subscription<span class="token punctuation">.</span>SubscriptionException<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>PostConstruct<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>PreDestroy<span class="token punctuation">;</span><span class="token annotation punctuation">@Service</span><span class="token annotation punctuation">@Profile</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"!install"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BasicSubscriptionService</span> <span class="token keyword">implements</span> <span class="token class-name">SubscriptionService</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>BasicSubscriptionService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String MAX_DEVICES_KEY <span class="token operator">=</span> <span class="token string">"maxdevices"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String MAX_ASSETS_KEY <span class="token operator">=</span> <span class="token string">"maxassets"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String WHITELABELING_KEY <span class="token operator">=</span> <span class="token string">"whitelabeling"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${license.secret}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String licenseSecret<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">BasicSubscriptionService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@PostConstruct</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code></pre></li></ol><pre><code>   }   @PreDestroy   public void stop() {   }   @Override   public void createDeviceAllowed(TenantId tenantId) throws SubscriptionException {   }   @Override   public void createAssetAllowed(TenantId tenantId) throws SubscriptionException {   }   @Override   public void whiteLabelingAllowed(TenantId tenantId) throws SubscriptionException {   }   @Override   public boolean whiteLabelingEnabled(TenantId tenantId) throws SubscriptionException {      return true;   }</code></pre><p>   }</p><pre><code>(这步过程中`SubscriptionService`类中有个异常类`SubscriptionException`是在`common`模块下的，CE版中也没有这个类，需要按照路径在CE版中生成，然后重新编译`common`模块)6. 编译`dao`模块，拿到`BasicSubscriptionService.class`7. 重新生成`dao-2.4.2PE.jar`,使用jar命令替换，在`dao-2.4.2PE.jar`同目录下新建目录`org\thingsboard\server\dao\subscription`,将`BasicSubscriptionService.class`放到该目录下，执行`jar uf dao-2.4.2PE.jar org\thingsboard\server\dao\subscription\BasicSubscriptionService.class`此时`dao-2.4.2PE.jar`已经更新完。8. 重新生成`thingsboard.jar`，解压之间的`thingsboard.jar`,得到3个目录`BOOT-INF`,`META-INF`,`org`,将上一步生成的`dao-2.4.2PE.jar`放入`BOOT-INF\lib`中，执行`jar cf0M thingsboard.jar *`生成新的jar包9. 用新的thingsboard.jar替换掉lib中的jar包重新install或者直接执行都可以（java -jar thingsboard.jar,需要修改jar包中的yml配置文件）。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ThingsBoard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThingsBoard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThingsBoard-Gateway（Java版）在树莓派上的使用-ModBus协议</title>
      <link href="/2019/11/21/Thingsboard/ThingsBoard%E7%BD%91%E5%85%B3%E9%85%8D%E7%BD%AE(Java%E7%89%88)-Modbus/"/>
      <url>/2019/11/21/Thingsboard/ThingsBoard%E7%BD%91%E5%85%B3%E9%85%8D%E7%BD%AE(Java%E7%89%88)-Modbus/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ThingsBoard GateWay 是在ThingsBoard下的一款高度集成遗留系统和第三方系统上联接设备的开源解决方案。<br>具有以下几个特点：</p><ul><li>MQTT扩展 - 于控制、配置和收集使用现有协议连接到外部MQTT代理的IoT设备数据。</li><li>OPC-UA扩展 - 收集连接到OPC-UA服务端的IoT设备数据。</li><li>Sigfox扩展 - 收集连接到Sigfox后端的IoT设备数据。</li><li>数据持久 - 网络和硬件异常时保证数据正常传输。</li><li>自动重新连接到UlyncThings集群。</li><li>将传入的数据和消息映射到统一格式。<br>本篇将介绍在树莓派上安装ThingsBoard GateWay使用Modbus协议遥测数据。<a id="more"></a><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1></li></ul><ol><li>启动ThingsBoard服务</li><li><a href="https://thingsboard.io/docs/iot-gateway/install/rpi/" target="_blank" rel="noopener">在树莓派上安装ThingsBoard GateWay</a></li><li><a href="https://thingsboard.io/docs/iot-gateway/getting-started/" target="_blank" rel="noopener">启动ThingsBoard GateWay服务</a></li><li><a href="http://etrd.org/2017/01/29/%E6%A0%91%E8%8E%93%E6%B4%BE3%E7%A1%AC%E4%BB%B6%E4%B8%B2%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E7%BC%96%E7%A8%8B/" target="_blank" rel="noopener">树莓派串口配置</a></li><li><a href="http://www.waveshare.net/wiki/RS485_CAN_HAT" target="_blank" rel="noopener">树莓派RS485扩展板</a>一块,将扩展板插入树莓派，并与自己的传感设备连接好</li><li><a href="https://harttle.land/2017/01/14/raspberrypi-uart.html" target="_blank" rel="noopener">将树莓派ttyAMA0串口权限开放</a><h1 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h1><h2 id="配置网关扩展"><a href="#配置网关扩展" class="headerlink" title="配置网关扩展"></a>配置网关扩展</h2><pre class=" language-$xslt"><code class="language-$xslt">[{ "id": "modbus-water", "type": "MODBUS", "configuration": {     "servers": [{         "transport": {             "type": "rtu",             "portName": "ttyAMA0",             "encoding": "rtu",             "timeout": 5000,             "baudRate": 9600,             "dataBits": 8,             "stopBits": 1,             "parity": "none"         },         "devices": [{             "unitId": 1,             "deviceName": "水压-设备1",             "attributesPollPeriod": 1000,             "timeseriesPollPeriod": 1000,             "attributes": [],             "timeseries": [{                 "tag": "pressure",                 "type": "long",                 "pollPeriod": 1000,                 "functionCode": 3,                 "address": 4,                 "registerCount": 1,                 "bit": 0,                 "byteOrder": "BIG"             }]         }]     }] }}]</code></pre></li></ol><pre><code>## 配置网关服务文件tb-gateway.yml```$xsltserver:  # Server bind address  address: "0.0.0.0"  # Server bind port  port: "9090"# Check new version updates parametersupdates:  # Enable/disable updates checking.  enabled: "${UPDATES_ENABLED:true}"gateways:  tenants:    -      label: "Tenant"      reporting:        interval: 60000      persistence:        type: file        path: storage        bufferSize: 1000      connection:        host: #ThingsBoard服务地址#        port: 1883        retryInterval: 3000        maxInFlight: 1000        security:          accessToken: #网关设备的令牌#      remoteConfiguration: true      extensions:        -          id: "http"          type: "HTTP"          extensionConfiguration: http-config.json</code></pre><h2 id="重启GateWay服务"><a href="#重启GateWay服务" class="headerlink" title="重启GateWay服务"></a>重启GateWay服务</h2><p>#问题<br>整个安装配置过程中出现了一个问题花了好久，在配置并重启GateWay服务后，发现网关设备始终没有同步，查看日志后发现</p><pre class=" language-$xslt"><code class="language-$xslt">2019-11-19 18:36:13,160 [pool-1-thread-1] ERROR o.t.g.extensions.modbus.ModbusClient - MBS[ttyAMA0] connection failed!java.io.IOException: Port [ttyAMA0] cannot be opened or does not exist - Valid ports are: [ttyAMA0]    at com.ghgande.j2mod.modbus.net.SerialConnection.open(SerialConnection.java:127)    at com.ghgande.j2mod.modbus.facade.ModbusSerialMaster.connect(ModbusSerialMaster.java:96)    at org.thingsboard.gateway.extensions.modbus.ModbusClient.connect(ModbusClient.java:121)    at java.util.ArrayList.forEach(ArrayList.java:1257)    at org.thingsboard.gateway.extensions.modbus.DefaultModbusService.init(DefaultModbusService.java:64)    at org.thingsboard.gateway.service.TenantServiceRegistry.updateExtensionConfiguration(TenantServiceRegistry.java:83)    at org.thingsboard.gateway.service.DefaultTenantManagerService.lambda$init$0(DefaultTenantManagerService.java:64)    at org.thingsboard.gateway.service.gateway.MqttGatewayService.updateConfiguration(MqttGatewayService.java:515)    at org.thingsboard.gateway.service.gateway.MqttGatewayService.onGatewayAttributesGet(MqttGatewayService.java:496)    at org.thingsboard.gateway.service.gateway.MqttGatewayService.lambda$onMessage$17(MqttGatewayService.java:426)    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)    at java.util.concurrent.FutureTask.run(FutureTask.java:266)    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)    at java.lang.Thread.run(Thread.java:748)2019-11-19 18:36:13,165 [pool-1-thread-1] ERROR o.t.g.e.modbus.DefaultModbusService - [Tenant] Modbus service initialization failed</code></pre><p>日志显示ttyAMA0口不能打开或不存在。dose not exist肯定是不可能的，那就是串口打不开。<br>最后在<a href="https://harttle.land/2017/01/14/raspberrypi-uart.html" target="_blank" rel="noopener">这里</a>找到了解决办法。将ttyAMA0口的权限设置为任何人可以读，写。<br>在<code>/etc/udev/rules.d</code>中添加100-ttyAMA0.rules,内容为：</p><pre class=" language-$xslt"><code class="language-$xslt">KERNEL=="ttyAMA0", MODE="666"</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ThingsBoard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThingsBoard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域解决方案---CORS</title>
      <link href="/2019/09/18/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88---CORS/"/>
      <url>/2019/09/18/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88---CORS/</url>
      
        <content type="html"><![CDATA[<h1 id="一、什么是跨域访问"><a href="#一、什么是跨域访问" class="headerlink" title="一、什么是跨域访问"></a>一、什么是跨域访问</h1><p>说到跨域访问，必须先解释一个名词：同源策略。<br>所谓同源策略就是在浏览器端出于安全考量，向服务端发起请求必须满足：协议相同、Host(ip)相同、端口相同的条件，否则访问将被禁止，该访问也就被称为跨域访问。<br>虽然跨域访问被禁止之后，可以在一定程度上提高了应用的安全性，但也为开发带来了一定的麻烦。<br>比如：我们开发一个前后端分离的易用，页面及js部署在一个主机的Nginx服务中，后端接口部署在一个tomcat应用容器中，当前端向后端发起请求的时候一定是不符合同源策略的，也就无法访问。<br>那么我们如何解决这个问题？就是本文需要向大家说明的内容。</p><h1 id="二、跨域解决方案"><a href="#二、跨域解决方案" class="headerlink" title="二、跨域解决方案"></a>二、跨域解决方案</h1><h2 id="1-前端解决方案"><a href="#1-前端解决方案" class="headerlink" title="1.前端解决方案"></a>1.前端解决方案</h2><p>虽然浏览器对于不符合同源策略的访问是禁止的，但是仍然存在例外的情况，如以下资源引用的标签不受同源策略的限制：</p><ul><li>html的script标签</li><li>html的link标签</li><li>html的img标签</li><li>html的iframe标签：对于使用jsp、freemarker开发的项目，这是实现跨域访问最常见的方法<br>除了基于HTML本身的特性实现跨域访问，我们还可以使用jsonp、window的postMessage实现跨域访问。这些都是前端实现跨域访问的方式。</li></ul><h2 id="2-使用代理"><a href="#2-使用代理" class="headerlink" title="2.使用代理"></a>2.使用代理</h2><p>实际上对跨域访问的支持在服务端实现起来更加容易，最常用的方法就是通过代理的方式，如：</p><ul><li>nginx或haproxy代理跨域</li><li>nodejs中间件代理跨域<br>其实实现代理跨域的逻辑非常简单：就是在不同的资源服务：js资源、html资源、css资源、接口数据资源服务的前端搭建一个中间层，所有的浏览器及客户端访问都通过代理转发。<br>所以在浏览器、客户端看来，它们访问的都是同一个ip、同一个端口的资源，从而符合同源策略实现跨域访问。<br><img src="https://nblog.oss-cn-shanghai.aliyuncs.com/16e57d7cc23916d8.jpg" alt=""></li></ul><h2 id="3-CORS"><a href="#3-CORS" class="headerlink" title="3.CORS"></a>3.CORS</h2><p>跨域资源共享（CORS）：通过修改Http协议header的方式，实现跨域。<br>说的简单点就是，通过设置HTTP的响应头信息，告知浏览器哪些情况在不符合同源策略的条件下也可以跨域访问，浏览器通过解析Http协议中的Header执行具体判断。<br>具体的Header如下：</p><ul><li>Access-Control-Allow-Origin: 允许哪些ip或域名可以跨域访问</li><li>Access-Control-Max-Age: 表示在多少秒之内不需要重复校验该请求的跨域访问权限</li><li>Access-Control-Allow-Methods: 表示允许跨域请求的HTTP方法，如：GET,POST,PUT,DELETE</li><li>Access-Control-Allow-Headers: 表示访问请求中允许携带哪些Header信息，如：Accept、Accept-Language、Content-Language、Content-Type<h3 id="SpringBoot下实现CORS的四种方式"><a href="#SpringBoot下实现CORS的四种方式" class="headerlink" title="SpringBoot下实现CORS的四种方式"></a>SpringBoot下实现CORS的四种方式</h3></li></ul><h4 id="1-使用CorsFilter进行全局跨域配置"><a href="#1-使用CorsFilter进行全局跨域配置" class="headerlink" title="1.使用CorsFilter进行全局跨域配置"></a>1.使用CorsFilter进行全局跨域配置</h4><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Configuration</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalCorsConfig</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Bean</span>        <span class="token keyword">public</span> CorsFilter <span class="token function">corsFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            CorsConfiguration config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CorsConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//开放哪些ip、端口、域名的访问权限，星号表示开放所有域</span>            config<span class="token punctuation">.</span><span class="token function">addAllowedOrigin</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//是否允许发送Cookie信息</span>            config<span class="token punctuation">.</span><span class="token function">setAllowCredentials</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//开放哪些Http方法，允许跨域访问</span>            config<span class="token punctuation">.</span><span class="token function">addAllowedMethod</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//允许HTTP请求中的携带哪些Header信息</span>            config<span class="token punctuation">.</span><span class="token function">addAllowedHeader</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）</span>            config<span class="token punctuation">.</span><span class="token function">addExposedHeader</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//添加映射路径，“/**”表示对所有的路径实行全局跨域访问权限的设置</span>            UrlBasedCorsConfigurationSource configSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UrlBasedCorsConfigurationSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            configSource<span class="token punctuation">.</span><span class="token function">registerCorsConfiguration</span><span class="token punctuation">(</span><span class="token string">"/**"</span><span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CorsFilter</span><span class="token punctuation">(</span>configSource<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="2-重写WebMvcConfigurer的addCorsMappings方法（全局跨域配置）"><a href="#2-重写WebMvcConfigurer的addCorsMappings方法（全局跨域配置）" class="headerlink" title="2.重写WebMvcConfigurer的addCorsMappings方法（全局跨域配置）"></a>2.重写WebMvcConfigurer的addCorsMappings方法（全局跨域配置）</h3><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Configuration</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalCorsConfig</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Bean</span>        <span class="token keyword">public</span> WebMvcConfigurer <span class="token function">corsConfigurer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WebMvcConfigurer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addCorsMappings</span><span class="token punctuation">(</span>CorsRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    registry<span class="token punctuation">.</span><span class="token function">addMapping</span><span class="token punctuation">(</span><span class="token string">"/**"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//添加映射路径，“/**”表示对所有的路径实行全局跨域访问权限的设置</span>                            <span class="token punctuation">.</span><span class="token function">allowedOrigins</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//开放哪些ip、端口、域名的访问权限</span>                            <span class="token punctuation">.</span><span class="token function">allowCredentials</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//是否允许发送Cookie信息 </span>                            <span class="token punctuation">.</span><span class="token function">allowedMethods</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span><span class="token string">"POST"</span><span class="token punctuation">,</span> <span class="token string">"PUT"</span><span class="token punctuation">,</span> <span class="token string">"DELETE"</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">//开放哪些Http方法，允许跨域访问</span>                            <span class="token punctuation">.</span><span class="token function">allowedHeaders</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">//允许HTTP请求中的携带哪些Header信息</span>                            <span class="token punctuation">.</span><span class="token function">exposedHeaders</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="3-使用CrossOrigin注解（局部跨域配置）"><a href="#3-使用CrossOrigin注解（局部跨域配置）" class="headerlink" title="3.使用CrossOrigin注解（局部跨域配置）"></a>3.使用CrossOrigin注解（局部跨域配置）</h3><ul><li>将CrossOrigin注解加在Controller层的方法上，该方法定义的RequestMapping端点将支持跨域访问 </li><li>将CrossOrigin注解加在Controller层的类定义处，整个类所有的方法对应的RequestMapping端点都将支持跨域访问<pre class=" language-java"><code class="language-java">  <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/cors"</span><span class="token punctuation">)</span>  <span class="token annotation punctuation">@ResponseBody</span>  <span class="token annotation punctuation">@CrossOrigin</span><span class="token punctuation">(</span>origins <span class="token operator">=</span> <span class="token string">"http://localhost:8080"</span><span class="token punctuation">,</span> maxAge <span class="token operator">=</span> <span class="token number">3600</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> String <span class="token function">cors</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token string">"cors"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><h3 id="4-使用HttpServletResponse设置响应头-局部跨域配置"><a href="#4-使用HttpServletResponse设置响应头-局部跨域配置" class="headerlink" title="4.使用HttpServletResponse设置响应头(局部跨域配置)"></a>4.使用HttpServletResponse设置响应头(局部跨域配置)</h3>这种方式略显麻烦，不建议在SpringBoot项目中使用。<pre class=" language-java"><code class="language-java">  <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/cors"</span><span class="token punctuation">)</span>  <span class="token annotation punctuation">@ResponseBody</span>  <span class="token keyword">public</span> String <span class="token function">cors</span><span class="token punctuation">(</span>HttpServletResponse response<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//使用HttpServletResponse定义HTTP请求头，最原始的方法也是最通用的方法</span>      response<span class="token punctuation">.</span><span class="token function">addHeader</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Origin"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost:8080"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token string">"cors"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中sql_mode=only_full_group_by问题解决办法</title>
      <link href="/2019/04/09/MySQL%E4%B8%ADsql-mode-only-full-group-by%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2019/04/09/MySQL%E4%B8%ADsql-mode-only-full-group-by%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-ONLY-FULL-GROUP-BY解析"><a href="#1-ONLY-FULL-GROUP-BY解析" class="headerlink" title="1.ONLY_FULL_GROUP_BY解析"></a>1.ONLY_FULL_GROUP_BY解析</h1><p>对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，也没有使用聚合函数，那么这个SQL是不合法的，因为列不在GROUP BY从句中。<br>简而言之，就是SELECT后面接的列必须被GROUP BY后面接的列所包含，或者该列被使用聚合函数（sum等）。如：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token number">a</span><span class="token punctuation">,</span><span class="token number">b</span><span class="token punctuation">,</span><span class="token number">c</span> <span class="token keyword">from</span> <span class="token keyword">table</span> <span class="token keyword">group</span> <span class="token keyword">by</span> <span class="token number">a</span><span class="token punctuation">,</span><span class="token number">b</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>错误<span class="token punctuation">)</span><span class="token keyword">select</span> <span class="token number">a</span><span class="token punctuation">,</span><span class="token number">b</span> <span class="token keyword">from</span> <span class="token keyword">table</span> <span class="token keyword">group</span> <span class="token keyword">by</span> <span class="token number">a</span><span class="token punctuation">,</span><span class="token number">b</span><span class="token punctuation">,</span><span class="token number">c</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>正确<span class="token punctuation">)</span><span class="token keyword">select</span> <span class="token number">a</span><span class="token punctuation">,</span><span class="token number">b</span><span class="token punctuation">,</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">c</span><span class="token punctuation">)</span> <span class="token keyword">from</span> <span class="token keyword">table</span> <span class="token keyword">group</span> <span class="token keyword">by</span> <span class="token number">a</span><span class="token punctuation">,</span><span class="token number">b</span><span class="token punctuation">;</span><span class="token punctuation">(</span>正确<span class="token punctuation">)</span></code></pre><h1 id="2-取消ONLY-FULL-GROUP-BY配置"><a href="#2-取消ONLY-FULL-GROUP-BY配置" class="headerlink" title="2.取消ONLY_FULL_GROUP_BY配置"></a>2.取消ONLY_FULL_GROUP_BY配置</h1><h2 id="1-临时修改，重新设置sql-mode，服务重启后将失效"><a href="#1-临时修改，重新设置sql-mode，服务重启后将失效" class="headerlink" title="1.临时修改，重新设置sql_mode，服务重启后将失效"></a>1.临时修改，重新设置sql_mode，服务重启后将失效</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SET</span> @<span class="token variable">@global.sql_mode</span> <span class="token operator">=</span><span class="token string">'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'</span><span class="token punctuation">;</span></code></pre><p>上面是改变了全局sql_mode，对于新建的数据库有效。对于已存在的数据库，则需要在对应的数据下执行：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SET</span> sql_mode <span class="token operator">=</span><span class="token string">'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'</span><span class="token punctuation">;</span></code></pre><h2 id="2-永久修改-修改mysql配置文件，通过手动添加sql-mode的方式强制指定不需要ONLY-FULL-GROUP-BY属性"><a href="#2-永久修改-修改mysql配置文件，通过手动添加sql-mode的方式强制指定不需要ONLY-FULL-GROUP-BY属性" class="headerlink" title="2.永久修改,修改mysql配置文件，通过手动添加sql_mode的方式强制指定不需要ONLY_FULL_GROUP_BY属性"></a>2.永久修改,修改mysql配置文件，通过手动添加sql_mode的方式强制指定不需要ONLY_FULL_GROUP_BY属性</h2><p>在 [mysqld] 下面添加代码：</p><pre class=" language-text"><code class="language-text">sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'</code></pre><p><em>注</em>：不同的系统mysql的配置文件名及路径不同：</p><ul><li>Mac或Linux文件 /etc/my.cnf</li><li>Windows在数据库安装目录下的 my.ini</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx常用命令</title>
      <link href="/2019/03/16/Nginx%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/03/16/Nginx%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>sudo nginx #打开 nginx<br>nginx -s reload|reopen|stop|quit  #重新加载配置|重启|停止|退出 nginx<br>nginx -t   #测试配置是否有语法错误</p><p>nginx [-?hvVtq] [-s signal] [-c filename] [-p prefix] [-g directives]</p><p>-?,-h           : 打开帮助信息<br>-v              : 显示版本信息并退出<br>-V              : 显示版本和配置选项信息，然后退出<br>-t              : 检测配置文件是否有语法错误，然后退出<br>-q              : 在检测配置文件期间屏蔽非错误信息<br>-s signal       : 给一个 nginx 主进程发送信号：stop（停止）, quit（退出）, reopen（重启）, reload（重新加载配置文件）<br>-p prefix       : 设置前缀路径（默认是：/usr/local/Cellar/nginx/1.2.6/）<br>-c filename     : 设置配置文件（默认是：/usr/local/etc/nginx/nginx.conf）<br>-g directives   : 设置配置文件外的全局指令</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之桥接模式</title>
      <link href="/2018/12/19/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/12/19/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：</p><ul><li>第一种设计方案是为每一种形状都提供一套各种颜色的版本。</li><li>第二种设计方案是根据实际需要对形状和颜色进行组合</li></ul><p>对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote><p><strong>桥接模式</strong>(<code>Bridge Pattern</code>)：将抽象和实现解耦，使得两者可以独立地变化。它是一种对象结构型模式，又称为桥梁模式。</p></blockquote><h3 id="模式角色"><a href="#模式角色" class="headerlink" title="模式角色"></a>模式角色</h3><p>桥接模式包含如下角色：</p><ul><li><code>Abstraction</code>：抽象类角色</li><li><code>RefinedAbstraction</code>：扩充抽象类</li><li><code>Implementor</code>：实现化角色</li><li><code>ConcreteImplementor</code>：具体实现化角色的实现类</li></ul><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="http://static.blinkfox.com/java-design-bridge.jpg" alt="桥接模式UML"></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>首先，是实现化角色<code>Abstraction</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 实现化角色 Implementor. * * @author niww on 2018-12-17. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 基本方法1.     */</span>    <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 基本方法2.     */</span>    <span class="token keyword">void</span> <span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后，是各个具体的实现化角色类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * ConcreteImplementor1. * * @author niww on 2018-12-17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteImplementor1</span> <span class="token keyword">implements</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 基本方法1.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteImplementor1 的业务逻辑 doSomething."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 基本方法2.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteImplementor1 的业务逻辑 doAnything."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * ConcreteImplementor2. * * @author niww on 2018-12-17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteImplementor2</span> <span class="token keyword">implements</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 基本方法1.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteImplementor2 的业务逻辑 doSomething."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 基本方法2.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteImplementor2 的业务逻辑 doAnything."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>接下来，是抽象类角色<code>Abstraction</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>niww<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>bridge<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 抽象化角色 Abstraction. * * @author niww on 2018-12-17. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Abstraction</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 定义对实现化角色的引用. */</span>    <span class="token keyword">private</span> Implementor impl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造方法.     *     * @param impl 实现类的实例     */</span>    <span class="token keyword">public</span> <span class="token function">Abstraction</span><span class="token punctuation">(</span>Implementor impl<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>impl <span class="token operator">=</span> impl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * impl 的 getter方法.     *     * @return impl     */</span>    <span class="token keyword">public</span> Implementor <span class="token function">getImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> impl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自身的请求处理方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>impl<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>再次，是扩展的具体抽象化角色类<code>RefinedAbstraction</code>：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * RefinedAbstraction. * * @author niww on 2018-12-17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RefinedAbstraction</span> <span class="token keyword">extends</span> <span class="token class-name">Abstraction</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 构造方法.     *     * @param impl 实现类的实例     */</span>    <span class="token keyword">public</span> <span class="token function">RefinedAbstraction</span><span class="token punctuation">(</span>Implementor impl<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>impl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 覆盖后的请求处理方法.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"RefinedAbstraction 开始做业务处理."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Client. * * @author niww on 2018-12-17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * main方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 定义一个实现化角色和抽象化角色,并执行请求方法.</span>        Implementor impl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteImplementor1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Abstraction abs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RefinedAbstraction</span><span class="token punctuation">(</span>impl<span class="token punctuation">)</span><span class="token punctuation">;</span>        abs<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>理解桥接模式，重点需要理解如何将抽象化(<code>Abstraction</code>)与实现化(<code>Implementation</code>)脱耦，使得二者可以独立地变化。</p><ul><li><strong>抽象化</strong>：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。</li><li><strong>实现化</strong>：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。</li><li><strong>脱耦</strong>：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。<strong>桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。</strong></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>桥接模式的优点:</p><ul><li>分离抽象接口及其实现部分。</li><li>桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。</li><li>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</li><li>实现细节对客户透明，可以对用户隐藏实现细节。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>桥接模式的缺点:</p><ul><li>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 </li><li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用桥接模式：</p><ul><li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li><li>抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。</li><li>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</li><li>虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。</li><li>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</li></ul><h3 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h3><p>一个Java桌面软件总是带有所在操作系统的视感(<code>LookAndFeel</code>)，如果一个Java软件是在Unix系统上开发的，那么开发人员看到的是<code>Motif</code>用户界面的视感；在Windows上面使用这个系统的用户看到的是Windows用户界面的视感；而一个在<code>Macintosh</code>上面使用的用户看到的则是<code>Macintosh</code>用户界面的视感，Java语言是通过所谓的Peer架构做到这一点的。Java为AWT中的每一个GUI构件都提供了一个Peer构件，在AWT中的Peer架构就使用了桥接模式。</p><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>适配器模式与桥接模式的联用:</p><p>桥接模式和适配器模式用于设计的不同阶段，<strong>桥接模式用于系统的初步设计</strong>，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，<strong>当发现系统与已有类无法协同工作时，可以采用适配器模式</strong>。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式。</li><li>桥接模式包含如下四个角色：抽象类中定义了一个实现类接口类型的对象并可以维护该对象；扩充抽象类扩充由抽象类定义的接口，它实现了在抽象类中定义的抽象业务方法，在扩充抽象类中可以调用在实现类接口中定义的业务方法；实现类接口定义了实现类的接口，实现类接口仅提供基本操作，而抽象类定义的接口可能会做更多更复杂的操作；具体实现类实现了实现类接口并且具体实现它，在不同的具体实现类中提供基本操作的不同实现，在程序运行时，具体实现类对象将替换其父类对象，提供给客户端具体的业务操作方法。</li><li>在桥接模式中，抽象化(<code>Abstraction</code>)与实现化(<code>Implementation</code>)脱耦，它们可以沿着各自的维度独立变化。</li><li>桥接模式的主要优点是分离抽象接口及其实现部分，是比多继承方案更好的解决方法，桥接模式还提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，实现细节对客户透明，可以对用户隐藏实现细节；其主要缺点是增加系统的理解与设计难度，且识别出系统中两个独立变化的维度并不是一件容易的事情。</li><li>桥接模式适用情况包括：需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系；抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响；一个类存在两个独立变化的维度，且这两个维度都需要进行扩展；设计要求需要独立管理抽象化角色和具体化角色；不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统。</li></ul><p>参考自：<a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/bridge.html" target="_blank" rel="noopener">桥接模式</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之适配器模式</title>
      <link href="/2018/12/12/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/12/12/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><ul><li>在软件开发中采用类似于电源适配器的设计和编码技巧被称为适配器模式。</li><li>通常情况下，客户端可以通过目标类的接口访问它所提供的服务。有时，现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。</li><li>在这种情况下，现有的接口需要转化为客户类期望的接口，这样保证了对现有类的重用。如果不进行这样的转化，客户类就不能利用现有类所提供的功能，适配器模式可以完成这样的转化。</li><li>在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是适配器(<code>Adapter</code>)，它所包装的对象就是适配者(<code>Adaptee</code>)，即被适配的类。</li><li>适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。</li></ul><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote><p><strong>适配器模式</strong>(<code>Adapter Pattern</code>) ：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(<code>Wrapper</code>)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。适配器模式是一种<strong>结构型模式</strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h3><p>适配器模式包含如下角色：</p><ul><li><code>Target</code>：目标抽象类</li><li><code>Adapter</code>：适配器类</li><li><code>Adaptee</code>：适配者类</li><li><code>Client</code>：客户类</li></ul><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="http://static.blinkfox.com/java-design-adapter.jpg" alt="适配器模式UML"></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>首先，是目标角色接口和具体目标实现类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Target 目标角色类. * * @author niww on 2018-12-11. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 目标角色自己的方法.     */</span>    <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的目标角色实现类. * * @author niww on 2018-12-11. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteTarget</span> <span class="token keyword">implements</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 目标角色自己的方法.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello, I'm concrete target method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其次，是适配者类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 适配者类. * * @author niww on 2018-12-11. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Adaptee</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 这是原有的业务逻辑方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, I'm Adaptee method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是适配器角色类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 适配器类. * * @author niww on 2018-12-11. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Adapter</span> <span class="token keyword">extends</span> <span class="token class-name">Adaptee</span> <span class="token keyword">implements</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 适配了目标角色自己的方法.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"适配器适配了目标角色方法."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 客户端场景类. * * @author niww on 2018-12-11. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * main方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 原有业务逻辑.</span>        Target target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        target<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 增加了适配器角色后的业务逻辑.</span>        Target adaptTarget <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Adapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        adaptTarget<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用适配器模式：</p><ul><li>系统需要使用现有的类，而这些类的接口不符合系统的需要。</li><li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li><li>增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</li><li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</p><h3 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h3><p>Sun公司在1996年公开了Java语言的数据库连接工具JDBC，JDBC使得Java语言程序能够与数据库连接，并使用SQL语言来查询和操作数据。JDBC给出一个客户端通用的抽象接口，每一个具体数据库引擎（如SQL Server、Oracle、MySQL等）的JDBC驱动软件都是一个介于JDBC接口和数据库引擎接口之间的适配器软件。抽象的JDBC接口和各个数据库引擎API之间都需要相应的适配器软件，这就是为各个不同数据库引擎准备的驱动程序。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>结构型模式描述如何将类或者对象结合在一起形成更大的结构。</li><li>适配器模式用于将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</li><li>适配器模式包含四个角色：目标抽象类定义客户要用的特定领域的接口；适配器类可以调用另一个接口，作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心；适配者类是被适配的角色，它定义了一个已经存在的接口，这个接口需要适配；在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。</li><li>在类适配器模式中，适配器类实现了目标抽象类接口并继承了适配者类，并在目标抽象类的实现方法中调用所继承的适配者类的方法；在对象适配器模式中，适配器类继承了目标抽象类并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。</li><li>适配器模式的主要优点是将目标类和适配者类解耦，增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合“开闭原则”；类适配器模式的缺点是适配器类在很多编程语言中不能同时适配多个适配者类，对象适配器模式的缺点是很难置换适配者类的方法。</li><li>适配器模式适用情况包括：系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。</li></ul><p>参考自：<a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/adapter.html" target="_blank" rel="noopener">适配器模式</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件程序设计原则</title>
      <link href="/2018/11/24/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2018/11/24/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>软件也像人一样，具有生命力，从出生到死亡，会经历多种变化。软件架构设计也不是一蹴而就的，是不断地演进发展。每个程序员都可以从理解编程原则和模式中受益。</p><p>软件设计原则是一组帮助我们避开不良设计的指导方针。根据<code>Robert Martin</code>的理论，应该避免不良设计的以下三个重要特点：</p><ul><li><strong>僵化</strong>：很难做改动，因为每一个细微的改动都会影响到系统大量的其他功能</li><li><strong>脆弱</strong>：每当你做一次改动，总会引起系统中预期之外的部分出现故障</li><li><strong>死板</strong>：代码很难在其他应用中重用，因其不能从当前应用中单独抽离出来</li></ul><p>下面这些软件设计原则是我从一些书籍和网络中收集而来，并不完整，而且你也需要在一些有“冲突的原则”之间进行权衡和取舍。本文或许会对你的编程、程序设计、讨论或评审工作有所帮助。</p><h2 id="二、通用设计原则"><a href="#二、通用设计原则" class="headerlink" title="二、通用设计原则"></a>二、通用设计原则</h2><h3 id="1-KISS"><a href="#1-KISS" class="headerlink" title="1. KISS"></a>1. KISS</h3><p>所谓<code>KISS</code>原则，即：<code>Keep It Simple,Stupid</code>，指<strong>设计时要坚持简约原则，避免不必要的复杂化，并且易于修改</strong>。</p><blockquote><p>Everything should be made as simple as possible, but not simpler. - Albert Einstein</p></blockquote><p>简单清晰、功能强大是软件设计最重要的原则和目标。但是软件工程天然错综复杂，而“简单”却没有一个衡量标准，判断和实现一个东西是不是简单，可以通过以下方式来参考。</p><ul><li>让别的软件工程师以一种最容易的方式使用你的方案。</li><li>简单不是走捷径，不是为手边的问题找一个最快的方案。</li><li>当系统变得更庞大更复杂的时候依然能够被理解。</li><li>如果系统无法保持简单，那么我们能做的就是保持各个局部简单，即任何单个的类、模块、应用的设计目标及工作原理都能被快速理解。</li></ul><blockquote><p><strong>我的理解</strong>：保持简单但不能掩盖软件丰富的内涵。即<strong>简约而不简单</strong>！简约是对复杂的事物抽丝剥茧、去除细枝末节显露主要逻辑的过程。就像小时候老师教写文章，要求尽可能用朴实的语言，言简意赅的写出来，但却又要避免语言过于贫乏。软件的“抽象”和它的“直观性”，其实是一对矛盾的关系，软件设计就要保证这两者的平衡。代码抽象过于复杂会陷入“过度设计”不易理解的困境；为了“直观性”缺乏抽象，长此以往又会出现大量的重复、不易于扩展和难维护的困境。</p></blockquote><h3 id="2-DRY"><a href="#2-DRY" class="headerlink" title="2. DRY"></a>2. DRY</h3><p>所谓<code>DRY</code>原则，即：<code>Don't Repeat Yourself</code>，<strong>不要让自己重复</strong>。</p><p><strong>重复代码是软件程序变烂的万恶之首</strong>。<code>DRY</code>并不是指你不能复制代码，而是你复制的代码不能包含重复的“信息”。复制的东西并不仅仅是复制了代码，而是由于你把同一个信息散播在了代码的各个部分导致了有很多相近的代码也散播在各个地方。代码之所以要写的好，不要重复某些“信息”，因为需求人员总是要改需求，不改代码你就要“死”，改代码你就要加班，所以为了减少修改代码的痛苦，我们不能重复任何信息。举个例子，有一天需求人员说，要把分隔符从分号改成顿号！一下子就要改多个地方了。</p><p>所以，<strong>去掉重复的信息会让你的代码结构发生本质的变化</strong>。</p><p>“重复代码”有很多变体：</p><ul><li>魔法数字、魔法字符串等</li><li>相同代码块</li><li>相似的代码逻辑及操作</li></ul><p>对于消除重复的代码有<strong>事不过三</strong>法则。</p><ul><li>第一次先写了一段代码。</li><li>第二次在另一个地方写了一段相同或相似逻辑的代码，你已经有消除和提取重复代码的冲动了。</li><li>再次在另一个地方写了同样的代码，你已忍无可忍，现在可以考虑抽取和消除重复代码了。</li></ul><blockquote><p><strong>我的理解</strong>：解决重复的最佳的方式是通过培养良好的编码习惯来避免重复，通过重构的手段来消除重复。发现和解决重复并不困难，通过提取抽象、提取方法等措施就能消除重复，但困难的是<strong>立即行动</strong>去解决重复，从而不断的磨砺和提升自己的编程技艺，不断将私人代码变成公共代码，这才是自我提升的过程。解决了重复，经过一段时间，你就会发现，你对整个系统的理解程度在不知不觉中提高了不少。</p></blockquote><h3 id="3-Maximize-Cohesion，-Minimize-Coupling"><a href="#3-Maximize-Cohesion，-Minimize-Coupling" class="headerlink" title="3. Maximize Cohesion， Minimize Coupling"></a>3. Maximize Cohesion， Minimize Coupling</h3><p>所谓<code>Maximize Cohesion,Minimize Coupling</code>原则，即：<strong>高内聚低耦合</strong>。这是判断设计好坏的标准，主要是看<strong>模块内的内聚性是否高，模块间的耦合度是否低。</strong></p><ul><li><strong>耦合性</strong>：也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</li><li><strong>内聚性</strong>：又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。</li></ul><p>内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。</p><p>Java中实现高内聚低耦合的常用方式：</p><ul><li>少使用类的继承，多用接口隐藏实现的细节。</li><li>模块的功能化分尽可能的单一，道理也很简单，功能单一的模块供其它模块调用的机会就少。</li><li>遵循一个定义只在一个地方出现。</li><li>少使用全局变量。</li><li>类属性和方法的声明少用<code>public</code>，多用<code>private</code>关键字，</li><li>多用设计模式，比如采用<code>MVC</code>的设计模式就可以降低界面与业务逻辑的耦合度。</li><li>尽量不用“硬编码”的方式写程序。</li><li>最后当然就是避免直接操作或调用其它模块或类（内容耦合）。</li></ul><h3 id="4-SOC"><a href="#4-SOC" class="headerlink" title="4. SOC"></a>4. SOC</h3><p>所谓<code>SOC</code>原则，即：<strong>关注点分离</strong>（<code>Separation of Concerns</code>）。<strong>不同领域的功能，应该由不同的代码和最小重迭的模块组成。</strong>关注点分离是处理复杂性的一个原则。由于关注点混杂在一起会导致软件程序复杂性大大增加，所以能够把不同的关注点分离开来，分别处理就是处理复杂性的一个原则，一种方法。关注点分离原则不仅体现在软件程序设计等设计方法中，同时也体现在架构设计、问题求解、软件开发过程、软件项目管理以及软件开发方法学等诸多方面。</p><p><code>MVC</code>就是关注点分离的一个体现，把业务逻辑、数据、界面分离，这也是组织代码结构的一个形式。<code>MVC</code>的基本结构：</p><ul><li><code>Model</code>层表示应用程序的数据核心，通常负责在数据库中存取数据。</li><li><code>View</code>是应用程序的显示层，通常是依据模型的数据而建立。</li><li><code>Controller</code>是用来控制和处理输入输出的，是处理用户交互的部分，也负责向模型（<code>Model</code>层）发送数据。</li></ul><p><code>MVC</code>的这个设计各个关注点是分开的，这样有助于我们管理和开发复杂的应用程序，我们可以在某个时间点只集中精力在其中的某一个关注点，而不是所有的部分。</p><blockquote><p>好的架构必须使每个关注点相互分离，也就是说系统中的一个部分发生了变化，不会影响其他部分。即使需要改变，也能够清晰地识别出那些部分需要改变。如果需要扩展架构，影响将会最小化，已经可以工作的每个部分都将继续工作。——Ivar Jacobson(《AOSD中文版》)</p></blockquote><h4 id="分离方式"><a href="#分离方式" class="headerlink" title="分离方式"></a>分离方式</h4><p>下面将介绍一些分层的思想和方式:</p><ul><li><strong>纵向分离</strong>: 如常见的三层架构（逻辑控制层、业务处理层和数据持久化层）。</li><li><strong>横向分离</strong>: 如把我们的软件拆分成模块或子系统。从左到右是模块1、模块2、模块3，这是一种水平方向的切割。这跟纵向的分离是两个不同的方向，横向分离大多是模块化的过程。</li><li><strong>切面分离</strong>: 有些内容是多个层之间都需要的，比如日志（<code>log</code>），在你的系统里面，界面层、逻辑层、数据访问层可能都需要写日志，这种跨到多层同样逻辑就可以考虑切面分离。</li><li><strong>依赖方向分离</strong>: 按依赖方向考虑，决定某个类应该放在哪个层次里面，或者考虑将某一层切割成多层。</li><li><strong>关注数据分离</strong>: 在组织数据时，应该尽量考虑数据本身的固有属性，如果不是它们的固有属性，那么应该分离出来。比如产品的类就不应该关联<code>customer</code>类，应该是用订单类来把他们联系在一起。</li><li><strong>关注行为分离</strong>: 行为也应该是事物或对象的固有的本身的行为，明显偏离原来行为的，应该考虑成另外的关注点儿分离开。比如有一个函数叫做<code>CreateNewCustomer()</code>，那么<code>CreateNewCustomer()</code>的行为就应该限定在创建一个新客户上面，给新客户自动发优惠券的动作就不能放到这个函数里面。</li><li><strong>扩展分离</strong>: 如果基于某种设计，原先不具有某些行为需要增加，可以考虑通过扩展或插件的形式来完成，将这些功能放入到插件或扩展中。</li><li><strong>反转分离</strong>: 很多依赖注入的框架，如<code>Spring</code>、<code>Guice</code>等等，这些帮助我们做依赖反转，从而倒置依赖关系。</li></ul><h3 id="5-YAGNI"><a href="#5-YAGNI" class="headerlink" title="5. YAGNI"></a>5. YAGNI</h3><p>所谓<code>YAGNI</code>原则，即：<code>You Ain’t Gonna Need It</code>，<strong>你不需要它</strong>。它是一种极限编程（XP）实践，表示程序员不应为目前还不需要的功能编写代码。<code>YAGNI</code>很像<code>KISS</code>原则，因为它也是致力于构建简单的方案。然而，<code>KISS</code>是通过尽可能容易的完成某件事情来实现精简方案；但<code>YAGNI</code>是通过根本就不实现它来达到精简。<code>YAGNI</code>的观点是你应该<strong>为了眼前的需求做设计而不是未来</strong>。</p><blockquote><p>只在真正需要某些功能的时候才去实现它，而不是仅仅因为你预见到它将出现。- XP的联合创始人Ron Jeffries</p></blockquote><p>即使你非常确信将来你需要某个特性，也不要现在就去实现它。在很多情况下，你会发现或许最终你不需要它了，或者是你真正所需的特性与你之前预计的有很大的出入。遵循 YAGNI 实践有两个主要原因：</p><ul><li>你节约了时间，因为你避免了编写最终证明不必要的代码。</li><li>你的代码质量更高了，因为你使代码不必为你的“推测”所污染，而这些“推测”最终可能或多或少有些错误，但此时这些错误已牢牢地依附在你的代码中了。</li></ul><blockquote><p><strong>我的理解</strong>：YAGNI 原则，本质上是告诫我们<strong>写代码不要画蛇添足，否则就会弄巧成拙了</strong>。编写业务代码时，不要去假想一些需求或者场景，因为大多数你所设想的场景都不会发生，而你所多写的那些代码也将会长期滞留在你的系统中，收效甚微，但却让你和团队花费了更多的时间和精力去书写和维护，更可怕的是可能会对将来新的代码维护人造成困惑。另外对于没有被使用到的代码，我认为也都应该立即删除，从而保持系统的精简，如果将来需要时再去书写或恢复，而且那时侯写出的代码也绝对比之前的更为契合。</p></blockquote><h3 id="6-Boy-Scout-Rule"><a href="#6-Boy-Scout-Rule" class="headerlink" title="6. Boy-Scout Rule"></a>6. Boy-Scout Rule</h3><p><code>Boy-Scout Rule</code>，译为：<strong>童子军规则</strong>。美国童子军有一个简单的规则：“让营地比你刚来时更干净(<code>Always leave the campground cleaner than you found it</code>)”。如果看到地上有垃圾，不管是谁扔的，都要清理。这样你就有意地为下一批来宿营的人改善了环境。</p><p>童子军规则告诉我们在对现有代码库进行更改时，代码质量往往会降低，从而积累技术债务。所以需要<strong>始终保持代码整洁</strong>。不管原作者是谁，如果我们努力去改进代码模块，不管是多么小的改进，我们的软件系统就再也不会持续变坏了。取而代之的是，系统在发展的同时会逐渐变得更好。我们也会看到团队们关心整体的系统，而不是各自只关心自己负责的一小部分。而且团队成员要互助，互相清理代码，他们遵从童子军规则，因为那对每个人都很好，而不仅仅是对自己好。</p><p>关于童子军规则中所提倡的<strong>对代码坏味道的尽早修复</strong>，我也想起来了我们所熟知的“<strong>破窗效应</strong>”和“<strong>讳疾忌医</strong>”的典故：</p><h4 id="破窗效应"><a href="#破窗效应" class="headerlink" title="破窗效应"></a>破窗效应</h4><blockquote><p>如果有人打坏了一幢建筑物的窗户玻璃，而这扇窗户又得不到及时的维修，别人就可能受到某些示范性的纵容去打烂更多的窗户。久而久之，这些破窗户就给人造成一种无序的感觉，结果在这种公众麻木不仁的氛围中，犯罪就会滋生、猖獗。——政治学家威尔逊和犯罪学家凯琳提出的“破窗效应”理论</p></blockquote><ul><li>“环境早就脏了，我扔的这点儿垃圾根本起不到关键性作用。”</li><li>“这个代码以前的其他人也都是这样写的。”</li><li>“反正也不是只有我才这么写代码的。”</li></ul><p>不少人会像上面这样辩解自己的过错。其实，这些说法根本站不住脚，错了就是错了，影响的大小并不能改变行为错误的本质，别人的错误更不会是证明你无错的理由。任何一种不良现象的存在，都有可能传递一种错误信息。进而导致更坏的后果，正所谓“<strong>千里之堤，溃于蚁穴</strong>”、<strong>勿以善小而不为，勿以恶小而为之</strong>。</p><h4 id="讳疾忌医的典故"><a href="#讳疾忌医的典故" class="headerlink" title="讳疾忌医的典故"></a>讳疾忌医的典故</h4><p><img src="http://static.blinkfox.com/20181123-hjjy.png" alt="扁鹊三连"></p><p>《扁鹊见蔡桓公》的故事，我们从小就学习了，告诉我们不能盲目相信自己，不能讳疾忌医。但想想我们自己代码的坏味道和bug，也是如出一辙。</p><p>代码坏味道或者糟糕的程序代码就像隐形的“疾病”一样潜伏在项目中，也因此形成了技术债务。如果这些“疾病”在项目初期不引起注关注、不把疾病扼杀在萌芽之中，那么后期修复它的代价也就越大，也必然会使得项目的软件程序越来越难以维护，这个项目也最终会像蔡桓公一样无药可治、“无奈何也”。</p><blockquote><p>所以，请记住童子军规则对我们的启示：<strong>始终保持代码整洁，勿以善小而不为，勿以恶小而为之，有病早治</strong>。</p></blockquote><h3 id="其他原则："><a href="#其他原则：" class="headerlink" title="其他原则："></a>其他原则：</h3><ul><li><strong>避免过早优化</strong>（<code>Avoid Premature Optimization</code>）: 除非你的代码运行的比你想像中的要慢，否则别去优化。假如你真的想优化，就必须先想好如何用数据证明，它的速度变快了。“<strong>过早的优化是一切罪恶之源</strong>。”——Donald Knuth</li><li><strong>最小惊讶原则</strong>(<code>Principle of least astonishment</code>): 代码应该尽可能减少让读者惊喜。也就是说，你编写的代码只需按照项目的要求来编写。其他华丽的功能就不必了，以免弄巧成拙。</li><li><strong>代码重用原则</strong>（<code>Code Reuse is Good</code>）: 重用代码能提高代码的可读性，缩短开发时间。</li><li><strong>别让我思考</strong>(<code>Don’t Make Me Think</code>): 所编写的代码一定要易于读易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。</li><li><strong>为维护者写代码</strong>(<code>Write Code for the Maintainer</code>): 优秀的代码，应当使本人或是他人在将来都能够对它继续编写或维护。代码维护时，或许本人会比较容易，但对他人却比较麻烦。因此你写的代码要尽可能保证他人能够容易维护。“如果一个维护者不再继续维护你的代码，很可能他就有了想杀你的冲动。”</li><li><strong>正交原则(Orthogonality)</strong>: 正交性的基本思想是，在概念上不相关的事物不应该与系统相关。设计越正交，异常越少。 这使得用编程语言更容易学习，读写程序。(反例：<code>CSS</code>)。</li><li><strong>做最简单的事儿就让代码可运行</strong>（<code>Do the simplest thing that could possibly work</code>）: 尽可能做最简单的事就可以让代码可运行。在编程中，一定要保持简单原则。作为一名程序员不断的反思“如何在工作中做到简化呢？”这将有助于在设计中保持简单的路径。</li><li><strong>隐藏实现细节</strong>（<code>Hide Implementation Details</code>）: 软件模块通过提供接口隐藏信息（即实现细节），而不泄漏任何不必要的信息。</li><li><strong>科里定律</strong>(<code>Curly's Law</code>): 是为任何特定的代码选择一个明确定义的目标：<strong>只做一件事</strong>。</li><li><strong>墨菲定律</strong>（<code>Murphy's Law</code>）:根本内容是：<strong>如果事情有变坏的可能，不管这种可能性有多小，它总会发生</strong>。主要内容如下：<ul><li>任何事都没有表面看起来那么简单；</li><li>所有的事都会比你预计的时间长；</li><li>会出错的事总会出错；</li><li>如果你担心某种情况发生，那么它就更有可能发生。</li></ul></li></ul><h2 id="三、面向对象设计原则"><a href="#三、面向对象设计原则" class="headerlink" title="三、面向对象设计原则"></a>三、面向对象设计原则</h2><h3 id="1-SRP"><a href="#1-SRP" class="headerlink" title="1. SRP"></a>1. SRP</h3><p>所谓<code>SRP</code>原则，即：<code>Single Responsibility Principle</code>，<strong>单一职责原则</strong>。原始定义如下：</p><blockquote><p>There should never be more than one reason for a class to change.(<strong>只有一个引起类改变的原因</strong>)</p></blockquote><p>在面向对象编程领域中，单一职责原则（<code>Single responsibility principle</code>）规定每个类都应该有一个单一的职责或者叫功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。一个类或者模块应该有且只有一个改变的原因。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是<strong>解耦</strong>和<strong>增强内聚性</strong>。</p><h4 id="单一职责的好处："><a href="#单一职责的好处：" class="headerlink" title="单一职责的好处："></a>单一职责的好处：</h4><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义;</li><li>可读性提高，复杂性降低，可维护性提高;</li><li>变更引起的风险降低。</li></ul><h4 id="单一职责原则的注意点："><a href="#单一职责原则的注意点：" class="headerlink" title="单一职责原则的注意点："></a>单一职责原则的注意点：</h4><ul><li>单一职责最难划分的是<strong>职责</strong>。</li><li>单一职责原则提出标准：用职责和变化原因来衡量接口或类设计的是否优良，但是职责和变化原因都是不可度量的，因项目、环境而异。</li><li>接口一定要做到单一职责，类的设计尽量做到只有一个原因引起它变化。</li></ul><h3 id="2-LSP"><a href="#2-LSP" class="headerlink" title="2. LSP"></a>2. LSP</h3><p>所谓<code>LSP</code>原则，即：<code>Liskov Substitution principle</code>，<strong>里氏替换原则</strong>。原始定义如下：</p><blockquote><p>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.（<strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>）</p></blockquote><p>更通俗的定义即为：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>。里氏替换原则包含了一下4层含义：</p><ul><li>子类必须完全实现父类的方法。在类中调用其他类是务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了<code>LSP</code>原则。</li><li>子类可以有自己的个性。子类当然可以有自己的行为和外观了，也就是方法和属性。</li><li>覆盖或实现父类的方法时输入参数可以被放大。即子类可以覆盖父类的方法，但输入参数应比父类方法中的大，这样在子类代替父类的时候，调用的仍然是父类的方法。即以子类中方法的前置条件必须与超类中被覆盖的方法的前置条件相同或者更宽松。</li><li>覆盖或实现父类的方法时输出结果可以被缩小。</li></ul><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>提高代码的重用性，子类拥有父类的方法和属性；</li><li>提高代码的可扩展性，子类可形似于父类，但异于父类，保留自我的特性；</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>继承是侵入性的，只要继承就必须拥有父类的所有方法和属性，在一定程度上约束了子类，降低了代码的灵活性；</li><li>增加了耦合，当父类的常量、变量或者方法被修改了，需要考虑子类的修改，所以一旦父类有了变动，很可能会造成非常糟糕的结果，要重构大量的代码。</li></ul><h3 id="3-ISP"><a href="#3-ISP" class="headerlink" title="3. ISP"></a>3. ISP</h3><p>所谓<code>ISP</code>原则，即：<code>Interface Segregation Principle</code>，<strong>接口隔离原则</strong>。原始定义如下：</p><blockquote><p>Clients should not be forced to depend upon interfaces that they do not use.(客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。)</p></blockquote><blockquote><p>The dependency of one class to another one should depend on the smallest possible interface.(类间的依赖关系应建立在最小的接口上。)</p></blockquote><p>即，<strong>接口尽量细化，接口中的方法尽量少</strong>。接口隔离原则与单一职责原则的审视角度是不同的，单一职责原则要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。根据接口隔离原则拆分接口时，首先必须满足单一职责原则。</p><p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p><ul><li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li><li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p><h3 id="4-OCP"><a href="#4-OCP" class="headerlink" title="4. OCP"></a>4. OCP</h3><p>所谓<code>OCP</code>原则，即：<code>Open Closed Principle</code>，<strong>开闭原则</strong>。原始定义如下：</p><blockquote><p>software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.(对扩展开放，对修改关闭)</p></blockquote><p>开闭原则（<code>OCP</code>）是面向对象设计中“可复用设计”的基石，是面向对象设计中最重要的原则之一，其它很多的设计原则和设计模式都是实现开闭原则的一种手段。核心就是：<strong>对扩展开放，对修改关闭</strong>。其含义是说一个软件应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化的。</p><p>软件系统中包含的各种组件，例如模块（<code>Module</code>）、类（<code>Class</code>）以及功能（<code>Function</code>）等等，应该在不修改现有代码的基础上，引入新功能。开闭原则中“开”，是指对于组件功能的扩展是开放的，是允许对其进行功能扩展的；开闭原则中“闭”，是指对于原有代码的修改是封闭的。</p><p>实现开闭原则的关键就在于“<strong>抽象</strong>”。把系统的所有可能的行为抽象成一个抽象底层，这个抽象底层规定出所有的具体实现必须提供的方法的特征。作为系统设计的抽象层，要预见所有可能的扩展，从而使得在任何扩展情况下，系统的抽象底层不需修改；同时，由于可以从抽象底层导出一个或多个新的具体实现，可以改变系统的行为，因此系统设计对扩展是开放的。在实际开发过程的设计开始阶段，就要罗列出来系统所有可能的行为，并把这些行为加入到抽象底层，根本就是不可能的，这么去做也是不经济的。因此我们应该现实的接受修改拥抱变化，使我们的代码可以对扩展开放，对修改关闭。</p><p>开闭原则的好处：</p><ul><li>可复用性好;</li><li>可维护性好。</li></ul><h3 id="5-DIP"><a href="#5-DIP" class="headerlink" title="5. DIP"></a>5. DIP</h3><p>所谓<code>DIP</code>原则，即：<code>Dependency Inversion Principle</code>，<strong>依赖倒置原则</strong>。原始定义如下：</p><blockquote><p>High-level modules should not depend on low-level modules. Both should depend on abstractions.(<strong>高层模块不应该依赖低层模块，两者都应该依赖其抽象</strong>)</p></blockquote><blockquote><p>Abstractions should not depend on details. Details should depend on abstractions.(<strong>抽象不应该依赖细节；细节应该依赖抽象</strong>)</p></blockquote><p>面向过程的开发，上层调用下层，上层依赖于下层，当下层剧烈变动时上层也要跟着变动，这就会导致模块的复用性降低而且大大提高了开发的成本。面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。</p><p>依赖倒置原则主要有以下三层含义：</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象（抽象类或接口）；</li><li>抽象不应该依赖细节（具体实现）；  </li><li>细节（具体实现）应该依赖抽象。</li></ul><p>依赖倒置原则基于这样一个事实：<strong>相对于细节的多变性，抽象的东西要稳定的多</strong>。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在 Java 中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。<strong>依赖倒置原则的核心思想就是面向接口编程</strong>。</p><h3 id="6-LOD-LKP"><a href="#6-LOD-LKP" class="headerlink" title="6. LOD | LKP"></a>6. LOD | LKP</h3><p>所谓<code>LOD</code>原则，即：<code>Law of Demeter</code>，<strong>迪米特法则</strong>，又叫<strong>最少知识原则</strong>（<code>Least Knowledge Principle</code>，简写<code>LKP</code>），就是说一个对象应当对其他对象有尽可能少的了解。通俗的讲，一个类应该对自己需要耦合或调用的类知道得最少，被耦合的类是如何的复杂都和我没关系，即为“不和陌生人说话”。迪米特法则的英文解释如下：</p><blockquote><p>talk only to your immediate friends.(<strong>只与直接的朋友通信</strong>)</p></blockquote><p><strong>迪米特法则的初衷在于降低类之间的耦合</strong>。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。</p><p>迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的“朋友”类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度,同时也为系统的维护带来了难度。所以，在采用迪米特法则时需要反复权衡，不遵循不对，严格执行又会“过犹不及”。既要做到让结构清晰，又要做到高内聚低耦合。</p><h3 id="7-CRP"><a href="#7-CRP" class="headerlink" title="7. CRP"></a>7. CRP</h3><p>所谓<code>CRP</code>原则，即：<code>Composite Reuse Principle</code>，<strong>组合复用原则</strong>。</p><p>组合复用原则的核心思想是：<strong>尽量使用对象组合，而不是继承来达到复用的目的</strong>。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。</p><p>继承的缺点主要有以下几点：</p><ul><li>继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用。虽然简单，但不安全，不能在程序的运行过程中随便改变。</li><li>基类的实现发生了改变，派生类的实现也不得不改变。</li><li>从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。</li></ul><p>由于组合可以将已有的对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做有下面的好处：</p><ul><li>新对象存取<code>组成对象</code>的唯一方法是通过<code>组成对象</code>的<code>getter/setter</code>方法。</li><li>组合复用是黑箱复用，因为组成对象的内部细节是新对象所看不见的。</li><li>组合复用所需要的依赖较少。</li><li>每一个新的类可以将焦点集中到一个任务上。</li><li>组合复用可以在运行时间动态进行，新对象可以动态的引用与成分对象类型相同的对象。</li></ul><p>组合复用的缺点：就是用组合复用建造的系统会有较多的对象需要管理。</p><p>组合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合来实现复用；其次才考虑继承。在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</p><p>使用继承时必须满足<code>Is-A</code>的关系是才能使用继承，而组合却是一种<code>Has-A</code>的关系。导致错误的使用继承而不是使用组合的一个重要原因可能就是错误的把<code>Has-A</code>当成了<code>Is-A</code>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象编程 </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性及使用</title>
      <link href="/2018/11/13/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/11/13/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="新特性列表"><a href="#新特性列表" class="headerlink" title="新特性列表"></a>新特性列表</h2><p>以下是Java8中的引入的部分新特性。关于Java8新特性更详细的介绍可参考<a href="http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" target="_blank" rel="noopener">这里</a>。</p><ul><li>接口默认方法和静态方法</li><li>Lambda 表达式</li><li>函数式接口</li><li>方法引用</li><li>Stream</li><li>Optional</li><li>Date/Time API</li><li>重复注解</li><li>扩展注解的支持</li><li>Base64</li><li>JavaFX</li><li>其它<ul><li>JDBC4.2规范</li><li>更好的类型推测机制</li><li>HashMap性能提升</li><li>IO/NIO 的改进</li><li>JavaScript引擎Nashorn</li><li>并发（Concurrency）</li><li>类依赖分析器jdeps</li><li>JVM的PermGen空间被移除</li></ul></li></ul><h2 id="一、接口默认方法和静态方法"><a href="#一、接口默认方法和静态方法" class="headerlink" title="一、接口默认方法和静态方法"></a>一、接口默认方法和静态方法</h2><p>Java 8用默认方法与静态方法这两个新概念来扩展接口的声明。与传统的接口又有些不一样，它允许在已有的接口中添加新方法，而同时又保持了与旧版本代码的兼容性。</p><h3 id="1-接口默认方法"><a href="#1-接口默认方法" class="headerlink" title="1. 接口默认方法"></a>1. 接口默认方法</h3><p>默认方法与抽象方法不同之处在于抽象方法必须要求实现，但是默认方法则没有这个要求。相反，每个接口都必须提供一个所谓的默认实现，这样所有的接口实现者将会默认继承它（如果有必要的话，可以覆盖这个默认实现）。让我们看看下面的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">interface</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Interfaces now allow default methods, the implementer may or</span>    <span class="token comment" spellcheck="true">// may not implement (override) them.</span>    <span class="token keyword">default</span> String <span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Default implementation"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DefaultableImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OverridableImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Overridden implementation"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>Defaulable</code>接口用关键字<code>default</code>声明了一个默认方法<code>notRequired()</code>，<code>Defaulable</code>接口的实现者之一<code>DefaultableImpl</code>实现了这个接口，并且让默认方法保持原样。<code>Defaulable</code>接口的另一个实现者<code>OverridableImpl</code>用自己的方法覆盖了默认方法。</p><h4 id="1-多重继承的冲突说明"><a href="#1-多重继承的冲突说明" class="headerlink" title="(1). 多重继承的冲突说明"></a>(1). 多重继承的冲突说明</h4><p>由于同一个方法可以从不同的接口引入，自然而然的会有冲突的现象，规则如下：</p><ul><li>一个声明在类里面的方法优先于任何默认方法</li><li>优先选取最具体的实现</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token keyword">implements</span> <span class="token class-name">A</span><span class="token punctuation">,</span> B <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 Hello B</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-优缺点"><a href="#2-优缺点" class="headerlink" title="(2). 优缺点"></a>(2). 优缺点</h4><ul><li><strong>优点</strong>: 可以在不破坏代码的前提下扩展原有库的功能。它通过一个很优雅的方式使得接口变得更智能，同时还避免了代码冗余，并且扩展类库。</li><li><strong>缺点</strong>: 使得<strong>接口作为协议，类作为具体实现</strong>的界限开始变得有点模糊。</li></ul><h4 id="3-接口默认方法不能重载Object类的任何方法"><a href="#3-接口默认方法不能重载Object类的任何方法" class="headerlink" title="(3). 接口默认方法不能重载Object类的任何方法"></a>(3). 接口默认方法不能重载Object类的任何方法</h4><p><strong>接口不能提供对Object类的任何方法的默认实现</strong>。简单地讲，每一个java类都是Object的子类，也都继承了它类中的<code>equals()</code>/<code>hashCode()</code>/<code>toString()</code>方法，那么在类的接口上包含这些默认方法是没有意义的，它们也从来不会被编译。</p><p>在JVM中，默认方法的实现是非常高效的，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的Java接口，而同时能够保障正常的编译过程。这方面好的例子是大量的方法被添加到<code>java.util.Collection</code>接口中去：<code>stream()</code>，<code>parallelStream()</code>，<code>forEach()</code>，<code>removeIf()</code>等。尽管默认方法非常强大，但是在使用默认方法时我们需要小心注意一个地方：在声明一个默认方法前，请仔细思考是不是真的有必要使用默认方法。</p><h3 id="2-接口静态方法"><a href="#2-接口静态方法" class="headerlink" title="2. 接口静态方法"></a>2. 接口静态方法</h3><p>Java 8带来的另一个有趣的特性是接口可以声明（并且可以提供实现）静态方法。在接口中定义静态方法，使用<code>static</code>关键字，例如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">StaticInterface</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是Java8接口中的静态方法!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下面的一小段代码是上面静态方法的使用。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StaticInterface<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 这是Java8接口中的静态方法!</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Java支持一个实现类可以实现多个接口，如果多个接口中存在同样的<code>static</code>方法会怎么样呢？如果有两个接口中的静态方法一模一样，并且一个实现类同时实现了这两个接口，此时并不会产生错误，因为Java8中只能通过接口类调用接口中的静态方法，所以对编译器来说是可以区分的。</p><p>二、Lambda 表达式</p><p><code>Lambda</code>表达式（也称为闭包）是整个Java 8发行版中最受期待的在Java语言层面上的改变，Lambda允许把函数作为一个方法的参数（即：<strong>行为参数化</strong>，函数作为参数传递进方法中）。</p><p>一个<code>Lambda</code>可以由用逗号分隔的参数列表、<code>–&gt;</code>符号与函数体三部分表示。</p><p>首先看看在老版本的Java中是如何排列字符串的：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> names <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"peter"</span><span class="token punctuation">,</span> <span class="token string">"anna"</span><span class="token punctuation">,</span> <span class="token string">"mike"</span><span class="token punctuation">,</span> <span class="token string">"xenia"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>只需要给静态方法<code>Collections.sort</code>传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。<br>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p><pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短：</p><pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>对于函数体只有一行代码的，你可以去掉大括号<code>{}</code>以及<code>return</code>关键字，但是你还可以写得更短点：</p><pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。</p><h2 id="三、函数式接口"><a href="#三、函数式接口" class="headerlink" title="三、函数式接口"></a>三、函数式接口</h2><p><code>Lambda</code>表达式是如何在Java的类型系统中表示的呢？每一个Lambda表达式都对应一个类型，通常是接口类型。而<strong>函数式接口</strong>是指仅仅只包含一个抽象方法的接口，每一个该类型的Lambda表达式都会被匹配到这个抽象方法。因为<strong>默认方法</strong>不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p><p>我们可以将Lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加<code>@FunctionalInterface</code>注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。</p><p>示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">interface</span> <span class="token class-name">Converter</span><span class="token operator">&lt;</span>F<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span>    T <span class="token function">convert</span><span class="token punctuation">(</span>F from<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Converter<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> converter <span class="token operator">=</span> <span class="token punctuation">(</span>from<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>Integer converted <span class="token operator">=</span> converter<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>converted<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 123</span></code></pre><blockquote><p><strong>注</strong>：如果<code>@FunctionalInterface</code>如果没有指定，上面的代码也是对的。</p></blockquote><p>Java8 API包含了很多内建的函数式接口，在老Java中常用到的比如<code>Comparator</code>或者<code>Runnable</code>接口，这些接口都增加了<code>@FunctionalInterface</code>注解以便能用在<code>Lambda</code>上。</p><p>Java8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。</p><h3 id="1-Comparator-比较器接口"><a href="#1-Comparator-比较器接口" class="headerlink" title="1. Comparator (比较器接口)"></a>1. Comparator (比较器接口)</h3><p><code>Comparator</code>是老Java中的经典接口， Java 8在此之上添加了多种默认方法。源代码及使用示例如下:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>T o1<span class="token punctuation">,</span> T o2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Comparator<span class="token operator">&lt;</span>Person<span class="token operator">></span> comparator <span class="token operator">=</span> <span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> p1<span class="token punctuation">.</span>firstName<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>firstName<span class="token punctuation">)</span><span class="token punctuation">;</span>Person p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token string">"Doe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Person p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> <span class="token string">"Wonderland"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// > 0</span>comparator<span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// &lt; 0</span></code></pre><h3 id="2-Consumer-消费型接口"><a href="#2-Consumer-消费型接口" class="headerlink" title="2. Consumer (消费型接口)"></a>2. Consumer (消费型接口)</h3><p><code>Consumer</code>接口表示执行在单个参数上的操作。源代码及使用示例如下:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Consumer</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Consumer<span class="token operator">&lt;</span>Person<span class="token operator">></span> greeter <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, "</span> <span class="token operator">+</span> p<span class="token punctuation">.</span>firstName<span class="token punctuation">)</span><span class="token punctuation">;</span>greeter<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"Luke"</span><span class="token punctuation">,</span> <span class="token string">"Skywalker"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="更多的Consumer接口"><a href="#更多的Consumer接口" class="headerlink" title="更多的Consumer接口"></a>更多的Consumer接口</h4><ul><li><code>BiConsumer：void accept(T t, U u);</code>: 接受两个参数的二元函数</li><li><code>DoubleConsumer：void accept(double value);</code>: 接受一个double参数的一元函数</li><li><code>IntConsumer：void accept(int value);</code>: 接受一个int参数的一元函数</li><li><code>LongConsumer：void accept(long value);</code>: 接受一个long参数的一元函数</li><li><code>ObjDoubleConsumer：void accept(T t, double value);</code>: 接受一个泛型参数一个double参数的二元函数</li><li><code>ObjIntConsumer：void accept(T t, int value);</code>: 接受一个泛型参数一个int参数的二元函数</li><li><code>ObjLongConsumer：void accept(T t, long value);</code>: 接受一个泛型参数一个long参数的二元函数</li></ul><h3 id="3-Supplier-供应型接口"><a href="#3-Supplier-供应型接口" class="headerlink" title="3. Supplier (供应型接口)"></a>3. Supplier (供应型接口)</h3><p><code>Supplier</code>接口是不需要参数并返回一个任意范型的值。其简洁的声明，会让人以为不是函数。这个抽象方法的声明，同Consumer相反，是一个只声明了返回值，不需要参数的函数。也就是说Supplier其实表达的不是从一个参数空间到结果空间的映射能力，而是表达一种生成能力，因为我们常见的场景中不止是要consume（Consumer）或者是简单的map（Function），还包括了new这个动作。而Supplier就表达了这种能力。源代码及使用示例如下:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Supplier</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Supplier<span class="token operator">&lt;</span>Person<span class="token operator">></span> personSupplier <span class="token operator">=</span> Person<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">;</span>personSupplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// new Person</span></code></pre><h4 id="更多Supplier接口"><a href="#更多Supplier接口" class="headerlink" title="更多Supplier接口"></a>更多Supplier接口</h4><ul><li><code>BooleanSupplier：boolean getAsBoolean();</code>: 返回boolean的无参函数</li><li><code>DoubleSupplier：double getAsDouble();</code>: 返回double的无参函数</li><li><code>IntSupplier：int getAsInt();</code>: 返回int的无参函数</li><li><code>LongSupplier：long getAsLong();</code>: 返回long的无参函数</li></ul><h3 id="4-Predicate-断言型接口"><a href="#4-Predicate-断言型接口" class="headerlink" title="4. Predicate (断言型接口)"></a>4. Predicate (断言型接口)</h3><p><code>Predicate</code>接口只有一个参数，返回<code>boolean</code>类型。该接口包含多种默认方法来将<code>Predicate</code>组合成其他复杂的逻辑（比如：<strong>与</strong>，<strong>或</strong>，<strong>非</strong>）。<code>Stream</code>的<code>filter</code>方法就是接受<code>Predicate</code>作为入参的。这个具体在后面使用<code>Stream</code>的时候再分析深入。源代码及使用示例如下:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Predicate</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> <span class="token function">test</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Predicate<span class="token operator">&lt;</span>String<span class="token operator">></span> predicate <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>predicate<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// true</span>predicate<span class="token punctuation">.</span><span class="token function">negate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// false</span>Predicate<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> nonNull <span class="token operator">=</span> Objects<span class="token operator">:</span><span class="token operator">:</span>nonNull<span class="token punctuation">;</span>Predicate<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> isNull <span class="token operator">=</span> Objects<span class="token operator">:</span><span class="token operator">:</span>isNull<span class="token punctuation">;</span>Predicate<span class="token operator">&lt;</span>String<span class="token operator">></span> isEmpty <span class="token operator">=</span> String<span class="token operator">:</span><span class="token operator">:</span>isEmpty<span class="token punctuation">;</span>Predicate<span class="token operator">&lt;</span>String<span class="token operator">></span> isNotEmpty <span class="token operator">=</span> isEmpty<span class="token punctuation">.</span><span class="token function">negate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="更多的Predicate接口"><a href="#更多的Predicate接口" class="headerlink" title="更多的Predicate接口"></a>更多的Predicate接口</h4><ul><li><code>BiPredicate：boolean test(T t, U u);</code>: 接受两个参数的二元断言函数</li><li><code>DoublePredicate：boolean test(double value);</code>: 入参为double的断言函数</li><li><code>IntPredicate：boolean test(int value);</code>: 入参为int的断言函数</li><li><code>LongPredicate：boolean test(long value);</code>: 入参为long的断言函数</li></ul><h3 id="5-Function-功能型接口"><a href="#5-Function-功能型接口" class="headerlink" title="5. Function (功能型接口)"></a>5. Function (功能型接口)</h3><p><code>Function</code>接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（<code>compose</code>, <code>andThen</code>）。源代码及使用示例如下:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Function</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> R<span class="token operator">></span> <span class="token punctuation">{</span>    R <span class="token function">apply</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Function<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> toInteger <span class="token operator">=</span> Integer<span class="token operator">:</span><span class="token operator">:</span>valueOf<span class="token punctuation">;</span>Function<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> backToString <span class="token operator">=</span> toInteger<span class="token punctuation">.</span><span class="token function">andThen</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>valueOf<span class="token punctuation">)</span><span class="token punctuation">;</span>backToString<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// "123"</span></code></pre><h4 id="更多的Function接口"><a href="#更多的Function接口" class="headerlink" title="更多的Function接口"></a>更多的Function接口</h4><ul><li><code>BiFunction ：R apply(T t, U u);</code>: 接受两个参数，返回一个值，代表一个二元函数；</li><li><code>DoubleFunction ：R apply(double value);</code>: 只处理double类型的一元函数；</li><li><code>IntFunction ：R apply(int value);</code>: 只处理int参数的一元函数；</li><li><code>LongFunction ：R apply(long value);</code>: 只处理long参数的一元函数；</li><li><code>ToDoubleFunction：double applyAsDouble(T value);</code>: 返回double的一元函数；</li><li><code>ToDoubleBiFunction：double applyAsDouble(T t, U u);</code>: 返回double的二元函数；</li><li><code>ToIntFunction：int applyAsInt(T value);</code>: 返回int的一元函数；</li><li><code>ToIntBiFunction：int applyAsInt(T t, U u);</code>: 返回int的二元函数；</li><li><code>ToLongFunction：long applyAsLong(T value);</code>: 返回long的一元函数；</li><li><code>ToLongBiFunction：long applyAsLong(T t, U u);</code>: 返回long的二元函数；</li><li><code>DoubleToIntFunction：int applyAsInt(double value);</code>: 接受double返回int的一元函数；</li><li><code>DoubleToLongFunction：long applyAsLong(double value);</code>: 接受double返回long的一元函数；</li><li><code>IntToDoubleFunction：double applyAsDouble(int value);</code>: 接受int返回double的一元函数；</li><li><code>IntToLongFunction：long applyAsLong(int value);</code>: 接受int返回long的一元函数；</li><li><code>LongToDoubleFunction：double applyAsDouble(long value);</code>: 接受long返回double的一元函数；</li><li><code>LongToIntFunction：int applyAsInt(long value);</code>: 接受long返回int的一元函数；</li></ul><h3 id="6-Operator"><a href="#6-Operator" class="headerlink" title="6. Operator"></a>6. Operator</h3><p><code>Operator</code>其实就是<code>Function</code>，函数有时候也叫作算子。算子在Java8中接口描述更像是函数的补充，和上面的很多类型映射型函数类似。算子Operator包括：<code>UnaryOperator</code>和<code>BinaryOperator</code>。分别对应单（一）元算子和二元算子。</p><p>算子的接口声明如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UnaryOperator</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Function</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> UnaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">identity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> t <span class="token operator">-</span><span class="token operator">></span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BinaryOperator</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">BiFunction</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span>T<span class="token punctuation">,</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> BinaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">minBy</span><span class="token punctuation">(</span>Comparator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>comparator<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> BinaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">maxBy</span><span class="token punctuation">(</span>Comparator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>comparator<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>Operator</code>只需声明一个泛型参数T即可。对应的使用示例如下：</p><pre class=" language-java"><code class="language-java">UnaryOperator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> increment <span class="token operator">=</span> x <span class="token operator">-</span><span class="token operator">></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"递增:"</span> <span class="token operator">+</span> increment<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 递增:3</span>BinaryOperator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> add <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"相加:"</span> <span class="token operator">+</span> add<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 相加:5</span>BinaryOperator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> min <span class="token operator">=</span> BinaryOperator<span class="token punctuation">.</span><span class="token function">minBy</span><span class="token punctuation">(</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> o1 <span class="token operator">-</span> o2<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"最小值:"</span> <span class="token operator">+</span> min<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 最小值:2</span></code></pre><h4 id="更多的Operator接口"><a href="#更多的Operator接口" class="headerlink" title="更多的Operator接口"></a>更多的Operator接口</h4><ul><li><code>LongUnaryOperator：long applyAsLong(long operand);</code>: 对long类型做操作的一元算子</li><li><code>IntUnaryOperator：int applyAsInt(int operand);</code>: 对int类型做操作的一元算子</li><li><code>DoubleUnaryOperator：double applyAsDouble(double operand);</code>: 对double类型做操作的一元算子</li><li><code>DoubleBinaryOperator：double applyAsDouble(double left, double right);</code>: 对double类型做操作的二元算子</li><li><code>IntBinaryOperator：int applyAsInt(int left, int right);</code>: 对int类型做操作的二元算子</li><li><code>LongBinaryOperator：long applyAsLong(long left, long right);</code>: 对long类型做操作的二元算子</li></ul><h3 id="6-其它函数式接口"><a href="#6-其它函数式接口" class="headerlink" title="6. 其它函数式接口"></a>6. 其它函数式接口</h3><ul><li>java.lang.Runnable</li><li>java.util.concurrent.Callable</li><li>java.security.PrivilegedAction</li><li>java.io.FileFilter</li><li>java.nio.file.PathMatcher </li><li>java.lang.reflect.InvocationHandler</li><li>java.beans.PropertyChangeListener</li><li>java.awt.event.ActionListener  </li><li>javax.swing.event.ChangeListener</li></ul><h2 id="四、方法引用"><a href="#四、方法引用" class="headerlink" title="四、方法引用"></a>四、方法引用</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>在学习了Lambda表达式之后，我们通常使用Lambda表达式来创建匿名方法。然而，有时候我们仅仅是调用了一个已存在的方法。如下：</p><pre class=" language-java"><code class="language-java">Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strArray<span class="token punctuation">,</span> <span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s1<span class="token punctuation">.</span><span class="token function">compareToIgnoreCase</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在Java8中，我们可以直接通过方法引用来简写Lambda表达式中已经存在的方法。</p><pre class=" language-java"><code class="language-java">Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strArray<span class="token punctuation">,</span> String<span class="token operator">:</span><span class="token operator">:</span>compareToIgnoreCase<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这种特性就叫做<strong>方法引用</strong>(<code>Method Reference</code>)。</p><p><strong>方法引用</strong>是用来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。当Lambda表达式中只是执行一个方法调用时，不用Lambda表达式，直接通过方法引用的形式可读性更高一些。方法引用是一种更简洁易懂的Lambda表达式。</p><blockquote><p><strong>注意</strong>: 方法引用是一个Lambda表达式，其中方法引用的操作符是双冒号<code>::</code>。</p></blockquote><h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h3><p>方法引用的标准形式是：<code>类名::方法名</code>。（注意：只需要写方法名，不需要写括号）</p><p>有以下四种形式的方法引用：</p><ul><li>引用静态方法: ContainingClass::staticMethodName</li><li>引用某个对象的实例方法: containingObject::instanceMethodName</li><li>引用某个类型的任意对象的实例方法:ContainingType::methodName</li><li>引用构造方法: ClassName::new</li></ul><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>使用示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    String name<span class="token punctuation">;</span>    LocalDate birthday<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> LocalDate birthday<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>birthday <span class="token operator">=</span> birthday<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> LocalDate <span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> birthday<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">compareByAge</span><span class="token punctuation">(</span>Person a<span class="token punctuation">,</span> Person b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a<span class="token punctuation">.</span>birthday<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>birthday<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodReferenceTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Person<span class="token punctuation">[</span><span class="token punctuation">]</span> pArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"003"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"001"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"002"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"004"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用匿名类</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pArr<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Person<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Person a<span class="token punctuation">,</span> Person b<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使用lambda表达式</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pArr<span class="token punctuation">,</span> <span class="token punctuation">(</span>Person a<span class="token punctuation">,</span> Person b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使用方法引用，引用的是类的静态方法</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pArr<span class="token punctuation">,</span> Person<span class="token operator">:</span><span class="token operator">:</span>compareByAge<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、Stream"><a href="#五、Stream" class="headerlink" title="五、Stream"></a>五、Stream</h2><p>Java8添加的<code>Stream API(java.util.stream)</code>把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为<code>Stream API</code>可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>流可以是无限的、有状态的，可以是顺序的，也可以是并行的。在使用流的时候，你首先需要从一些来源中获取一个流，执行一个或者多个中间操作，然后执行一个最终操作。中间操作包括<code>filter</code>、<code>map</code>、<code>flatMap</code>、<code>peel</code>、<code>distinct</code>、<code>sorted</code>、<code>limit</code>和<code>substream</code>。终止操作包括<code>forEach</code>、<code>toArray</code>、<code>reduce</code>、<code>collect</code>、<code>min</code>、<code>max</code>、<code>count</code>、<code>anyMatch</code>、<code>allMatch</code>、<code>noneMatch</code>、<code>findFirst</code>和<code>findAny</code>。 <code>java.util.stream.Collectors</code>是一个非常有用的实用类。该类实现了很多归约操作，例如将流转换成集合和聚合元素。</p><h3 id="1-一些重要方法说明"><a href="#1-一些重要方法说明" class="headerlink" title="1. 一些重要方法说明"></a>1. 一些重要方法说明</h3><ul><li><code>stream</code>: 返回数据流，集合作为其源</li><li><code>parallelStream</code>: 返回并行数据流， 集合作为其源</li><li><code>filter</code>: 方法用于过滤出满足条件的元素</li><li><code>map</code>: 方法用于映射每个元素对应的结果</li><li><code>forEach</code>: 方法遍历该流中的每个元素</li><li><code>limit</code>: 方法用于减少流的大小</li><li><code>sorted</code>: 方法用来对流中的元素进行排序</li><li><code>anyMatch</code>: 是否存在任意一个元素满足条件（返回布尔值）</li><li><code>allMatch</code>: 是否所有元素都满足条件（返回布尔值）</li><li><code>noneMatch</code>: 是否所有元素都不满足条件（返回布尔值）</li><li><code>collect</code>: 方法是终端操作，这是通常出现在管道传输操作结束标记流的结束</li></ul><h3 id="2-一些使用示例"><a href="#2-一些使用示例" class="headerlink" title="2. 一些使用示例"></a>2. 一些使用示例</h3><h4 id="1-Filter-过滤"><a href="#1-Filter-过滤" class="headerlink" title="(1). Filter 过滤"></a>(1). Filter 过滤</h4><pre class=" language-java"><code class="language-java">stringCollection    <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="2-Sort-排序"><a href="#2-Sort-排序" class="headerlink" title="(2). Sort 排序"></a>(2). Sort 排序</h3><pre class=" language-java"><code class="language-java">stringCollection    <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="3-Map-映射"><a href="#3-Map-映射" class="headerlink" title="(3). Map 映射"></a>(3). Map 映射</h3><pre class=" language-java"><code class="language-java">stringCollection    <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>toUpperCase<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="4-Match-匹配"><a href="#4-Match-匹配" class="headerlink" title="(4). Match 匹配"></a>(4). Match 匹配</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">boolean</span> anyStartsWithA <span class="token operator">=</span> stringCollection        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>anyStartsWithA<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// true</span><span class="token keyword">boolean</span> allStartsWithA <span class="token operator">=</span> stringCollection        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">allMatch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>allStartsWithA<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// false</span><span class="token keyword">boolean</span> noneStartsWithZ <span class="token operator">=</span> stringCollection        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">noneMatch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"z"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>noneStartsWithZ<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// true</span></code></pre><h3 id="5-Count-计数"><a href="#5-Count-计数" class="headerlink" title="(5). Count 计数"></a>(5). Count 计数</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">long</span> startsWithB <span class="token operator">=</span> stringCollection        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>startsWithB<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3</span></code></pre><h3 id="6-Reduce-规约"><a href="#6-Reduce-规约" class="headerlink" title="(6). Reduce 规约"></a>(6). Reduce 规约</h3><p>这是一个最终操作，允许通过指定的函数来将<code>stream</code>中的多个元素规约为一个元素，规越后的结果是通过<code>Optional</code>接口表示的。代码如下:</p><pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> reduced <span class="token operator">=</span> stringCollection        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s1 <span class="token operator">+</span> <span class="token string">"#"</span> <span class="token operator">+</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>reduced<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="六、Optional"><a href="#六、Optional" class="headerlink" title="六、Optional"></a>六、Optional</h2><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的<code>Guava</code>项目引入了<code>Optional</code>类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，<code>Optional</code>类已经成为Java 8类库的一部分。</p><p><code>Optional</code>实际上是个容器：它可以保存类型T的值，或者仅仅保存null。<code>Optional</code>提供很多有用的方法，这样我们就不用显式进行空值检测。</p><p>我们下面用两个小例子来演示如何使用Optional类：一个允许为空值，一个不允许为空值。</p><pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> fullName <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Full Name is set? "</span> <span class="token operator">+</span> fullName<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Full Name: "</span> <span class="token operator">+</span> fullName<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"[none]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fullName<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"Hey "</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"Hey Stranger!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果<code>Optional</code>类的实例为非空值的话，<code>isPresent()</code>返回<code>true</code>，否从返回<code>false</code>。为了防止Optional为空值，<code>orElseGet()</code>方法通过回调函数来产生一个默认值。<code>map()</code>函数对当前<code>Optional</code>的值进行转化，然后返回一个新的<code>Optional</code>实例。<code>orElse()</code>方法和<code>orElseGet()</code>方法类似，但是<code>orElse</code>接受一个默认值而不是一个回调函数。下面是这个程序的输出：</p><pre class=" language-bash"><code class="language-bash">Full Name is set? <span class="token boolean">false</span>Full Name: <span class="token punctuation">[</span>none<span class="token punctuation">]</span>Hey Stranger<span class="token operator">!</span></code></pre><p>让我们来看看另一个例子：</p><pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> firstName <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"First Name is set? "</span> <span class="token operator">+</span> firstName<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"First Name: "</span> <span class="token operator">+</span> firstName<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"[none]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>firstName<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"Hey "</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"Hey Stranger!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>下面是程序的输出：</p><pre class=" language-bash"><code class="language-bash">First Name is set? <span class="token boolean">true</span>First Name: TomHey Tom<span class="token operator">!</span></code></pre><h2 id="七、Date-Time-API"><a href="#七、Date-Time-API" class="headerlink" title="七、Date/Time API"></a>七、Date/Time API</h2><p>Java 8 在包<code>java.time</code>下包含了一组全新的时间日期API。新的日期API和开源的<code>Joda-Time</code>库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：</p><h3 id="1-Clock-时钟"><a href="#1-Clock-时钟" class="headerlink" title="1. Clock 时钟"></a>1. Clock 时钟</h3><p><code>Clock</code>类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代<code>System.currentTimeMillis()</code>来获取当前的微秒数。某一个特定的时间点也可以使用<code>Instant</code>类来表示，<code>Instant</code>类也可以用来创建老的<code>java.util.Date</code>对象。代码如下:</p><pre class=" language-java"><code class="language-java">Clock clock <span class="token operator">=</span> Clock<span class="token punctuation">.</span><span class="token function">systemDefaultZone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> millis <span class="token operator">=</span> clock<span class="token punctuation">.</span><span class="token function">millis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Instant instant <span class="token operator">=</span> clock<span class="token punctuation">.</span><span class="token function">instant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Date legacyDate <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>instant<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// legacy java.util.Date</span></code></pre><h3 id="2-Timezones-时区"><a href="#2-Timezones-时区" class="headerlink" title="2. Timezones 时区"></a>2. Timezones 时区</h3><p>在新API中时区使用<code>ZoneId</code>来表示。时区可以很方便的使用静态方法<code>of</code>来获取到。时区定义了到UTS时间的时间差，在<code>Instant</code>时间点对象到本地日期对象之间转换的时候是极其重要的。代码如下:</p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span><span class="token function">getAvailableZoneIds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// prints all available timezone ids</span>ZoneId zone1 <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Europe/Berlin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ZoneId zone2 <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Brazil/East"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zone1<span class="token punctuation">.</span><span class="token function">getRules</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zone2<span class="token punctuation">.</span><span class="token function">getRules</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ZoneRules[currentStandardOffset=+01:00]</span><span class="token comment" spellcheck="true">// ZoneRules[currentStandardOffset=-03:00]</span></code></pre><h3 id="3-LocalTime-本地时间"><a href="#3-LocalTime-本地时间" class="headerlink" title="3. LocalTime 本地时间"></a>3. LocalTime 本地时间</h3><p><code>LocalTime</code>定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差。代码如下:</p><pre class=" language-java"><code class="language-java">LocalTime now1 <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>zone1<span class="token punctuation">)</span><span class="token punctuation">;</span>LocalTime now2 <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>zone2<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>now1<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span>now2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// false</span><span class="token keyword">long</span> hoursBetween <span class="token operator">=</span> ChronoUnit<span class="token punctuation">.</span>HOURS<span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>now1<span class="token punctuation">,</span> now2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> minutesBetween <span class="token operator">=</span> ChronoUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>now1<span class="token punctuation">,</span> now2<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hoursBetween<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// -3</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>minutesBetween<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// -239</span></code></pre><p><code>LocalTime</code>提供了多种工厂方法来简化对象的创建，包括解析时间字符串。代码如下:</p><pre class=" language-java"><code class="language-java">LocalTime late <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>late<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 23:59:59</span>DateTimeFormatter germanFormatter <span class="token operator">=</span> DateTimeFormatter        <span class="token punctuation">.</span><span class="token function">ofLocalizedTime</span><span class="token punctuation">(</span>FormatStyle<span class="token punctuation">.</span>SHORT<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">withLocale</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span>GERMAN<span class="token punctuation">)</span><span class="token punctuation">;</span>LocalTime leetTime <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"13:37"</span><span class="token punctuation">,</span> germanFormatter<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>leetTime<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 13:37</span></code></pre><h3 id="4-LocalDate-本地日期"><a href="#4-LocalDate-本地日期" class="headerlink" title="4. LocalDate 本地日期"></a>4. LocalDate 本地日期</h3><p><code>LocalDate</code>表示了一个确切的日期，比如<code>2014-03-11</code>。该对象值是不可变的，用起来和<code>LocalTime</code>基本一致。下面的例子展示了如何给<code>Date</code>对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。代码如下:</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate tomorrow <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ChronoUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate yesterday <span class="token operator">=</span> tomorrow<span class="token punctuation">.</span><span class="token function">minusDays</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate independenceDay <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>JULY<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>DayOfWeek dayOfWeek <span class="token operator">=</span> independenceDay<span class="token punctuation">.</span><span class="token function">getDayOfWeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dayOfWeek<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// FRIDAY</span></code></pre><p>从字符串解析一个LocalDate类型和解析LocalTime一样简单。代码如下:</p><pre class=" language-java"><code class="language-java">DateTimeFormatter germanFormatter <span class="token operator">=</span> DateTimeFormatter        <span class="token punctuation">.</span><span class="token function">ofLocalizedDate</span><span class="token punctuation">(</span>FormatStyle<span class="token punctuation">.</span>MEDIUM<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">withLocale</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span>GERMAN<span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate xmas <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"24.12.2014"</span><span class="token punctuation">,</span> germanFormatter<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>xmas<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 2014-12-24</span></code></pre><h3 id="5-LocalDateTime-本地日期时间"><a href="#5-LocalDateTime-本地日期时间" class="headerlink" title="5. LocalDateTime 本地日期时间"></a>5. LocalDateTime 本地日期时间</h3><p><code>LocalDateTime</code>同时表示了时间和日期，相当于前两节内容合并到一个对象上了。<code>LocalDateTime</code>和<code>LocalTime</code>还有<code>LocalDate</code>一样，都是不可变的。<code>LocalDateTime</code>提供了一些能访问具体字段的方法。代码如下:</p><pre class=" language-java"><code class="language-java">LocalDateTime sylvester <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>DECEMBER<span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">)</span><span class="token punctuation">;</span>DayOfWeek dayOfWeek <span class="token operator">=</span> sylvester<span class="token punctuation">.</span><span class="token function">getDayOfWeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dayOfWeek<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// WEDNESDAY</span>Month month <span class="token operator">=</span> sylvester<span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// DECEMBER</span><span class="token keyword">long</span> minuteOfDay <span class="token operator">=</span> sylvester<span class="token punctuation">.</span><span class="token function">getLong</span><span class="token punctuation">(</span>ChronoField<span class="token punctuation">.</span>MINUTE_OF_DAY<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>minuteOfDay<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1439</span></code></pre><p>只要附加上时区信息，就可以将其转换为一个时间点<code>Instant</code>对象，<code>Instant</code>时间点对象可以很容易的转换为老式的<code>java.util.Date</code>。代码如下:</p><pre class=" language-java"><code class="language-java">Instant instant <span class="token operator">=</span> sylvester        <span class="token punctuation">.</span><span class="token function">atZone</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Date legacyDate <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>instant<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>legacyDate<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// Wed Dec 31 23:59:59 CET 2014</span></code></pre><p>格式化<code>LocalDateTime</code>和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式。代码如下:</p><pre class=" language-java"><code class="language-java">DateTimeFormatter formatter <span class="token operator">=</span>    DateTimeFormatter        <span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"MMM dd, yyyy - HH:mm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDateTime parsed <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"Nov 03, 2014 - 07:13"</span><span class="token punctuation">,</span> formatter<span class="token punctuation">)</span><span class="token punctuation">;</span>String string <span class="token operator">=</span> formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>parsed<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// Nov 03, 2014 - 07:13</span></code></pre><p>和<code>java.text.NumberFormat</code>不一样的是新版的<code>DateTimeFormatter</code>是不可变的，所以它是线程安全的。</p><p>关于Java8中日期API更多的使用示例可以参考<a href="http://blinkfox.com/java-8zhong-guan-yu-ri-qi-he-shi-jian-apide-20ge-shi-yong-shi-li/" target="_blank" rel="noopener">Java 8中关于日期和时间API的20个使用示例</a>。</p><h2 id="八、重复注解"><a href="#八、重复注解" class="headerlink" title="八、重复注解"></a>八、重复注解</h2><p>自从Java 5引入了注解机制，这一特性就变得非常流行并且广为使用。然而，使用注解的一个限制是相同的注解在同一位置只能声明一次，不能声明多次。Java 8打破了这条规则，引入了重复注解机制，这样相同的注解可以在同一地方声明多次。</p><p>重复注解机制本身必须用<code>@Repeatable</code>注解。事实上，这并不是语言层面上的改变，更多的是编译器的技巧，底层的原理保持不变。让我们看一个快速入门的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Repeatable<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RepeatingAnnotations</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Filters</span> <span class="token punctuation">{</span>        Filter<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>    <span class="token annotation punctuation">@Repeatable</span><span class="token punctuation">(</span>Filters<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>        String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span><span class="token string">"filter1"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span><span class="token string">"filter2"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Filterable</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Filter filter<span class="token operator">:</span> Filterable<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getAnnotationsByType</span><span class="token punctuation">(</span>Filter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>正如我们看到的，这里有个使用<code>@Repeatable(Filters.class)</code>注解的注解类<code>Filter</code>，<code>Filters</code>仅仅是<code>Filter</code>注解的数组，但Java编译器并不想让程序员意识到<code>Filters</code>的存在。这样，接口<code>Filterable</code>就拥有了两次<code>Filter</code>（并没有提到<code>Filter</code>）注解。</p><p>同时，反射相关的API提供了新的函数<code>getAnnotationsByType()</code>来返回重复注解的类型（请注意<code>Filterable.class.getAnnotation(Filters.class</code>)`经编译器处理后将会返回Filters的实例）。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射基础</title>
      <link href="/2018/11/07/Java%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/11/07/Java%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>Java反射(<code>Reflection</code>)机制就是在运行状态中，对于任意一个类，都能够知道这个类的属性和方法。对于任意一个对象能够调用它的任意一个属性和方法。这种动态获取的信息和动态调用对象的方法的功能称为Java语言的反射机制。Java程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p><p>反射的核心是JVM在<strong>运行时</strong>才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。反射机制就是通过<code>java.lang.Class</code>类来实现的，在Java中，Object 类是所有类的根类，而Class类就是描述Java类的类。</p><blockquote><p><strong>注</strong>：因为Class类也是类，所以Object也包括Class类。</p></blockquote><h3 id="2-主要功能"><a href="#2-主要功能" class="headerlink" title="2. 主要功能"></a>2. 主要功能</h3><p>Java反射框架主要提供以下功能：</p><ul><li>在运行时判断任意一个对象所属的类；</li><li>在运行时构造任意一个类的对象；</li><li>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li><li>在运行时调用任意一个对象的方法；</li><li>修改构造函数、方法、属性的可见性。</li></ul><h3 id="3-主要用途"><a href="#3-主要用途" class="headerlink" title="3. 主要用途"></a>3. 主要用途</h3><p><strong>反射最重要的用途就是开发各种通用框架</strong>。很多框架（比如Spring）都是配置化的（比如通过XML文件配置JavaBean,Action之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。</p><h2 id="二、反射的使用"><a href="#二、反射的使用" class="headerlink" title="二、反射的使用"></a>二、反射的使用</h2><h3 id="1-获取Class对象"><a href="#1-获取Class对象" class="headerlink" title="1. 获取Class对象"></a>1. 获取Class对象</h3><p>反射的各种功能都需要通过Class对象来实现，因此，需要知道如何获取Class对象，主要有以下几种方式。</p><h4 id="使用-Class-forName-的静态方法"><a href="#使用-Class-forName-的静态方法" class="headerlink" title="使用 Class.forName() 的静态方法"></a>使用 Class.forName() 的静态方法</h4><p><code>Class.forName(String className)</code>方法可以通过类或接口的名称（一个字符串或完全限定名）来获取对应的Class对象。</p><pre class=" language-java"><code class="language-java">Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> cls <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.niww.Zealot"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="直接获取某个类的class-最安全-性能最好"><a href="#直接获取某个类的class-最安全-性能最好" class="headerlink" title="直接获取某个类的class(最安全/性能最好)"></a>直接获取某个类的class(最安全/性能最好)</h4><pre class=" language-java"><code class="language-java">Class<span class="token operator">&lt;</span>String<span class="token operator">></span> cls <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span></code></pre><h4 id="调用某个对象的-getClass-方法"><a href="#调用某个对象的-getClass-方法" class="headerlink" title="调用某个对象的 getClass() 方法"></a>调用某个对象的 getClass() 方法</h4><pre class=" language-java"><code class="language-java">Class<span class="token operator">&lt;</span>String<span class="token operator">></span> cls <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="2-判断是否为某个类的实例"><a href="#2-判断是否为某个类的实例" class="headerlink" title="2. 判断是否为某个类的实例"></a>2. 判断是否为某个类的实例</h3><p>一般地，我们用<code>instanceof</code>关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的<code>isInstance()</code>方法来判断是否为某个类的实例，它是一个Native方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">isInstance</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="3-创建实例"><a href="#3-创建实例" class="headerlink" title="3. 创建实例"></a>3. 创建实例</h3><p>通过反射来生成对象主要有两种方式。</p><h4 id="使用Class对象的newInstance-方法"><a href="#使用Class对象的newInstance-方法" class="headerlink" title="使用Class对象的newInstance()方法"></a>使用Class对象的newInstance()方法</h4><pre class=" language-java"><code class="language-java">Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>Object str <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance-方法"><a href="#通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance-方法" class="headerlink" title="通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法"></a>通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 获取String所对应的Class对象</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取String类带一个String参数的构造器</span>Constructor constructor <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 根据构造器创建实例</span>Object obj <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">"23333"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p><strong>注</strong>：这种方法可以用指定的构造器构造类的实例。</p></blockquote><h3 id="4-获取方法"><a href="#4-获取方法" class="headerlink" title="4. 获取方法"></a>4. 获取方法</h3><p>获取某个Class对象的方法集合，主要有以下几个方法：</p><ul><li><code>getDeclaredMethods()</code>方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Method<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException</code></pre><ul><li><code>getMethods()</code>方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Method<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException</code></pre><ul><li><code>getMethod()</code>方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Method <span class="token function">getMethod</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span></code></pre><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationTargetException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span>            InstantiationException<span class="token punctuation">,</span> NoSuchMethodException<span class="token punctuation">,</span> InvocationTargetException <span class="token punctuation">{</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> MethodClass<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        Object object <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Method<span class="token punctuation">[</span><span class="token punctuation">]</span> methods <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Method<span class="token punctuation">[</span><span class="token punctuation">]</span> declaredMethods <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取MethodClass类的add方法</span>        Method method <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//getMethods()方法获取的所有方法</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getMethods获取的方法："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Method m<span class="token operator">:</span> methods<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//getDeclaredMethods()方法获取的所有方法</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getDeclaredMethods获取的方法："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Method m<span class="token operator">:</span> declaredMethods<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MethodClass</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> fuck <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：通过<code>getMethods()</code>获取的方法可以获取到父类的方法,比如<code>java.lang.Object</code>下定义的各个方法。</p></blockquote><h3 id="5-获取构造方法"><a href="#5-获取构造方法" class="headerlink" title="5. 获取构造方法"></a>5. 获取构造方法</h3><p>获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的<code>getConstructor</code>方法得到<code>Constructor</code>类的一个实例，而Constructor类有一个<code>newInstance</code>方法可以创建一个对象实例:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> T <span class="token function">newInstance</span><span class="token punctuation">(</span>Object <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> initargs<span class="token punctuation">)</span></code></pre><blockquote><p><strong>注</strong>：此方法可以根据传入的参数来调用对应的Constructor创建对象实例。</p></blockquote><h3 id="6-获取类的成员变量信息"><a href="#6-获取类的成员变量信息" class="headerlink" title="6. 获取类的成员变量信息"></a>6. 获取类的成员变量信息</h3><p>获取的方法同Method相似，主要是这几个方法，在此不再赘述：</p><ul><li><code>Field getField(String name)</code>: 访问公有的成员变量。</li><li><code>Field[] getDeclaredFields()</code>：所有已声明的成员变量。但不能得到其父类的成员变量。</li><li><code>Field[] getFields()</code>和<code>Field[] getDeclaredFields()</code>用法同上。</li></ul><h3 id="7-调用方法"><a href="#7-调用方法" class="headerlink" title="7. 调用方法"></a>7. 调用方法</h3><p>当我们从类中获取了一个方法后，我们就可以用invoke()方法来调用这个方法。invoke方法的原型为:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span> IllegalArgumentException<span class="token punctuation">,</span> InvocationTargetException</code></pre><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span>            InstantiationException<span class="token punctuation">,</span> NoSuchMethodException<span class="token punctuation">,</span> InvocationTargetException <span class="token punctuation">{</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> klass <span class="token operator">=</span> MethodClass<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建 MethodClass 的实例</span>        Object obj <span class="token operator">=</span> klass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取 MethodClass 类的add方法</span>        Method method <span class="token operator">=</span> klass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//调用 method 对应的方法 => add(1,4)</span>        Object result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MethodClass</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> fuck <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="8-利用反射创建数组"><a href="#8-利用反射创建数组" class="headerlink" title="8. 利用反射创建数组"></a>8. 利用反射创建数组</h3><p>数组在Java里是比较特殊的一种类型，它可以赋值给一个<code>Object Reference</code>。下面我们看一看利用反射创建数组的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 使用`java.lang.reflect.Array`反射创建长度为25的字符串数组.</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> cls <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.String"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Object array <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 往数组里添加内容</span>    Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Java"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"Go"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"Scala"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"Clojure"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取某一项的内容</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="三、使用反射获取信息"><a href="#三、使用反射获取信息" class="headerlink" title="三、使用反射获取信息"></a>三、使用反射获取信息</h2><p>Class类提供了大量的实例方法来获取该Class对象所对应的详细信息，Class类大致包含如下方法，其中每个方法都包含多个重载版本，因此我们只是做简单的介绍，详细请参考<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html" target="_blank" rel="noopener">JDK文档</a>。</p><h3 id="1-获取类内信息"><a href="#1-获取类内信息" class="headerlink" title="1. 获取类内信息"></a>1. 获取类内信息</h3><ul><li>构造器: <code>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code></li><li>包含的方法: <code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></li><li>包含的属性: <code>Field getField(String name)</code></li><li>包含的Annotation: <code>&lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass)</code></li><li>内部类: <code>Class&lt;?&gt;[] getDeclaredClasses()</code></li><li>外部类: <code>Class&lt;?&gt; getDeclaringClass()</code></li><li>所实现的接口: <code>Class&lt;?&gt;[] getInterfaces()</code></li><li>修饰符: <code>int getModifiers()</code></li><li>所在包: <code>Package getPackage()</code></li><li>类名: <code>String getName()</code></li><li>简称: <code>String getSimpleName()</code></li></ul><h3 id="2-判断类本身信息的方法"><a href="#2-判断类本身信息的方法" class="headerlink" title="2. 判断类本身信息的方法"></a>2. 判断类本身信息的方法</h3><ul><li>是否注解类型: <code>boolean isAnnotation()</code></li><li>是否使用了该Annotation修饰: <code>boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code></li><li>是否匿名类: <code>boolean isAnonymousClass()</code></li><li>是否数组: <code>boolean isArray()</code></li><li>是否枚举: <code>boolean isEnum()</code></li><li>是否原始类型: <code>boolean isPrimitive()</code></li><li>是否接口: <code>boolean isInterface()</code></li><li>obj是否是该Class的实例: <code>boolean isInstance(Object obj)</code></li></ul><h3 id="3-使用反射获取泛型信息"><a href="#3-使用反射获取泛型信息" class="headerlink" title="3. 使用反射获取泛型信息"></a>3. 使用反射获取泛型信息</h3><p>为了通过反射操作泛型以迎合实际开发的需要, Java新增了<code>java.lang.reflect.ParameterizedType</code>、<code>java.lang.reflect.GenericArrayType</code>、<code>java.lang.reflect.TypeVariable</code>、<code>java.lang.reflect.WildcardType</code>几种类型来代表不能归一到Class类型但是又和原始类型同样重要的类型。</p><ul><li><code>ParameterizedType</code>: 一种参数化类型, 比如Collection<string></string></li><li><code>GenericArrayType</code>: 一种元素类型是参数化类型或者类型变量的数组类型</li><li><code>TypeVariable</code>: 各种类型变量的公共接口</li><li><code>WildcardType</code>: 一种通配符类型表达式, 如<code>?</code>、<code>? extends Number</code>、<code>? super Integer</code></li></ul><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> objectMap<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> User<span class="token operator">></span> map<span class="token punctuation">,</span> String string<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>User<span class="token punctuation">,</span> Bean<span class="token operator">></span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试属性类型     *     * @throws NoSuchFieldException     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFieldType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchFieldException <span class="token punctuation">{</span>        Field field <span class="token operator">=</span> Client<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"objectMap"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Type gType <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">getGenericType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 打印type与generic type的区别</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>gType<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"**************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>gType <span class="token keyword">instanceof</span> <span class="token class-name">ParameterizedType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ParameterizedType pType <span class="token operator">=</span> <span class="token punctuation">(</span>ParameterizedType<span class="token punctuation">)</span> gType<span class="token punctuation">;</span>            Type<span class="token punctuation">[</span><span class="token punctuation">]</span> types <span class="token operator">=</span> pType<span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Type type <span class="token operator">:</span> types<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试参数类型     *     * @throws NoSuchMethodException     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testParamType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchMethodException <span class="token punctuation">{</span>        Method testMethod <span class="token operator">=</span> Client<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> Map<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Type<span class="token punctuation">[</span><span class="token punctuation">]</span> parameterTypes <span class="token operator">=</span> testMethod<span class="token punctuation">.</span><span class="token function">getGenericParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Type type <span class="token operator">:</span> parameterTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"type -> "</span> <span class="token operator">+</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token keyword">instanceof</span> <span class="token class-name">ParameterizedType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Type<span class="token punctuation">[</span><span class="token punctuation">]</span> actualTypes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ParameterizedType<span class="token punctuation">)</span> type<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>Type actualType <span class="token operator">:</span> actualTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\tactual type -> "</span> <span class="token operator">+</span> actualType<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试返回值类型     *     * @throws NoSuchMethodException     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchMethodException <span class="token punctuation">{</span>        Method testMethod <span class="token operator">=</span> Client<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Type returnType <span class="token operator">=</span> testMethod<span class="token punctuation">.</span><span class="token function">getGenericReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"return type -> "</span> <span class="token operator">+</span> returnType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>returnType <span class="token keyword">instanceof</span> <span class="token class-name">ParameterizedType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Type<span class="token punctuation">[</span><span class="token punctuation">]</span> actualTypes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ParameterizedType<span class="token punctuation">)</span> returnType<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Type actualType <span class="token operator">:</span> actualTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\tactual type -> "</span> <span class="token operator">+</span> actualType<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><p>参考文档：<a href="http://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener">Java反射基础</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之责任链模式</title>
      <link href="/2018/11/04/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/04/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>很多情况下，在一个软件系统中可以处理某个请求的对象不止一个。例如审批工作流等，他们可以构成一条处理采购单的链式结构，采购单(可以看作是要处理的信息)沿着这条链进行传递，这条链就称为责任链。责任链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，责任链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理。在此过程中，客户端实际上无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，从而实现请求发送者和请求处理者解耦。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote><p><strong>定义</strong>：责任链模式(<code>Chain of Responsibility Pattern</code>)是使多个对象都有机会处理请求，从而避免请求的发送者与请求处理者耦合在一起。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。它是一种对象行为型模式。</p></blockquote><p><strong>实质</strong>：责任链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，从而实现请求发送者与请求处理者的解耦。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h3><ul><li><code>Handler</code>（抽象处理者）：处理请求的接口，一般设计为具有抽象请求处理方法的抽象类，以便于不同的具体处理者进行继承，从而实现具体的请求处理方法。此外，由于每一个请求处理者的下家还是一个处理者，因此抽象处理者本身还包含了一个本身的引用(<code>nextHandler</code>)作为其对下家的引用，以便将处理者链成一条链；</li><li><code>ConcreteHandler</code>（具体处理者）：抽象处理者的子类，可以处理用户请求，其实现了抽象处理者中定义的请求处理方法。在具体处理请求时需要进行判断，若其具有相应的处理权限，那么就处理它；否则，其将请求转发给后继者，以便让后面的处理者进行处理。</li></ul><p>在责任链模式里，由每一个请求处理者对象对其下家的引用而连接起来形成一条请求处理链。请求将在这条链上一直传递，直到链上的某一个请求处理者能够处理此请求。<strong>发出这个请求的客户端并不知道链上的哪一个请求处理者将处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任</strong>。</p><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="http://static.blinkfox.com/chain_of_responsibility.png" alt="责任链模式UML类图"></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>首先，责任链模式的核心在于对请求处理者的抽象。在实现过程中，抽象处理者一般会被设定为<strong>抽象类</strong>，其典型实现代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 责任连模式的抽象处理者角色. * * Created by niww on 16/7/11. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 后继处理者角色. */</span>    <span class="token keyword">protected</span> Handler nextHandler<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 处理请求的抽象方法.     *     * @param condition 条件     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * nextHandler的Setter方法.     *     * @param nextHandler 后继处理器     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNextHandler</span><span class="token punctuation">(</span>Handler nextHandler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nextHandler <span class="token operator">=</span> nextHandler<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其次，是若干个具体的处理角色类。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体处理角色1. * * Created by niww on 16/7/11. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandler1</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体处理角色1的处理方法.     *     * @param condition 条件     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果是自己的责任，就自己处理，负责传给下家处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"ConcreteHandler1"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色1的处理方法handled1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色1 通过..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            nextHandler<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体处理角色2. * * Created by niww on 16/7/11. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandler2</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体处理角色2的处理方法.     *     * @param condition 条件     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果是自己的责任，就自己处理，负责传给下家处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"ConcreteHandler2"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色2的处理方法handled1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色2 通过..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            nextHandler<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体处理角色n. * * Created by niww on 16/7/11. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandlerN</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 这里假设n是链的最后一个节点必须处理掉.     * 在实际情况下，可能出现环，或者是树形，这里并不一定是最后一个节点.     *     * @param condition 参数条件     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色n的处理方法 结束..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类，代码调用示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 责任连模式的客户端场景类. * * Created by niww on 16/7/11. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChainClient</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 主入口方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Handler handler1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandler1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Handler handler2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandler2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Handler handlern <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        handler1<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>handler2<span class="token punctuation">)</span><span class="token punctuation">;</span>        handler2<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>handlern<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//假设这个请求是ConcreteHandler2的责任</span>        handler1<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token string">"ConcreteHandler2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：责任链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般由使用该责任链的客户端创建。职责链模式降低了请求的发送者和请求处理者之间的耦合，从而使得多个请求处理者都有机会处理这个请求。</p></blockquote><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在实际软件开发中，如果遇到有多个对象可以处理同一请求时可以考虑使用职责链模式，最常见的例子包括在 Java Web 应用开发中创建一个过滤器（Filter）链来对请求数据进行过滤（中文字符乱码的处理）、在工作流系统中实现公文的分级审批、在Struts应用中添加不同的拦截器(常用的有类型转化、异常处理，数据校验…)以增强Struts2的功能等。</p><h3 id="纯与不纯的责任链模式"><a href="#纯与不纯的责任链模式" class="headerlink" title="纯与不纯的责任链模式"></a>纯与不纯的责任链模式</h3><ul><li><strong>纯的责任链模式</strong>要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，而是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又把责任向下传的情况；</li><li>在纯责任链模式里面，一个请求必须被某一个处理者对象所接收；</li><li>在不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。</li></ul><p>纯的责任链模式的实际例子很难找到，一般看到的例子均是不纯的责任链模式的实现。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>降低耦合度，使请求的发送者和接收者解耦，便于灵活的、可插拔的定义请求处理过程；</li><li>简化、封装了请求的处理过程，并且这个过程对客户端而言是透明的，以便于动态地重新组织链以及分配责任，增强请求处理的灵活性；</li><li>可以从职责链任何一个节点开始，也可以随时改变内部的请求处理规则，每个请求处理者都可以去动态地指定他的继任者；</li><li>职责链可简化对象间的相互连接。它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用；</li><li>增加新的请求处理类很方便。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>不能保证请求一定被接收。既然一个请求没有明确的接收者，那么就不能保证它一定会被处理；</li><li>该请求可能一直到链的末端都得不到处理。一个请求也可能因该链没有被正确配置而得不到处理；</li><li>系统性能将受到一定影响，而且在进行代码调试时不太方便；可能会造成循环调用。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。</li><li>职责链模式的主要优点在于可以降低系统的耦合度，简化对象的相互连接，同时增强给对象指派职责的灵活性，增加新的请求处理类也很方便；其主要缺点在于不能保证请求一定被接收，且对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之单例模式</title>
      <link href="/2018/10/29/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/29/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。</p><p>如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。</p><p>一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote><p><strong>单例模式(<code>Singleton Pattern</code>)</strong>：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种<strong>对象创建型模式</strong>。单例模式又名单件模式或单态模式。</p></blockquote><p>单例模式的要点有三个：</p><ul><li>一是某个类只能有一个实例；</li><li>二是它必须自行创建这个实例；</li><li>三是它必须自行向整个系统提供这个实例。</li></ul><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h3><ul><li><code>Singleton</code>: 单例</li></ul><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="http://static.blinkfox.com/Java_design_singleton_uml.jpg" alt="单例模式UML类图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="http://static.blinkfox.com/Java_design_singleton_seq.jpg" alt="单例模式时序图"></p><h2 id="代码实现方式"><a href="#代码实现方式" class="headerlink" title="代码实现方式"></a>代码实现方式</h2><h3 id="1-饿汉式（推荐使用）"><a href="#1-饿汉式（推荐使用）" class="headerlink" title="1. 饿汉式（推荐使用）"></a>1. 饿汉式（推荐使用）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 饿汉式单例模式. * * @author niww on 2017-10-23. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 全局唯一实例. */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：这种方式避免了多线程的同步问题，但不是懒加载。如果不需要懒加载的方式，推荐使用。</p></blockquote><h3 id="2-非线程安全懒汉式（不推荐使用）"><a href="#2-非线程安全懒汉式（不推荐使用）" class="headerlink" title="2. 非线程安全懒汉式（不推荐使用）"></a>2. 非线程安全懒汉式（不推荐使用）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 非线程安全的懒汉式. * * @author niww on 2017-10-23. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过懒加载的方式获取实例，但是非线程安全.     * @return Singleton实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：是懒加载的方式，但非线程安全。不推荐使用。</p></blockquote><h3 id="3-低效的线程安全懒汉式（不推荐使用）"><a href="#3-低效的线程安全懒汉式（不推荐使用）" class="headerlink" title="3. 低效的线程安全懒汉式（不推荐使用）"></a>3. 低效的线程安全懒汉式（不推荐使用）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 低效的线程安全的懒汉式. * * @author niww on 2017-10-23. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过 synchronized 关键字来保证线程安全，也是懒加载的方式来获取实例.     * @return Singleton实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：是懒加载的方式，也线程安全，但是效率很低。因为99%的情况下是不需要去同步的。不推荐使用。</p></blockquote><h3 id="4-双重校验锁线程安全懒汉式（不推荐使用）"><a href="#4-双重校验锁线程安全懒汉式（不推荐使用）" class="headerlink" title="4. 双重校验锁线程安全懒汉式（不推荐使用）"></a>4. 双重校验锁线程安全懒汉式（不推荐使用）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 双重校验锁线程安全懒汉式. * * @author niww on 2017-10-23. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过'双重校验锁'来更高效的保证线程安全，也是懒加载的方式来获取实例.     * @return Singleton实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：是懒加载的方式，也线程安全，效率也不错。但受限于Jdk5以前的Java内存模型，仍然会有bug，Java5及之后才能正常达到单例效果。</p></blockquote><h3 id="5-枚举式（强烈推荐使用）"><a href="#5-枚举式（强烈推荐使用）" class="headerlink" title="5. 枚举式（强烈推荐使用）"></a>5. 枚举式（强烈推荐使用）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 枚举方式的单例. * * @author niww on 2017-10-23. */</span><span class="token keyword">public</span> <span class="token keyword">enum</span> Singleton <span class="token punctuation">{</span>    INSTANCE<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：在<code>《Effective Java》</code>一书中强烈推荐使用枚举来实现单例模式，该方式简单可自由序列化；保证只有一个实例（即使使用反射机制也无法多次实例化一个枚举量）；线程安全。唯一的缺点是非懒加载方式。</p></blockquote><h3 id="6-静态内部类（推荐使用）"><a href="#6-静态内部类（推荐使用）" class="headerlink" title="6. 静态内部类（推荐使用）"></a>6. 静态内部类（推荐使用）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 通过使用静态内部类的方式来实现懒加载且线程安全的创建单例. * * @author niww on 2017-10-23. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 静态内部类.     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token function">SingletonHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton4 instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过懒加载的方式获取Singleton唯一实例的方法.     * @return Singleton实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SingletonHolder<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：这种方式利用了<code>ClassLoader</code>的机制保证初始化<code>instance</code>时只有一个线程，其只有显示通过调用<code>getInstance</code>方法时，才会显示装载<code>SingletonHolder</code>类，从而实例化<code>instance</code>。</p></blockquote><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类——<code>Singleton</code>。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。</li><li>允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li><li>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如<code>Java</code>、<code>C#</code>)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用单例模式：</p><ul><li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</li><li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</li><li>在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。</li><li>单例模式只包含一个单例角色：在单例类的内部实现只生成一个实例，同时它提供一个静态的工厂方法，让客户可以使用它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有。</li><li>实现单例模式，如果不需要懒加载的效果，则推荐使用枚举和饿汉式的方式；如果需要懒加载的效果，则推荐使用静态内部类来实现更好。</li><li>单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。</li><li>单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML各类关系介绍</title>
      <link href="/2018/10/22/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/UML%E5%90%84%E7%B1%BB%E5%85%B3%E7%B3%BB%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/10/22/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/UML%E5%90%84%E7%B1%BB%E5%85%B3%E7%B3%BB%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="继承关系（generalization）"><a href="#继承关系（generalization）" class="headerlink" title="继承关系（generalization）"></a>继承关系（generalization）</h2><p><strong>继承</strong>关系用一条带<strong>空心箭头的直线</strong>表示。如下图所示（A继承自B）：</p><p><img src="http://static.blinkfox.com/uml_demo_1.png" alt="A继承自B"></p><p><strong>继承</strong>指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。<strong>继承关系为<code>is-a</code>的关系</strong>，是类与类或者接口与接口之间最常见的关系之一，在Java中此类关系通过关键字<code>extends</code>来表示。</p><blockquote><p><strong>注意</strong>：表现在代码中，继承关系表现为<strong>一个类继承另一个类或者一个接口继承另一个接口</strong>。</p></blockquote><h2 id="实现关系（realization）"><a href="#实现关系（realization）" class="headerlink" title="实现关系（realization）"></a>实现关系（realization）</h2><p><strong>实现</strong>关系是用一条带<strong>空心箭头的虚线</strong>表示。如下图所示（A实现B）：：</p><p><img src="http://static.blinkfox.com/uml_demo_2.png" alt="A实现B"></p><p><strong>实现</strong>指的是一个<code>class</code>类实现<code>interface</code>接口（可以是多个）的功能。实现是类与接口之间最常见的关系之一，在Java中此类关系通过关键字<code>implements</code>来表示。</p><blockquote><p><strong>注意</strong>：表现在代码中，实现关系表现为<strong>普通类实现某个接口</strong>。</p></blockquote><h2 id="关联关系（association）"><a href="#关联关系（association）" class="headerlink" title="关联关系（association）"></a>关联关系（association）</h2><p><strong>关联</strong>关系是用一条<strong>可能会有方向的直线</strong>表示的。关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如上图，表示A关联B，但B不关联A；如下图所示：</p><p><img src="http://static.blinkfox.com/uml_demo_3.png" alt="A关联B"></p><p><strong>关联</strong>关系体现的是两个类、或者类与接口之间语义级别的一种强依赖的结构关系，是一种长期的静态稳定的关系，通常与运行状态无关，一般由常识等因素决定的。</p><p>例如：乘车人和车票之间就是一种关联关系。</p><blockquote><p><strong>注意</strong>：表现在代码中，<strong>被关联类以类属性的形式出现在关联类中，也可能是关联类引用了一个类型为被关联类的全局变量</strong>。</p></blockquote><h2 id="聚合关系（aggregation）"><a href="#聚合关系（aggregation）" class="headerlink" title="聚合关系（aggregation）"></a>聚合关系（aggregation）</h2><p><strong>聚合</strong>关系用一条带<strong>空心菱形箭头的直线</strong>表示，如下图所示A聚合到B，或者说B由A组成。</p><p><img src="http://static.blinkfox.com/uml_demo_4.png" alt="A聚合到B"></p><p><strong>聚合</strong>关系用于表示实体对象之间的关系，表示整体由部分构成的意思。<strong>聚合是关联关系的一种特例，它体现的是整体与部分、拥有的关系，即<code>has-a</code>的关系</strong>，此时整体与部分之间是<strong>可分离</strong>的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。例如一个部门由多个员工组成。</p><blockquote><p><strong>注意</strong>：表现在代码中，和关联关系是一致的，只能从语义级别来区分。聚合与组合不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如，部门撤销了，人员不会消失，他们依然存在。</p></blockquote><h2 id="组合关系（composition）"><a href="#组合关系（composition）" class="headerlink" title="组合关系（composition）"></a>组合关系（composition）</h2><p><strong>组合</strong>关系用一条带<strong>实心菱形箭头的直线</strong>表示，如下图表示A组成B，或者B由A组成。</p><p><img src="http://static.blinkfox.com/uml_demo_5.png" alt="A组合到B"></p><p><strong>组合</strong>关系同样表示整体由部分组成的意思。与聚合关系一样，<strong>组合也是关联关系的一种特例，它体现的是一种整体与部分不可分割的关系，即<code>contains-a</code>的关系，这种关系比聚合更强，也称为强聚合</strong>。例如公司由多个部门组成组合，但此时整体与部分是<strong>不可分离</strong>的，整体的生命周期结束也就意味着部分的生命周期结束。</p><blockquote><p><strong>注意</strong>：表现在代码中，和关联关系是一致的，只能从语义级别来区分。组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也就不存在了。例如，公司不存在了，部门也将不存在了。</p></blockquote><h2 id="依赖关系（dependency）"><a href="#依赖关系（dependency）" class="headerlink" title="依赖关系（dependency）"></a>依赖关系（dependency）</h2><p><strong>依赖</strong>关系是用一套<strong>带箭头的虚线</strong>表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系。</p><p><img src="http://static.blinkfox.com/uml_demo_6.png" alt="A依赖于B"></p><p><strong>依赖</strong>关系是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是B类的变化会影响到A，与关联关系不同的是，它是一种<strong>临时性</strong>的关系，通常在运行期间产生，并且随着运行时的变化依赖关系也可能发生变化。</p><p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生。</p><blockquote><p><strong>注意</strong>：表现在代码中，依赖关系体现为<strong>类的构造方法及类方法的传入参数</strong>。</p></blockquote><h2 id="UML类关系图示例"><a href="#UML类关系图示例" class="headerlink" title="UML类关系图示例"></a>UML类关系图示例</h2><p>请看以下这个UML类关系图：</p><p><img src="http://static.blinkfox.com/uml_demo_0.png" alt="UML示例"></p><ul><li>开车的类图结构表示的是一个接口</li><li>有一个自行车的抽象类，实现了开车的接口，它们之间的关系为实现关系，使用带空心三角箭头的虚线表示</li><li>自行车与摩拜单车之间是继承关系，使用带空心三角箭头的实线表示</li><li>学生上学需要用到摩拜单车，与摩拜单车是一种依赖关系，使用带箭头的虚线表示</li><li>学生与身份证之间为关联关系，使用一根实线表示，如果两个类之间互相通过属性引用，则是双向关联关系</li><li>学生与班级、学生与学校之间是聚合关系，使用带空心菱形箭头的实线表示</li><li>学校与班级是组合关系，使用带实心菱形箭头的实线表示</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象编程 </tag>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之建造者模式</title>
      <link href="/2018/10/20/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/20/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发动机等各种部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，可以通过建造者模式对其进行设计与描述，建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</p><p>在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。</p><p>复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p>造者模式(<code>Builder Pattern</code>)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式属于<strong>对象创建型模式</strong>。建造者模式又可以称为<strong>生成器模式</strong>。</p></blockquote><p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>建造者模式包含如下角色：</p><ul><li><code>Builder</code>：抽象建造者</li><li><code>ConcreteBuilder</code>：具体建造者</li><li><code>Director</code>：导演者</li><li><code>Product</code>：产品角色</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://static.blinkfox.com/Builder.jpg" alt="建造者模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是产品类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 产品类. * * Created by niww on 2016/10/8. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String part1<span class="token punctuation">;</span>    <span class="token keyword">private</span> String part2<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* getter 和 setter方法. */</span>    <span class="token keyword">public</span> String <span class="token function">getPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> part1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPart1</span><span class="token punctuation">(</span>String part1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>part1 <span class="token operator">=</span> part1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> part2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPart2</span><span class="token punctuation">(</span>String part2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>part2 <span class="token operator">=</span> part2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其实，是抽象的建造者<code>Builder</code>接口和具体的建造者<code>ConcreteBuilder</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象的建造者. * * Created by niww on 2016/10/8. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 产品建造部分1.     */</span>    <span class="token keyword">void</span> <span class="token function">buildPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 产品建造部分2.     */</span>    <span class="token keyword">void</span> <span class="token function">buildPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 得到建造的产品.     *     * @return 产品     */</span>    Product <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的建造者实现类. * * Created by niww on 2016/10/8. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteBuilder</span> <span class="token keyword">implements</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 产品. */</span>    <span class="token keyword">private</span> Product product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 产品建造部分1.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setPart1</span><span class="token punctuation">(</span><span class="token string">"编号：95757"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 产品建造部分2.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setPart2</span><span class="token punctuation">(</span><span class="token string">"名称：小机器人"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 得到建造的产品.     *     * @return 产品     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，导演者<code>Director</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 导演者类. * * Created by niww on 2016/10/8. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Director</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 当前需要的建造者对象. */</span>    <span class="token keyword">private</span> Builder builder<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造方法.     *     * @param builder     */</span>    <span class="token keyword">public</span> <span class="token function">Director</span><span class="token punctuation">(</span>Builder builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>builder <span class="token operator">=</span> builder<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 产品构造方法，负责调用各个零件建造方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        builder<span class="token punctuation">.</span><span class="token function">buildPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">buildPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以下是建造者模式的客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 建造者模式的客户端场景类. * * Created by niww on 2016/10/8. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BuilderClient</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 主入口方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Builder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Director director <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Director</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>        director<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>product<span class="token punctuation">.</span><span class="token function">getPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>product<span class="token punctuation">.</span><span class="token function">getPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><p>抽象建造者类中定义了产品的创建方法和返回方法;</p><p>建造者模式的结构中还引入了一个导演者类<code>Director</code>，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。导演者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过导演者类调用建造者的相关方法，返回一个完整的产品对象</p><p>在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>建造者模式的优点：</p><ul><li>在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>建造者模式的缺点：</p><ul><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用建造者模式：</p><ul><li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li><li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li><li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li></ul><h3 id="4-建造者模式与抽象工厂模式的比较"><a href="#4-建造者模式与抽象工厂模式的比较" class="headerlink" title="4. 建造者模式与抽象工厂模式的比较"></a>4. 建造者模式与抽象工厂模式的比较</h3><ul><li>与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。</li><li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。</li><li>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</li></ul><h2 id="六、模式总结"><a href="#六、模式总结" class="headerlink" title="六、模式总结"></a>六、模式总结</h2><ul><li>建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。</li><li>建造者模式包含如下四个角色：抽象建造者为创建一个产品对象的各个部件指定抽象接口；具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象；产品角色是被构建的复杂对象，包含多个组成部件；指挥者负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其<code>construct()</code>建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造</li><li>在建造者模式的结构中引入了一个导演者类，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</li><li>建造者模式的主要优点在于客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，符合“开闭原则”，还可以更加精细地控制产品的创建过程；其主要缺点在于由于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，因此其使用范围受到一定的限制，如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li><li>建造者模式适用情况包括：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；需要生成的产品对象的属性相互依赖，需要指定其生成顺序；对象的创建过程独立于创建该对象的类；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之外观模式</title>
      <link href="/2018/10/18/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/18/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式定义"><a href="#一、模式定义" class="headerlink" title="一、模式定义"></a>一、模式定义</h2><blockquote><p><strong>外观模式</strong>(<code>Facade Pattern</code>)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为<strong>门面模式</strong>，它是一种对象结构型模式。</p></blockquote><h2 id="二、模式结构"><a href="#二、模式结构" class="headerlink" title="二、模式结构"></a>二、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>外观模式包含如下角色：</p><ul><li><code>Facade</code>: 外观角色</li><li><code>SubSystem</code>: 子系统角色</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://static.blinkfox.com/Facade.jpg" alt="命令模式结构图"></p><h2 id="三、示例代码"><a href="#三、示例代码" class="headerlink" title="三、示例代码"></a>三、示例代码</h2><p>首先，是各个子系统角色类，分别如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 子系统类A. * * Created by niww on 16/8/25. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassA</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----业务方法A..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 子系统类B. * * Created by niww on 16/8/25. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassB</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----业务方法B..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 子系统类C. * * Created by niww on 16/8/25. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassC</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----业务方法C..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以下是外观模式的外观类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 外观门面类. * * Created by niww on 16/8/25. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Facade</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> ClassA a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> ClassB b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> ClassC c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 以下是提供给外部访问的方法.</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">.</span><span class="token function">doSomethingA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>b<span class="token punctuation">.</span><span class="token function">doSomethingB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>c<span class="token punctuation">.</span><span class="token function">doSomethingC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="四、模式分析"><a href="#四、模式分析" class="headerlink" title="四、模式分析"></a>四、模式分析</h2><p>根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。 外观模式也是“<strong>迪米特法则</strong>”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。</p><ul><li>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</li><li>外观模式的目的在于降低系统的复杂程度。</li><li>外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>外观模式的优点k：</p><ul><li>对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。</li><li>实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。</li><li>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li><li>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>外观模式的缺点：</p><ul><li>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</li><li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“<strong>开闭原则</strong>”。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用外观模式：</p><ul><li>当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。</li><li>客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。</li><li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li></ul><h2 id="五、模式总结"><a href="#五、模式总结" class="headerlink" title="五、模式总结"></a>五、模式总结</h2><ul><li>在外观模式中，外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</li><li>外观模式包含两个角色：外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理；在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。</li><li>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</li><li>外观模式主要优点在于对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易，它实现了子系统与客户之间的松耦合关系，并降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程；其缺点在于不能很好地限制客户使用子系统类，而且在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li><li>外观模式适用情况包括：要为一个复杂子系统提供一个简单接口；客户程序与多个子系统之间存在很大的依赖性；在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之中介者模式</title>
      <link href="/2018/10/17/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/17/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在用户与用户直接聊天的设计方案中，用户对象之间存在很强的关联性，将导致系统出现如下问题：</p><ul><li>系统结构复杂：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。</li><li>对象可重用性差：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。</li><li>系统扩展性低：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。</li><li>在面向对象的软件设计与开发过程中，根据“单一职责原则”，我们应该尽量将对象细化，使其只负责或呈现单一的职责。</li><li>对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式，这就是中介者模式的模式动机。</li></ul><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>中介者模式(<code>Mediator Pattern</code>)</strong>：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为<strong>调停者模式</strong>，它是一种对象行为型模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>中介者模式包含如下角色：</p><ul><li><code>Mediator</code>: 抽象中介者</li><li><code>ConcreteMediator</code>: 具体中介者</li><li><code>Colleague</code>: 抽象同事类</li><li><code>ConcreteColleague</code>: 具体同事类</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://static.blinkfox.com/Mediator.jpg" alt="命令模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的<code>Mediator</code>类和具体的<code>ConcreteMediator</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 通用抽象中介者类. * * Created by niww on 16/8/21. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Mediator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 定义同事类1. */</span>    <span class="token keyword">protected</span> ConcreteColleague1 colleague1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 定义同事类2. */</span>    <span class="token keyword">protected</span> ConcreteColleague2 colleague2<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* getter 和 setter 方法 */</span>    <span class="token keyword">public</span> ConcreteColleague1 <span class="token function">getColleague1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> colleague1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setColleague1</span><span class="token punctuation">(</span>ConcreteColleague1 colleague1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>colleague1 <span class="token operator">=</span> colleague1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ConcreteColleague2 <span class="token function">getColleague2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> colleague2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setColleague2</span><span class="token punctuation">(</span>ConcreteColleague2 colleague2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>colleague2 <span class="token operator">=</span> colleague2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 中介者模式的抽象业务逻辑1.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doSomething1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 中介者模式的抽象业务逻辑2.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doSomething2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的通用中介者类. * * Created by niww on 16/8/21. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteMediator</span> <span class="token keyword">extends</span> <span class="token class-name">Mediator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 中介者模式的具体业务逻辑1.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>colleague1<span class="token punctuation">.</span><span class="token function">selfMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>colleague2<span class="token punctuation">.</span><span class="token function">selfMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 中介者模式的具体业务逻辑2.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>colleague1<span class="token punctuation">.</span><span class="token function">selfMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>colleague2<span class="token punctuation">.</span><span class="token function">selfMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其实，是抽象的<code>Colleague</code>类和具体的<code>ConcreteColleague</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象的同事类. * * Created by niww on 16/8/21. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 中介者. */</span>    <span class="token keyword">protected</span> Mediator mediator<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Colleague</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mediator <span class="token operator">=</span> mediator<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的同事类1. * * Created by niww on 16/8/21. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteColleague1</span> <span class="token keyword">extends</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteColleague1</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自有方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">selfMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------ConcreteColleague1-处理自己的业务逻辑1--------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 依赖方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">depMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------ConcreteColleague1-委托给中介者的业务逻辑1--------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>mediator<span class="token punctuation">.</span><span class="token function">doSomething1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的同事类2. * * Created by niww on 16/8/21. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteColleague2</span> <span class="token keyword">extends</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteColleague2</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自有方法2.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">selfMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------ConcreteColleague2-处理自己的业务逻辑2--------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 依赖方法2.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">depMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------ConcreteColleague2-委托给中介者的业务逻辑2--------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>mediator<span class="token punctuation">.</span><span class="token function">doSomething2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以下是中介者模式的客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 中介者模式的场景类 * Created by niww on 16/8/21. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MediatorClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Mediator mediator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteMediator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ConcreteColleague1 colleague1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteColleague1</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>        ConcreteColleague2 colleague2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteColleague2</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">setColleague1</span><span class="token punctuation">(</span>colleague1<span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">setColleague2</span><span class="token punctuation">(</span>colleague2<span class="token punctuation">)</span><span class="token punctuation">;</span>        colleague1<span class="token punctuation">.</span><span class="token function">depMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        colleague2<span class="token punctuation">.</span><span class="token function">depMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">doSomething1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">doSomething2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><p>中介者模式可以使对象之间的关系数量急剧减少。</p><p>中介者承担两方面的职责：</p><ul><li><strong>中转作用（结构性）</strong>：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者在结构上的支持。</li><li><strong>协调作用（行为性）</strong>：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>中介者模式的优点：</p><ul><li>简化了对象之间的交互。</li><li>将各同事解耦。</li><li>减少子类生成。</li><li>可以简化各同事类的设计和实现。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>中介者模式的缺点：</p><ul><li>在具体中介者类中包含了同事之间的交互细节，<strong>可能会导致具体中介者类非常复杂，使得系统难以维护</strong>。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用中介者模式：</p><ul><li>系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。</li><li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。</li><li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象。</li><li>交互的公共行为，如果需要改变行为则可以增加新的中介者类。</li></ul><h2 id="六、模式总结"><a href="#六、模式总结" class="headerlink" title="六、模式总结"></a>六、模式总结</h2><ul><li>中介者模式用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</li><li>中介者模式包含四个角色：抽象中介者用于定义一个接口，该接口用于与各同事对象之间的通信；具体中介者是抽象中介者的子类，通过协调各个同事对象来实现协作行为，了解并维护它的各个同事对象的引用；抽象同事类定义各同事的公有方法；具体同事类是抽象同事类的子类，每一个同事对象都引用一个中介者对象；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中定义的方法。</li><li>通过引入中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构，中介者承担了中转作用和协调作用。中介者类是中介者模式的核心，它对整个系统进行控制和协调，简化了对象之间的交互，还可以对对象间的交互进行进一步的控制。</li><li>中介者模式的主要优点在于简化了对象之间的交互，将各同事解耦，还可以减少子类生成，对于复杂的对象之间的交互，通过引入中介者，可以简化各同事类的设计和实现；中介者模式主要缺点在于具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</li><li>中介者模式适用情况包括：系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解；一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象；想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之命令模式</title>
      <link href="/2018/10/16/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/16/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。</p><p>命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>命令模式(<code>Command Pattern</code>)</strong>：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(<code>Action</code>)模式或事务(<code>Transaction</code>)模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>命令模式包含如下角色：</p><ul><li><code>Command</code>: 抽象命令类</li><li><code>ConcreteCommand</code>: 具体命令类</li><li><code>Invoker</code>: 调用者</li><li><code>Receiver</code>: 接收者</li><li><code>Client</code>: 客户类</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://static.blinkfox.com/Command.jpg" alt="命令模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的<code>Receiver</code>类和具体的<code>Receiver</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 通用的抽象 Receiver 接收者. * * Created by niww on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Receiver</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 定义每个接收者都必须完成的业务.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的 Receiver 类1. * * Created by niww on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteReceiver1</span> <span class="token keyword">extends</span> <span class="token class-name">Receiver</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteReceiver1 处理的业务逻辑..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的 Receiver 类2. * * Created by niww on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteReceiver2</span> <span class="token keyword">extends</span> <span class="token class-name">Receiver</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteReceiver2 处理的业务逻辑..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其实，是抽象的<code>Command</code>类和具体的<code>Command</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象的 Command 类. * * Created by niww on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 命令的抽象执行命令的方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的 Command 命令类1. * * Created by niww on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteCommand1</span> <span class="token keyword">extends</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 对哪个receiver类进行处理. */</span>    <span class="token keyword">private</span> Receiver receiver<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ConcreteCommand1</span><span class="token punctuation">(</span>Receiver receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver <span class="token operator">=</span> receiver<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 必须实现的一个命令.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的 Command 命令类2. * * Created by niww on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteCommand2</span> <span class="token keyword">extends</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 对哪个receiver类进行处理. */</span>    <span class="token keyword">private</span> Receiver receiver<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ConcreteCommand2</span><span class="token punctuation">(</span>Receiver receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver <span class="token operator">=</span> receiver<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 必须实现的命令.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，调用者<code>Invoker</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 调用者 Invoker 类. * * Created by niww on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Invoker</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Command command<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCommand</span><span class="token punctuation">(</span>Command command<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>command <span class="token operator">=</span> command<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 执行命令.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>command<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以下是命令模式的客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 命令模式的场景类. * * Created by niww on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommandClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Invoker invoker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Invoker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Receiver receiver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteReceiver1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Command command <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteCommand1</span><span class="token punctuation">(</span>receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 把命令交给调用者执行</span>        invoker<span class="token punctuation">.</span><span class="token function">setCommand</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        invoker<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><p><strong>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开</strong>。</p><ul><li>每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。</li><li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li><li>命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li><li>命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>命令模式的优点：</p><ul><li>降低系统的耦合度。</li><li>新的命令可以很容易地加入到系统中。</li><li>可以比较容易地设计一个命令队列和宏命令（组合命令）。</li><li>可以方便地实现对请求的<code>Undo</code>和<code>Redo</code>。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>命令模式的缺点：</p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用命令模式：</p><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li><li>系统需要将一组操作组合在一起，即支持宏命令</li></ul><h2 id="六、模式总结"><a href="#六、模式总结" class="headerlink" title="六、模式总结"></a>六、模式总结</h2><ul><li>在命令模式中，将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作模式或事务模式。</li><li>命令模式包含四个角色：抽象命令类中声明了用于执行请求的<code>execute()</code>等方法，通过这些方法可以调用请求接收者的相关操作；具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中；调用者即请求的发送者，又称为请求者，它通过命令对象来执行请求；接收者执行与请求相关的操作，它具体实现对请求的业务处理。</li><li>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li><li>命令模式的主要优点在于降低系统的耦合度，增加新的命令很方便，而且可以比较容易地设计一个命令队列和宏命令，并方便地实现对请求的撤销和恢复；其主要缺点在于可能会导致某些系统有过多的具体命令类。</li><li>命令模式适用情况包括：需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互；需要在不同的时间指定请求、将请求排队和执行请求；需要支持命令的撤销操作和恢复操作，需要将一组操作组合在一起，即支持宏命令。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之观察者模式</title>
      <link href="/2018/10/14/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/14/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p>观察者模式(<code>Observer Pattern</code>)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（<code>Publish</code>/<code>Subscribe</code>）模式、模型-视图（<code>Model</code>/<code>View</code>）模式、源-监听器（<code>Source</code>/<code>Listener</code>）模式或从属者（<code>Dependents</code>）模式。</p></blockquote><p>观察者模式是一种<strong>对象行为型模式</strong>。</p><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成："><a href="#1-角色组成：" class="headerlink" title="1. 角色组成："></a>1. 角色组成：</h3><p>观察者模式包含如下角色：</p><ul><li><code>Subject</code>: 目标（抽象的被观察着）</li><li><code>ConcreteSubject</code>: 具体目标（具体的被观察者）</li><li><code>Observer</code>: 观察者</li><li><code>ConcreteObserver</code>: 具体观察者</li></ul><h3 id="2-结构图："><a href="#2-结构图：" class="headerlink" title="2. 结构图："></a>2. 结构图：</h3><p><img src="http://static.blinkfox.com/Obeserver.jpg" alt="观察者模式结构图"></p><h3 id="3-时序图："><a href="#3-时序图：" class="headerlink" title="3. 时序图："></a>3. 时序图：</h3><p><img src="http://static.blinkfox.com/seq_Obeserver.jpg" alt="观察者模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是观察者接口：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 观察者接口 * Created by niww on 16/7/14. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 更新的方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>接下来，是具体的观察者类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的观察者. * * Created by niww on 16/7/15. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteObserver</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 实现更新方法.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收到信息,并进行处理..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是被观察者的抽象类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 被观察者的抽象类. * * Created by niww on 16/7/14. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 定义一个观察者的集合. */</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Observer<span class="token operator">></span> observers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Observer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 增加一个观察者.     *     * @param o     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addObserver</span><span class="token punctuation">(</span>Observer o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 删除一个观察者.     *     * @param o     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delObserver</span><span class="token punctuation">(</span>Observer o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通知所有观察者.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Observer o<span class="token operator">:</span> observers<span class="token punctuation">)</span> <span class="token punctuation">{</span>            o<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>具体的被观察者：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的被观察者. * * Created by niww on 16/7/15. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteSubject</span> <span class="token keyword">extends</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体的业务.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是用于测试观察者模式的客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 观察者模式客户端场景类. * * Created by niww on 16/7/15. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObserverClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建一个被观察者和观察者.</span>        ConcreteSubject sub <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Observer obs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 观察者观察被观察者.</span>        sub<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span>obs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 观察者开始活动了.</span>        sub<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><ul><li>观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。</li><li>这一模式中的关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知。</li><li>作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为<strong>发布-订阅</strong>(<code>publish-subscribe</code>)。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>观察者模式的优点：</p><ul><li>观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li><li>观察者模式在观察目标和观察者之间建立一个抽象的耦合。</li><li>观察者模式支持广播通信。</li><li>观察者模式符合“开闭原则”的要求。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>观察者模式的缺点：</p><ul><li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3.适用环境"></a>3.适用环境</h3><p>在以下情况下可以使用观察者模式：</p><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ul><blockquote><p>观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。</p></blockquote><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>观察者模式定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅模式、模型-视图模式、源-监听器模式或从属者模式。观察者模式是一种对象行为型模式。</li><li>观察者模式包含四个角色：目标又称为主题，它是指被观察的对象；具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；观察者将对观察目标的改变做出反应；在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。</li><li>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。</li><li>观察者模式的主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信；其主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式适用情况包括：一个抽象模型有两个方面，其中一个方面依赖于另一个方面；一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变；一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。</li><li>在JDK的<code>java.util</code>包中，提供了<code>Observable</code>类以及<code>Observer</code>接口，它们构成了Java语言对观察者模式的支持。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用Bash命令整理之其他常用命令</title>
      <link href="/2018/10/13/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Linux/%E5%B8%B8%E7%94%A8Bash%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%E4%B9%8B%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/10/13/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Linux/%E5%B8%B8%E7%94%A8Bash%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%E4%B9%8B%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="1-hostname-查看主机名"><a href="#1-hostname-查看主机名" class="headerlink" title="1. hostname - 查看主机名"></a>1. hostname - 查看主机名</h2><p><code>hostname</code>命令用于查看系统的主机名，或是修改系统的主机名。</p><p><code>hostname</code>的常用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 显示系统的当前主机名</span><span class="token function">hostname</span><span class="token comment" spellcheck="true"># 修改你系统的主机名</span><span class="token function">hostname</span> niww-system<span class="token comment" spellcheck="true"># 使用 -F 选项，从指定的文件中读取主机名</span><span class="token function">hostname</span> -F /root/hostname.txt</code></pre><h2 id="2-uptime-查看系统运行时间"><a href="#2-uptime-查看系统运行时间" class="headerlink" title="2. uptime - 查看系统运行时间"></a>2. uptime - 查看系统运行时间</h2><p><code>uptime</code>命令用于打印系统的运行时间等信息。使用如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">uptime</span></code></pre><h2 id="3-w、who-列出登录的用户"><a href="#3-w、who-列出登录的用户" class="headerlink" title="3. w、who - 列出登录的用户"></a>3. w、who - 列出登录的用户</h2><p><code>w</code>命令用于显示登录用户及他们当前运行的进程。输入的内容格式如下：</p><pre class=" language-bash"><code class="language-bash">w<span class="token comment" spellcheck="true"># 打印如下</span>22:42  up 18 days, 1 hr, 2 users, load averages: 1.23 1.79 1.75USER     TTY      FROM              LOGIN@  IDLE WHATniww console  -                日19   6days -niww s000     -                五23       - w</code></pre><p><code>who</code>命令有与<code>w</code>命令类似的用途，但它的功能比<code>w</code>命令更强大一些。语法格式如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">who</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>FILE <span class="token operator">|</span> ARG1 ARG2<span class="token punctuation">]</span></code></pre><p><code>who</code>常用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 显示当前登录的所有用户信息</span><span class="token function">who</span><span class="token comment" spellcheck="true"># 显示系统的启动时间</span><span class="token function">who</span> -b<span class="token comment" spellcheck="true"># 显示系统登录进程</span><span class="token function">who</span> -l<span class="token comment" spellcheck="true"># 显示与当前标准输入关联的用户信息</span><span class="token function">who</span> -m<span class="token comment" spellcheck="true"># 显示系统的运行级别</span><span class="token function">who</span> -r<span class="token comment" spellcheck="true"># 显示所有登录用户的用户名和登录用户数</span><span class="token function">who</span> -q</code></pre><h2 id="4-uname-查看系统信息"><a href="#4-uname-查看系统信息" class="headerlink" title="4. uname - 查看系统信息"></a>4. uname - 查看系统信息</h2><p><code>uname</code>命令用于打印内核名称和版本、主机名等系统信息。命令的语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">uname</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>.</code></pre><p>常用使用方式如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 只打印内核的名称</span><span class="token function">uname</span><span class="token comment" spellcheck="true"># 使用 -n 选项，只打印系统的主机名</span><span class="token function">uname</span> -n<span class="token comment" spellcheck="true"># 使用 -r 选项，打印内核版本信息</span><span class="token function">uname</span> -r<span class="token comment" spellcheck="true"># 使用 -m 选项，打印系统的硬件名称</span><span class="token function">uname</span> -m<span class="token comment" spellcheck="true"># 使用 -p 选项，打印系统的处理器类型信息</span><span class="token function">uname</span> -p<span class="token comment" spellcheck="true"># 使用 -i 选项，打印系统的硬件平台信息</span><span class="token function">uname</span> -i<span class="token comment" spellcheck="true"># 使用 -a 选项，打印上述所有示例中的信息</span><span class="token function">uname</span> -a</code></pre><h2 id="5-date-显示和设置系统日期和时间"><a href="#5-date-显示和设置系统日期和时间" class="headerlink" title="5. date - 显示和设置系统日期和时间"></a>5. date - 显示和设置系统日期和时间</h2><p><code>date</code>命令用于以多种格式显示日期和时间，或设置系统的日期和时间。<code>date</code>命令的语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">date</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>+FORMAT<span class="token punctuation">]</span><span class="token function">date</span> <span class="token punctuation">[</span>-u<span class="token operator">|</span>--utc<span class="token operator">|</span>--universal<span class="token punctuation">]</span> <span class="token punctuation">[</span>MMDDhhmm<span class="token punctuation">[</span><span class="token punctuation">[</span>CC<span class="token punctuation">]</span>YY<span class="token punctuation">]</span><span class="token punctuation">[</span>.ss<span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><p>常用使用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 以默认格式显示系统的当前日期时间</span><span class="token function">date</span><span class="token comment" spellcheck="true"># 格式化当前日期</span><span class="token function">date</span> +<span class="token string">"%Y-%m-%d"</span><span class="token comment" spellcheck="true"># 格式化输出昨天的日期</span><span class="token function">date</span> -d <span class="token string">"1 day ago"</span> +<span class="token string">"%Y-%m-%d"</span><span class="token comment" spellcheck="true"># 2秒后格式化输出</span><span class="token function">date</span> -d <span class="token string">"2 second"</span> +<span class="token string">"%Y-%m-%d %H:%M.%S"</span><span class="token comment" spellcheck="true"># 普通格式化转出</span><span class="token function">date</span> -d <span class="token string">"2009-12-12"</span> +<span class="token string">"%Y/%m/%d %H:%M.%S"</span><span class="token comment" spellcheck="true"># apache格式转换</span><span class="token function">date</span> -d <span class="token string">"Dec 5, 2009 12:00:37 AM"</span> +<span class="token string">"%Y-%m-%d %H:%M.%S"</span><span class="token comment" spellcheck="true"># 日期加减操作</span><span class="token function">date</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示前天年月日</span><span class="token function">date</span> -d <span class="token string">"+1 day"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示前一天的日期</span><span class="token function">date</span> -d <span class="token string">"-1 day"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示后一天的日期</span><span class="token function">date</span> -d <span class="token string">"-1 month"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示上一月的日期</span><span class="token function">date</span> -d <span class="token string">"+1 month"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示下一月的日期</span><span class="token function">date</span> -d <span class="token string">"-1 year"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示前一年的日期</span><span class="token function">date</span> -d <span class="token string">"+1 year"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示下一年的日期</span><span class="token comment" spellcheck="true"># 设定时间</span><span class="token function">date</span> -s <span class="token comment" spellcheck="true"># 设置当前时间，只有root权限才能设置，其他只能查看</span><span class="token function">date</span> -s 20160816 <span class="token comment" spellcheck="true"># 设置成20160816，这样会把具体时间设置成空00:00:00</span><span class="token function">date</span> -s 01:01:01 <span class="token comment" spellcheck="true"># 设置具体时间，不会对日期做更改</span><span class="token function">date</span> -s <span class="token string">"01:01:01 2012-05-23"</span> <span class="token comment" spellcheck="true"># 这样可以设置全部时间 </span><span class="token function">date</span> -s <span class="token string">"01:01:01 20120523"</span> <span class="token comment" spellcheck="true"># 这样可以设置全部时间</span><span class="token function">date</span> -s <span class="token string">"2012-05-23 01:01:01"</span> <span class="token comment" spellcheck="true"># 这样可以设置全部时间 </span><span class="token function">date</span> -s <span class="token string">"20120523 01:01:01"</span> <span class="token comment" spellcheck="true"># 这样可以设置全部时间</span></code></pre><h2 id="6-id-显示用户属性"><a href="#6-id-显示用户属性" class="headerlink" title="6. id - 显示用户属性"></a>6. id - 显示用户属性</h2><p><code>id</code>命令用于打印输出用户<code>uid</code>、<code>gid</code>、用户名和组名等用户身份信息。<code>id</code>命令的语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">id</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>USERNAME<span class="token punctuation">]</span></code></pre><p>常见使用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 输出当前用户的uid、用户名、gid、组名及用户属于的群组信息</span><span class="token function">id</span><span class="token comment" spellcheck="true"># 使用 -u 选项，输出用户的 uid</span><span class="token function">id</span> -u<span class="token comment" spellcheck="true">#-u 选项和 -n 选项结合使用，输出账户的用户名</span><span class="token function">id</span> -un<span class="token comment" spellcheck="true"># 使用 -g 选项，输出帐号当前起作用的gid</span><span class="token function">id</span> -g<span class="token comment" spellcheck="true"># -g 与 -n 选项结合使用，输出帐号当前起作用的用户组名</span><span class="token function">id</span> -gn<span class="token comment" spellcheck="true"># 使用 -G 选项，输出帐号所属的所有群组id</span><span class="token function">id</span> -G root<span class="token comment" spellcheck="true"># -G 与 -n 选项结合使用，输出账号所属的所有群组的名称</span><span class="token function">id</span> -Gn root</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用Bash命令整理之文本处理</title>
      <link href="/2018/10/11/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Linux/%E5%B8%B8%E7%94%A8Bash%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%E4%B9%8B%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"/>
      <url>/2018/10/11/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Linux/%E5%B8%B8%E7%94%A8Bash%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%E4%B9%8B%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-sort-文本排序"><a href="#1-sort-文本排序" class="headerlink" title="1. sort - 文本排序"></a>1. sort - 文本排序</h2><p><code>sort</code>命令用于将文本文件的行排序。默认情况下，<code>sort</code>命令是按照字符串的字母顺序排序。</p><p>sort 的常用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将文本内容按字母顺序排序</span><span class="token function">sort</span> example.txt<span class="token comment" spellcheck="true"># 使用 -u 选项，移除所有重复行后排序</span><span class="token function">sort</span> -u example.txt<span class="token comment" spellcheck="true"># 使用 -n 选项，将令数字按数值的大小排序</span><span class="token function">sort</span> -n example.txt<span class="token comment" spellcheck="true"># 使用 -r 选项，以倒序方式排序</span><span class="token function">sort</span> -n -r example.txt<span class="token comment" spellcheck="true"># 同时将 file1、file2 的内容排序</span><span class="token function">sort</span> file1 file2</code></pre><h2 id="2-uniq-文本去重"><a href="#2-uniq-文本去重" class="headerlink" title="2.uniq - 文本去重"></a>2.uniq - 文本去重</h2><p><code>uniq</code>命令用于移除或发现文件中重复的条目。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 它将移除文件中重复的行并显示单一行</span><span class="token function">uniq</span> example.txt<span class="token comment" spellcheck="true"># 可以统计重复行出现的次数</span><span class="token function">uniq</span> -c example.txt<span class="token comment" spellcheck="true"># 使用 -d 选项，只显示文件中有重复的行并只显示一次</span><span class="token function">uniq</span> -d example.txt<span class="token comment" spellcheck="true"># 使用 -D 选项，显示文件中所有重复的行</span><span class="token function">uniq</span> -D example.txt<span class="token comment" spellcheck="true"># 使用 -u 选项，只显示文件中不重复的行</span><span class="token function">uniq</span> -u example.txt<span class="token comment" spellcheck="true"># 使用 -w 选项，限制 uniq 命令只比较每行的前 3 个字符是否重复</span><span class="token function">uniq</span> -w 3 example.txt<span class="token comment" spellcheck="true"># 使用 -s 选项，避免 uniq 命令比较每行的前 3 个字符，只比较后面的字符是否重复</span><span class="token function">uniq</span> -s 3 example.txt<span class="token comment" spellcheck="true"># 使用 -f 选项，避免 uniq 命令比较第一列的内容，只比较后面的字符是否重复</span><span class="token function">uniq</span> -f 1 example.txt</code></pre><h2 id="3-tr-替换或删除字符"><a href="#3-tr-替换或删除字符" class="headerlink" title="3.tr - 替换或删除字符"></a>3.tr - 替换或删除字符</h2><p><code>tr</code>命令主要用于删除文件中控制字符或进行字符转换。使用<code>tr</code>时要转换两个字符串：字符串 1 用于查询，字符串 2 用于处理各种转换。<code>tr</code>刚执行时，字符串 1 中的字符被映射到字符串 2 中的字符，然后转换操作开始。</p><p><code>tr</code>命令的语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">tr</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. SET1 <span class="token punctuation">[</span>SET2<span class="token punctuation">]</span></code></pre><p>常用命令示例：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 若要将大括号转换为小括号</span><span class="token function">tr</span> <span class="token string">'{}'</span> <span class="token string">'()'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要将大括号转换成方括号</span><span class="token function">tr</span> <span class="token string">'{}'</span> <span class="token string">'\[]'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要将小写字符转换成大写，请输入：</span><span class="token function">tr</span> <span class="token string">'a-z'</span> <span class="token string">'A-Z'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要创建一个文件中的单词列表</span><span class="token function">tr</span> -cs <span class="token string">'[:lower:][:upper:]'</span> <span class="token string">'[\n*]'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要从某个文件中删除所有空字符</span><span class="token function">tr</span> -d <span class="token string">'\0'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要用单独的换行替换每一序列的一个或多个换行，请输入：</span><span class="token function">tr</span> -s <span class="token string">'\n'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 要以单个“#”字符替换 &lt;space> 字符类中的每个字符序列</span><span class="token function">tr</span> -s <span class="token string">'[:space:]'</span> <span class="token string">'[#*]'</span></code></pre><h2 id="4-grep-查找字符串"><a href="#4-grep-查找字符串" class="headerlink" title="4.grep - 查找字符串"></a>4.grep - 查找字符串</h2><p><code>grep</code>命令用于搜索文本或指定的文件中与指定的字符串或模式相匹配的行。默认情况下，<code>grep</code>命令只显示匹配的行。</p><p><code>grep</code>命令的语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">grep</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. PATTERN <span class="token punctuation">[</span>FILE<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span class="token function">grep</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>-e PATTERN <span class="token operator">|</span> -f FILE<span class="token punctuation">]</span> <span class="token punctuation">[</span>FILE<span class="token punctuation">]</span><span class="token punctuation">..</span>.</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># `grep`命令查找文件/etc/passwd 中帐号 niww 的信息</span><span class="token function">grep</span> niww /etc/passwd<span class="token comment" spellcheck="true"># 使用 -i 选项，强制 grep 命令忽略搜索关键字的大小写</span><span class="token function">grep</span> -i niww /etc/passwd<span class="token comment" spellcheck="true"># 使用 -r 选项，可以递归搜索指定目录下的所有文件</span><span class="token function">grep</span> -r niww /etc/<span class="token comment" spellcheck="true"># 使用 -w 选项，只匹配包含指定单词的行</span><span class="token function">grep</span> -w niww /etc/<span class="token comment" spellcheck="true"># 使用 -c 选项，报告文件或文本中模式被匹配的次数</span><span class="token function">grep</span> -c niww /etc/passwd<span class="token comment" spellcheck="true"># 使用 -n 选项，显示每一个匹配的行的行号</span><span class="token function">grep</span> -n niww /etc/passwd<span class="token comment" spellcheck="true"># 使用 -v 选项，可以输出除匹配指定模式的行以外的其他所有行</span><span class="token function">grep</span> -v niww /etc/passwd<span class="token comment" spellcheck="true"># 使用 --color 选项，在输出中将匹配的字符串以彩色的形式标出</span><span class="token function">grep</span> --color niww /etc/passwd</code></pre><h2 id="5-diff-比较两个文件"><a href="#5-diff-比较两个文件" class="headerlink" title="5.diff - 比较两个文件"></a>5.diff - 比较两个文件</h2><p><code>diff</code>命令用于比较两个文件，并找出它们之间的不同。<code>diff</code>命令的语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">diff</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. from-file to-file</code></pre><p>常用使用方式如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 比较两个文件</span><span class="token function">diff</span> nsswitch.conf nsswitch.conf.org<span class="token comment" spellcheck="true"># 使用 -w 选项，比较时忽略空格</span><span class="token function">diff</span> -w nsswitch.conf nsswitch.conf.org<span class="token comment" spellcheck="true"># 使用 -y 选项，以并排的格式输出两个文件的比较结果</span><span class="token function">diff</span> -y nsswitch.conf nsswitch.conf.org使用 -c 选项，以上下对比的格式输出两个文件的比较结果<span class="token function">diff</span> -c nsswitch.conf nsswitch.conf.org</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用Bash命令整理之操作文件和目录</title>
      <link href="/2018/10/10/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Linux/%E5%B8%B8%E7%94%A8Bash%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%E4%B9%8B%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/"/>
      <url>/2018/10/10/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Linux/%E5%B8%B8%E7%94%A8Bash%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%E4%B9%8B%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-touch-创建文件"><a href="#1-touch-创建文件" class="headerlink" title="1. touch - 创建文件"></a>1. touch - 创建文件</h2><p><code>touch</code>命令就可用于创建、变更和修改文件的时间戳。它是 Linux 操作系统的标准程序。<code>touch</code>命令又如下选项：</p><pre class=" language-bash"><code class="language-bash">-a: 只改变访问时间 -c: 不创建任何文件-m: 只改变修改时间-r: 使用指定文件的时间替代当前时间-t: 使用 <span class="token punctuation">[</span><span class="token punctuation">[</span>CC<span class="token punctuation">]</span>YY<span class="token punctuation">]</span>MMDDhhmm<span class="token punctuation">[</span>.ss<span class="token punctuation">]</span> 替代当前时间</code></pre><p>touch 命令的常见用法如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建一个名为 effyl 的新空文件</span><span class="token function">touch</span> effyl<span class="token comment" spellcheck="true"># 同时创建名称分别为 effyl myeffyl lueffyl 的三个文件</span><span class="token function">touch</span> effyl myeffyl lueffyl<span class="token comment" spellcheck="true"># 使用 -a 选项，可以改变或更新文件的最新访问时间，如果文件 effyl 不存在，则新创建一个</span><span class="token function">touch</span> -a effyl<span class="token comment" spellcheck="true"># 使用 -c 选项，可以避免创建一个新文件，并用当前时间更新文件的时间戳</span><span class="token function">touch</span> -c effyl<span class="token comment" spellcheck="true"># 使用 -m 选项，可以只改变文件的修改时间，而访问时间不变</span><span class="token function">touch</span> -m effyl<span class="token comment" spellcheck="true"># 使用 -c 和 -t 选项，来明确设置文件的时间</span><span class="token function">touch</span> -c -t YYMMDDHHMM filename<span class="token comment" spellcheck="true"># 如果想使用文件 myeffyl 的时间戳更新文件 effyl 的时间戳，可以使用 -r 选项</span><span class="token function">touch</span> -r myeffyl effyl</code></pre><h2 id="2-mkdir-创建目录"><a href="#2-mkdir-创建目录" class="headerlink" title="2.mkdir - 创建目录"></a>2.mkdir - 创建目录</h2><p><code>mkdir</code>命令用于创建一个新目录。最基本的<code>mkdir</code>命令的使用方法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在当前目录下创建一个给定的目录名</span><span class="token function">mkdir</span> <span class="token operator">&lt;</span>dirname<span class="token operator">></span><span class="token comment" spellcheck="true"># 在 backup 中的相对路径创建一个名为 old 的目录</span><span class="token function">mkdir</span> backup/old<span class="token comment" spellcheck="true"># 在 backup 中的绝对路径中创建一个名为 old 的目录</span><span class="token function">mkdir</span> /home/niww/backup/old<span class="token comment" spellcheck="true"># 使用 -p 选项，会自动创建所有还不存在的父目录</span><span class="token function">mkdir</span> -p backup/old<span class="token comment" spellcheck="true"># 使用 -m 选项，可以设置将要创建目录的权限</span><span class="token comment" spellcheck="true"># 如：创建一个任何人都有读写访问权限的目录</span><span class="token function">mkdir</span> -p -m 777 backup/old</code></pre><h2 id="3-cp-复制文件或目录"><a href="#3-cp-复制文件或目录" class="headerlink" title="3.cp - 复制文件或目录"></a>3.cp - 复制文件或目录</h2><p><code>cp</code>命令用于将文件从一个地方复制到另一个地方。原来的文件保持不变，新文件可能保持原名或用一个不同的名字。</p><p>使用 cp 命令复制文件和目录的语法有以下几种：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 复制源文件到目标文件</span><span class="token function">cp</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span> SOURCE DEST<span class="token comment" spellcheck="true"># 复制一个或多个源文件到一个目录</span><span class="token function">cp</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span> SOURCE<span class="token punctuation">..</span>. DIRECTORY<span class="token comment" spellcheck="true"># 同上</span><span class="token function">cp</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span> -t DIRECTORY SOURCE<span class="token punctuation">..</span>. </code></pre><p>常用使用示例如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在当前目录下，创建一个文件 file.txt 的副本，取名为 newfile.txt</span><span class="token function">cp</span> file.txt newfile.txt<span class="token comment" spellcheck="true"># 复制当前目录下的 file.txt 文件到 /tmp 目录下</span><span class="token function">cp</span> file.txt /tmp<span class="token comment" spellcheck="true"># 复制当前目录下的所有文件到 /tmp 目录下</span><span class="token function">cp</span> * /tmp<span class="token comment" spellcheck="true"># 使用 -p 选项，可以使复制一个文件到新文件时，保留源文件的所有者、权限等信息</span><span class="token function">cp</span> -p filename /path/to/new/location/myfile<span class="token comment" spellcheck="true"># 使用 -R 或 -r 选项，恶意递归地复制一个目录</span><span class="token comment" spellcheck="true"># 即将一个目录及其下的所有文件和子目录都复制到另一个目录</span><span class="token function">cp</span> -R * /home/niww/backup</code></pre><h2 id="4-ln-链接文件或目录"><a href="#4-ln-链接文件或目录" class="headerlink" title="4.ln - 链接文件或目录"></a>4.ln - 链接文件或目录</h2><p><code>ln</code>命令用于创建软链接或硬链接。使用 -s 选项，可以创建一个软链接：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在目录 lib 下创建一个软链接 library.so，链接到 /home/niww/src/library.so</span><span class="token function">ln</span> -s /home/niww/src/library.so /home/niww/lib<span class="token comment" spellcheck="true"># 创建目录的软链接</span><span class="token function">ln</span> -s /home/niww/src <span class="token function">source</span></code></pre><h2 id="5-mv-移动文件或目录"><a href="#5-mv-移动文件或目录" class="headerlink" title="5. mv - 移动文件或目录"></a>5. mv - 移动文件或目录</h2><p><code>mv</code>命令用于将文件和目录从一个位置移到另外一个位置。除了移动文件，<code>mv</code>命令还可用于修改文件或目录的名字。</p><p>mv 命令的基本语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mv</span> SOURCE<span class="token punctuation">..</span>. DIRECTORY</code></pre><p>常用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将当前目录下的文件 source.txt 移到目录 /tmp 下</span><span class="token function">mv</span> source.txt /tmp<span class="token comment" spellcheck="true"># 将目录 dir1、dir2 移到目录 dir_dist 下</span><span class="token function">mv</span> dir1 dir2 dir_dist<span class="token comment" spellcheck="true"># 将当前目录下的 old.txt 文件更名为 new.txt</span><span class="token function">mv</span> old.txt new.txt<span class="token comment" spellcheck="true"># 使用 -i 选项，在重写覆盖目标文件或目录之前给出提示信息</span><span class="token function">mv</span> -i old.txt new.txt<span class="token comment" spellcheck="true"># 将当前目录下的所有文件移动到目录 /tmp 下</span><span class="token function">mv</span> * /tmp/<span class="token comment" spellcheck="true"># 使用 -i 选项，从 dir1 中移动那些在目标目录中不存在的文件到目标目录</span><span class="token function">mv</span> -u dir1/* dir2/</code></pre><h2 id="6-rm-删除文件或目录"><a href="#6-rm-删除文件或目录" class="headerlink" title="6.rm - 删除文件或目录"></a>6.rm - 删除文件或目录</h2><p><code>rm</code>命令用于删除指定的文件和目录。其语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">rm</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span><span class="token punctuation">..</span>. FILE<span class="token punctuation">..</span>.</code></pre><p><code>rm</code>的常用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 删除当前目录下的文件 file1.txt、file2.txt、file3.txt</span><span class="token function">rm</span> file1.txt file2.txt file3.txt<span class="token comment" spellcheck="true"># 删除当前目录下的所有文件</span><span class="token function">rm</span> *<span class="token comment" spellcheck="true"># 删除你当前帐号主目录下的 temp 目录中的所有文件</span><span class="token function">rm</span> ~/temp/*<span class="token comment" spellcheck="true"># 使用 -i 选项，可以在删除每个文件或目录前提示用户确认</span><span class="token function">rm</span> -i *<span class="token comment" spellcheck="true"># 删除当前目录下所有以".doc"结尾的文件</span><span class="token function">rm</span> *.doc<span class="token comment" spellcheck="true"># 删除当前目录下所有文件名中包含"movie"字符串的文件</span><span class="token function">rm</span> *movie*<span class="token comment" spellcheck="true"># 删除当前目录下所有以"a"开头的文件</span><span class="token function">rm</span> a*<span class="token comment" spellcheck="true"># 删除当前目录下整个文件名（包括扩展名）只有 3 个字符的所有文件</span><span class="token function">rm</span> ???<span class="token comment" spellcheck="true"># 删除当前目录下文件扩展名有两个字符的所有文件</span><span class="token function">rm</span> *.??<span class="token comment" spellcheck="true"># 删除当前目录下文件名中含有字母 a 或 b 或 c 的所有文件</span><span class="token function">rm</span> *<span class="token punctuation">[</span>abc<span class="token punctuation">]</span>*<span class="token comment" spellcheck="true"># 删除当前目录下文件名中包含 0~9 的所有文件</span><span class="token function">rm</span> *<span class="token punctuation">[</span>0-9<span class="token punctuation">]</span>*<span class="token comment" spellcheck="true"># 删除当前目录下文件扩展名是字母 c 或 h 的所有文件</span><span class="token function">rm</span> *.<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除 /tmp 目录下的所有文件及其子目录</span><span class="token function">rm</span> -rf /tmp/*</code></pre><blockquote><p>-f 删除前不提示用户确认，并忽略不存在的文件</p></blockquote><blockquote><p>-r 递归地删除目录及其下的内容</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用Bash命令整理之查看文件和目录</title>
      <link href="/2018/10/09/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Linux/%E5%B8%B8%E7%94%A8Bash%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%E4%B9%8B%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/"/>
      <url>/2018/10/09/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Linux/%E5%B8%B8%E7%94%A8Bash%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%E4%B9%8B%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-ls-列出文件名和目录"><a href="#1-ls-列出文件名和目录" class="headerlink" title="1. ls - 列出文件名和目录"></a>1. ls - 列出文件名和目录</h2><p><code>ls</code>命令是<code>Linux</code>中最常用的命令之一，其作用就是列出文件名和目录。在命令行提示符下，直接输入<code>ls</code>命令，不带任何选项，将列出当前目录下所有文件和目录，但不会显示详细的信息，比如，文件类型、大小、修改日期和时间、权限等。</p><p>以下便是<code>ls</code>命令及其选项的作用说明：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 仅列出当前目录下所有文件和目录</span><span class="token function">ls</span><span class="token comment" spellcheck="true"># 每行显示一条记录，每条记录包括文件类型、大小、修改日期和时间、权限等</span><span class="token function">ls</span> -l<span class="token comment" spellcheck="true"># 将文件大小显示符合人类阅读习惯的格式</span><span class="token function">ls</span> -lh<span class="token comment" spellcheck="true"># 将使用不同的特殊字符归类不同的文件类型</span><span class="token function">ls</span> -F<span class="token comment" spellcheck="true"># 以长列表格式列出某个目录的信息</span><span class="token function">ls</span> -ld /var/log<span class="token comment" spellcheck="true"># 将递归地列出子目录的内容</span><span class="token function">ls</span> -R /etc/sysconfig/<span class="token comment" spellcheck="true"># 以长列表格式按文件或目录的修改时间倒序地列出文件和目录</span><span class="token function">ls</span> -ltr<span class="token comment" spellcheck="true"># 以长列表格式按文件大小顺序列出文件和目录</span><span class="token function">ls</span> -ls<span class="token comment" spellcheck="true"># 列出包括隐藏文件或目录在内的所有文件和目录，包括“.”（当前目录）和“..”（父目录）</span><span class="token function">ls</span> -a<span class="token comment" spellcheck="true"># 列出包括隐藏文件或目录在内的所有文件和目录，不包括“.”（当前目录）和“..”（父目录）</span><span class="token function">ls</span> -A输出的内容类似于-l选项，指示显示uid和gid，替代显示所有者和用户组<span class="token function">ls</span> -n</code></pre><h2 id="2-cat-连接显示文件内容"><a href="#2-cat-连接显示文件内容" class="headerlink" title="2. cat - 连接显示文件内容"></a>2. cat - 连接显示文件内容</h2><p><code>cat</code> 命令也是Linux系统中最常用的命令之一。<code>cat</code>命令让我们可以看看文件的内容、连接文件、创建一个或多个文件和重定向输出到终端或文件。</p><p><code>cat</code>命令的语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span> <span class="token punctuation">[</span>FILE<span class="token punctuation">]</span><span class="token punctuation">..</span>.</code></pre><p><code>cat</code>常用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 使用 cat 命令查看文件 /etc/group 的内容</span><span class="token function">cat</span> /etc/group<span class="token comment" spellcheck="true"># 显示多个文件的内容</span><span class="token function">cat</span> /etc/redhat-release /etc/issue<span class="token comment" spellcheck="true"># -n 选项，可以显示文件内容的行号</span><span class="token function">cat</span> -n /etc/fstab<span class="token comment" spellcheck="true"># -b 选项和 -n 选项类似，但只标识非空白行的行号</span><span class="token function">cat</span> -b /etc/fstab<span class="token comment" spellcheck="true"># -e 选项，将在每一行的结尾显示“$”字符</span><span class="token function">cat</span> -e /etc/fstab</code></pre><blockquote><p>当你只输入 cat 命令，而没有任何参数时，它只是接收标准输入的内容并在标准输出中显示。所以你在输入一行内容并回车后，会在接下来的一行显示相同的内容。你也可以重定向标准输出到一个新文件。</p></blockquote><h2 id="3-less、more-分屏显示文件"><a href="#3-less、more-分屏显示文件" class="headerlink" title="3.less、more - 分屏显示文件"></a>3.less、more - 分屏显示文件</h2><p><code>more</code>命令在你使用小的xterm窗口时，或是想不使用文本编辑器而只是简单地阅读一个文件时是很有用的。more命令是一个用于一次翻阅一整屏文件的过滤器。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看一个文件，自动清空屏幕并显示文件开头部分</span><span class="token function">more</span> /etc/inittab<span class="token comment" spellcheck="true"># 指定一次显示num行</span><span class="token function">more</span> -num /etc/inittab</code></pre><p>与<code>more</code>命令相比，我个人更喜欢<code>less</code>命令来查看文件。<code>less</code>命令与<code>more</code>命令类似，但<code>less</code>命令向前和向后翻页都支持，而且<code>less</code>命令不需要在查看前加载整个文件，即<code>less</code>命令查看文件更快速。</p><p><code>less</code>常用命令参数如下：</p><pre class=" language-bash"><code class="language-bash">-b  <span class="token operator">&lt;</span>缓冲区大小<span class="token operator">></span> 设置缓冲区的大小-e  当文件显示结束后，自动离开-f  强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g  只标志最后搜索的关键词-i  忽略搜索时的大小写-m  显示类似more命令的百分比-N  显示每行的行号-o  <span class="token operator">&lt;</span>文件名<span class="token operator">></span> 将less 输出的内容在指定文件中保存起来-Q  不使用警告音-s  显示连续空行为一行-S  行过长时间将超出部分舍弃-x  <span class="token operator">&lt;</span>数字<span class="token operator">></span> 将“tab”键显示为规定的数字空格/字符串：向下搜索“字符串”的功能?字符串：向上搜索“字符串”的功能n： 重复前一个搜索（与 / 或 ? 有关）N： 反向重复前一个搜索（与 / 或 ? 有关）b  向后翻一页d  向后翻半页h  显示帮助界面Q  退出less 命令u  向前滚动半页y  向前滚动一行空格键 滚动一行回车键 滚动一页<span class="token punctuation">[</span>pagedown<span class="token punctuation">]</span>： 向下翻动一页<span class="token punctuation">[</span>pageup<span class="token punctuation">]</span>：   向上翻动一页</code></pre><h2 id="4-head-显示文件头部"><a href="#4-head-显示文件头部" class="headerlink" title="4.head - 显示文件头部"></a>4.head - 显示文件头部</h2><p><code>head</code>命令用于打印指定输入的开头部分内容。默认情况下，打印每个指定输入的前10行内容。</p><p>使用<code>-n</code>选项可以指定打印文件的前N行：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 指定打印文件的前5行</span><span class="token function">head</span> -n 5 /etc/inittab（或）head -5 /etc/inittab<span class="token comment" spellcheck="true"># 打印文件的前N个字节的数据</span><span class="token function">head</span> -c 10 /etc/inittab</code></pre><h2 id="5-tail-显示文件尾部"><a href="#5-tail-显示文件尾部" class="headerlink" title="5.tail - 显示文件尾部"></a>5.tail - 显示文件尾部</h2><p><code>tail</code>命令和<code>head</code>命令相反，它打印指定输入的结尾部分的内容。默认情况下，它打印指定输入的最后10行内容。</p><p>使用<code>-n</code>选项可以指定打印文件的最后N行：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 指定打印文件的后10行</span><span class="token function">tail</span> -n 10 /etc/inittab<span class="token function">tail</span> -10 /etc/inittab<span class="token comment" spellcheck="true"># 即时打印文件中新写入的行</span><span class="token function">tail</span> -f /var/log/messages<span class="token comment" spellcheck="true"># --retry选项表示持续尝试打开某个文件，当你想打开一个稍后才会创建或即使不可用的文件</span><span class="token function">tail</span> -f /tmp/debug.log --retry</code></pre><h2 id="6-file-查看文件类型"><a href="#6-file-查看文件类型" class="headerlink" title="6.file - 查看文件类型"></a>6.file - 查看文件类型</h2><p><code>file</code>命令用于接收一个文件作为参数并执行某些测试，已确定正确的文件类型。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看文件类型</span><span class="token function">file</span> /etc/inittab<span class="token comment" spellcheck="true"># 可以MIME类型的格式显示文件类型的信息</span><span class="token function">file</span> -i  /etc/inittab<span class="token comment" spellcheck="true"># 使用-N 选项，输出的队列可以以在文件名之后无空白填充的形式显示</span><span class="token function">file</span> -N *</code></pre><h2 id="7-wc-查看文件统计信息"><a href="#7-wc-查看文件统计信息" class="headerlink" title="7.wc - 查看文件统计信息"></a>7.wc - 查看文件统计信息</h2><p><code>wc</code>命令用于查看文件的行数、单词数和字符数等信息。语法类似如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">wc</span> filenameX Y Z /etc/inittab</code></pre><p>其中X表示行数，Y表示单词数，Z表示字节数，filename表示文件名。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># -l选项，可以只统计文件的行数信息</span><span class="token function">wc</span> -l /etc/inittab<span class="token comment" spellcheck="true"># -w选项，可以只统计文件的单词数信息</span><span class="token function">wc</span> -w /etc/inittab<span class="token comment" spellcheck="true"># -c选项，可以只统计文件的字节数信息</span><span class="token function">wc</span> -c /etc/inittab<span class="token comment" spellcheck="true"># -L选项，可以只统计文件中最长的行的长度</span><span class="token function">wc</span> -L /etc/inittab</code></pre><h2 id="8-find-查找文件或目录"><a href="#8-find-查找文件或目录" class="headerlink" title="8.find - 查找文件或目录"></a>8.find - 查找文件或目录</h2><p><code>find</code>命令用于根据你指定的参数搜索和定位文件和目录的列表。<code>find</code>命令可以在多种情况下使用，比如你可以通过权限、用户、用户组、文件类型、日期、大小和其他可能的条件来查找文件。</p><p><code>find</code>命令常用使用和说明如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查找指定目录下的某个文件</span><span class="token function">find</span> /etc/ -name inittab<span class="token comment" spellcheck="true"># 在当前目录下查找名称为 inittab 的文件</span><span class="token function">find</span> <span class="token keyword">.</span> -name inittab<span class="token comment" spellcheck="true"># 在当前目录下，文件不区分大小写是example的所有文件</span><span class="token function">find</span> <span class="token keyword">.</span> -iname example<span class="token comment" spellcheck="true"># 找出当前目录下所有以 sh 结尾的文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f -name <span class="token string">"*.sh"</span><span class="token comment" spellcheck="true"># 找出当前目录下，文件权限是 777 的所有文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f -perm 777<span class="token comment" spellcheck="true"># 找出当前目录下，文件权限不是 777 的所有文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f <span class="token operator">!</span> -perm 777<span class="token comment" spellcheck="true"># 找出当前目录下所有只读文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f <span class="token operator">!</span> -perm /a+w<span class="token comment" spellcheck="true"># 找出你帐号主目录下的所有可执行文件</span><span class="token function">find</span> ~ -type f -perm /a+w<span class="token comment" spellcheck="true"># 找出 /tmp 目录下的.log文件并将其删除：</span><span class="token function">find</span> /tmp/ -type f -name <span class="token string">"*.log"</span> -exec <span class="token function">rm</span> -f <span class="token punctuation">{</span><span class="token punctuation">}</span> \<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 找出当前目录下的所有空文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f -empty<span class="token comment" spellcheck="true"># 找出当前目录下的所有空目录</span><span class="token function">find</span> <span class="token keyword">.</span> -type d -empty<span class="token comment" spellcheck="true"># 找出 /tmp 目录下的所有隐藏文件</span><span class="token function">find</span> /tmp/ -type f -name <span class="token string">".*"</span><span class="token comment" spellcheck="true"># 找出 /tmp 目录下，所有者是 root 的文件和目录</span><span class="token function">find</span> /tmp/ -user root<span class="token comment" spellcheck="true"># 找出 /tmp 目录下，用户组是 developer 的文件和目录</span><span class="token function">find</span> /tmp/ -group root<span class="token comment" spellcheck="true"># 找出你账号的主目录下，3 天前修改的文件</span><span class="token function">find</span> ~ -type f -mtime 3<span class="token comment" spellcheck="true"># 找出你账号的主目录下，30 天以前修改的所有文件</span><span class="token function">find</span> ~ -type f -mtime +30<span class="token comment" spellcheck="true"># 找出你账号的主目录下，3 天以内修改的所有文件</span><span class="token function">find</span> ~ -type f -mtime -3<span class="token comment" spellcheck="true"># 找出你账号的主目录下，30 天以前，60 天以内修改的所有文件</span><span class="token function">find</span> ~ -type f -mtime +30 -mtime -60<span class="token comment" spellcheck="true"># 找出 /etc 目录下，一小时以内变更过的文件</span><span class="token function">find</span> /etc -type f -cmin -60<span class="token comment" spellcheck="true"># 找出 /etc 目录下，一小时以内访问过的文件</span><span class="token function">find</span> /etc -type f -amin -60<span class="token comment" spellcheck="true"># 找出你账号主目录下，大小是50MB的所有文件</span><span class="token function">find</span> ~ -type f -size 50MB<span class="token comment" spellcheck="true"># 找出你账号主目录下，大于50MB小于100MB的所有文件</span><span class="token function">find</span> ~ -type f -size +50MB -size -100MB<span class="token comment" spellcheck="true"># 找出你账号主目录下，大于100MB的文件并将其删除</span><span class="token function">find</span> ~ -type f -size +100MB -exec <span class="token function">rm</span> -rf <span class="token punctuation">{</span><span class="token punctuation">}</span> \<span class="token punctuation">;</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git知识点整理</title>
      <link href="/2018/09/24/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/Git%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
      <url>/2018/09/24/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/Git%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Git基本概念。"><a href="#1-Git基本概念。" class="headerlink" title="1. Git基本概念。"></a>1. Git基本概念。</h2><ul><li><code>repository</code></li><li><code>config</code></li><li><code>init</code></li><li><code>clone</code></li><li><code>fetch</code></li><li><code>pull</code></li><li><code>commit</code></li><li><code>push</code></li><li><code>branch</code></li><li><code>head</code></li><li><code>tag</code></li><li><code>merge</code></li><li><code>conflict</code></li><li><code>diff</code></li><li><code>log</code></li><li><code>show</code></li><li><code>status</code></li></ul><h2 id="2-Git工作空间和文件状态"><a href="#2-Git工作空间和文件状态" class="headerlink" title="2. Git工作空间和文件状态"></a>2. Git工作空间和文件状态</h2><h3 id="1-工作空间"><a href="#1-工作空间" class="headerlink" title="(1).工作空间"></a>(1).工作空间</h3><p><img src="http://blog.chinaunix.net/attachment/201402/19/10415985_139279770639pM.jpg" alt="Git工作空间"></p><p>左侧为工作区，右侧为版本库。</p><ul><li>工作区（<code>Working Directory</code>） 就是在电脑里能看到的目录，比如learngit文件夹就是一个工作区。</li><li>版本库（<code>Repository</code>）工作区有一个隐藏目录<code>.git</code>，是Git的版本库。</li></ul><p>在版本库中标记为<code>index</code>的区域为暂存区，标记为<code>master</code>的是Git为我们自动创建的第一个分支，代表的是目录树。此时<code>HEAD</code>实际是指向<code>master</code>分支的一个“游标”，所以图示的命令中出现HEAD的地方可以用<code>master</code>来替换。图中的objects标识的区域为git的对象库，实际位于<code>.git/objects</code>目录下。</p><ul><li>当对工作区修改（或新增）的文件执行<code>git add</code>命令时，暂存区的目录树会被更新，同时工作区修改（或新增）的文件内容会被写入到对象库中的一个新的对象中，而该对象的id被记录在暂存区的文件索引中。</li><li>当执行提交操作<code>git commit</code>时，暂存区的目录树会写到版本库（对象库）中，master分支会做相应的更新，即master最新指向的目录树就是提交时原暂存区的目录树。</li><li>当执行<code>git reset HEAD</code>命令时，暂存区的目录树会被重写，会被master分支指向的目录树所替换，但是工作区不受影响。</li><li>当执行<code>git rm --cached</code>命令时，会直接从暂存区删除文件，工作区则不做出改变。</li><li>当执行<code>git checkout .</code>或<code>git checkout --</code> 命令时，会用暂存区全部的文件或指定的文件替换工作区的文件。这个操作很危险，会清楚工作区中未添加到暂存区的改动。</li><li>当执行<code>git checkout HEAD .</code>或<code>git checkout HEAD</code>命令时，会用HEAD指向的master分支中的全部或部分文件替换暂存区和工作区中的文件。这个命令也是极度危险的。因为不但会清楚工作区中未提交的改动，也会清楚暂存区中未提交的改动。</li></ul><h3 id="1-文件状态"><a href="#1-文件状态" class="headerlink" title="(1).文件状态"></a>(1).文件状态</h3><p>Git 有三种状态，你的文件可能处于其中之一：<strong>已提交(<code>committed</code>)</strong>、<strong>已修改(<code>modified</code>)</strong>和<strong>已暂存(<code>staged</code>)</strong>。</p><h2 id="3-Git配置系统级、全局、当前仓库用户名、邮箱的命令"><a href="#3-Git配置系统级、全局、当前仓库用户名、邮箱的命令" class="headerlink" title="3. Git配置系统级、全局、当前仓库用户名、邮箱的命令"></a>3. Git配置系统级、全局、当前仓库用户名、邮箱的命令</h2><p>系统级、全局、当前仓库选项分别是:仓库-system、-global、-local(或默认不填)</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"Jerry Mouse"</span><span class="token function">git</span> config --global user.email <span class="token string">"jerry@yiibai.com"</span></code></pre><p>列出Git设置</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --list<span class="token function">git</span> config -l</code></pre><h2 id="4-Git-fetch和pull的区别"><a href="#4-Git-fetch和pull的区别" class="headerlink" title="4. Git fetch和pull的区别"></a>4. Git fetch和pull的区别</h2><ul><li><code>git fetch</code>：相当于是从远程获取最新版本到本地，不会自动merge.</li><li><code>git pull</code>：相当于是从远程获取最新版本并merge到本地.</li></ul><h3 id="1-git-fetch示例："><a href="#1-git-fetch示例：" class="headerlink" title="(1). git fetch示例："></a>(1). git fetch示例：</h3><pre class=" language-bash"><code class="language-bash">Git fetch origin master<span class="token function">git</span> log -p master<span class="token punctuation">..</span>origin/master<span class="token function">git</span> merge origin/master</code></pre><p>以上命令的含义：</p><ul><li>首先从远程的<code>origin</code>的<code>master</code>主分支下载最新的版本到<code>origin/master</code>分支上</li><li>然后比较本地的<code>master</code>分支和<code>origin/master</code>分支的差别</li><li>最后进行合并</li><li>上述过程其实可以用以下更清晰的方式来进行：</li></ul><h3 id="1-git-pull示例："><a href="#1-git-pull示例：" class="headerlink" title="(1). git pull示例："></a>(1). git pull示例：</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> pull origin master</code></pre><p>上述命令其实相当于<code>git fetch</code>和<code>git merge</code>。在实际使用中，<code>git fetch</code>更安全一些，因为在merge前，我们可以查看更新情况，然后再决定是否合并。</p><h2 id="5-Git-reset和revert的却别"><a href="#5-Git-reset和revert的却别" class="headerlink" title="5. Git reset和revert的却别"></a>5. Git reset和revert的却别</h2><ul><li><code>git revert</code>是用一次新的commit来回滚之前的commit，<code>git reset</code>是直接删除指定的commit。 </li><li>在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为<code>git revert</code>是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是<code>git reset</code>是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。</li><li><code>git reset</code>是把HEAD向后移动了一下，而<code>git revert</code>是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。</li><li>git revert与git reset最大的不同是，git revert 仅仅是撤销某次提交。</li></ul><p>另外，说一下<code>git revert</code>， <code>git reset –hard</code>和 <code>–soft</code>的区别</p><ul><li><code>git reset –mixed id</code>: 是将git的HEAD变了（也就是提交记录变了），但文件并没有改变，（也就是working tree并没有改变）。</li><li><code>git reset –soft id</code>: 实际上，是<code>git reset –mixed id</code>后，又做了一次<code>git add</code>。</li><li><code>git reset –herd id</code>: 是将git的HEAD变了，文件也变了。</li></ul><h2 id="6-Git-merge和reabse的相同点和不同点"><a href="#6-Git-merge和reabse的相同点和不同点" class="headerlink" title="6. Git merge和reabse的相同点和不同点"></a>6. Git merge和reabse的相同点和不同点</h2><p><code>merge</code>是合并的意思，<code>rebase</code>是复位基底的意思，相同点都是用来合并分支的。</p><p><img src="http://images2015.cnblogs.com/blog/759200/201608/759200-20160806092734215-279978821.png" alt="merge和rebase"></p><p>不同点:</p><ul><li><code>merge</code>操作会生成一个新的节点，之前的提交分开显示。而<code>rebase</code>操作不会生成新的节点，是将两个分支融合成一个线性的提交。</li><li>解决冲突时。merge操作遇到冲突的时候，当前merge不能继续进行下去。手动修改冲突内容后，add 修改，commit就可以了。而<code>rebase</code>操作的话，会中断rebase,同时会提示去解决冲突。解决冲突后,将修改add后执行<code>git rebase –continue</code>继续操作，或者<code>git rebase –skip</code>忽略冲突。</li><li><code>git pull</code>和<code>git pull --rebase</code>区别：<code>git pull</code>做了两个操作分别是”获取”和”合并”。所以加了rebase就是以rebase的方式进行合并分支，默认为merge。</li></ul><p><strong>总结</strong>：选择 merge 还是 rebase？</p><ul><li>merge 是一个合并操作，会将两个分支的修改合并在一起，默认操作的情况下会提交合并中修改的内容</li><li>merge 的提交历史忠实地记录了实际发生过什么，关注点在真实的提交历史上面</li><li>rebase 并没有进行合并操作，只是提取了当前分支的修改，将其复制在了目标分支的最新提交后面</li><li>rebase 的提交历史反映了项目过程中发生了什么，关注点在开发过程上面</li><li>merge 与 rebase 都是非常强大的分支整合命令，没有优劣之分，使用哪一个应由项目和团队的开发需求决定</li><li>merge 和 rebase 还有很多强大的选项，可以使用 git help <command> 查看</command></li></ul><h2 id="7-Git-stash是什么？它的相关使用方式命令"><a href="#7-Git-stash是什么？它的相关使用方式命令" class="headerlink" title="7. Git stash是什么？它的相关使用方式命令"></a>7. Git stash是什么？它的相关使用方式命令</h2><ul><li>git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。</li><li>git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。</li><li>git stash pop –index stash@{0}: 恢复编号为0的进度的工作区和暂存区。</li><li>git stash apply stash@{1} 以将你指定版本号为stash@{1}的工作取出来</li><li>git stash drop[<stash>] 删除某一个进度，默认删除最新进度</stash></li><li>git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。</li><li>git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 恢复工作进度</span><span class="token function">git</span> stash pop <span class="token punctuation">[</span>--index<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>stash<span class="token operator">></span><span class="token punctuation">]</span>--index 参数：不仅恢复工作区，还恢复暂存区<span class="token operator">&lt;</span>stash<span class="token operator">></span> 指定恢复某一个具体进度。如果没有这个参数，默认恢复最新进度<span class="token comment" spellcheck="true"># 这是git stash保存进度的完整命令形式</span><span class="token function">git</span> stash <span class="token punctuation">[</span>save message<span class="token punctuation">]</span> <span class="token punctuation">[</span>-k<span class="token operator">|</span>--no-keep-index<span class="token punctuation">]</span> <span class="token punctuation">[</span>--patch<span class="token punctuation">]</span>-k和--no-keep-index指定保存进度后，是否重置暂存区--patch 会显示工作区和HEAD的差异,通过编辑差异文件，排除不需要保存的内容。和git add -p命令类似使用save可以对进度添加备注<span class="token comment" spellcheck="true"># git stash save "这是保存的进度"</span></code></pre><h2 id="8-Git只从暂存区删除，从工作空间删除的命令分别是什么"><a href="#8-Git只从暂存区删除，从工作空间删除的命令分别是什么" class="headerlink" title="8. Git只从暂存区删除，从工作空间删除的命令分别是什么?"></a>8. Git只从暂存区删除，从工作空间删除的命令分别是什么?</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> --cached<span class="token function">git</span> <span class="token function">rm</span><span class="token function">git</span> commit</code></pre><h2 id="9-Git标签的使用"><a href="#9-Git标签的使用" class="headerlink" title="9. Git标签的使用"></a>9. Git标签的使用</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出现有的标签</span><span class="token function">git</span> tag<span class="token comment" spellcheck="true"># 打标签</span><span class="token function">git</span> tag -a v1.01 -m <span class="token string">"Relase version 1.01"</span><span class="token comment" spellcheck="true"># 查看相应标签的版本信息</span><span class="token function">git</span> show v1.4</code></pre><ul><li>-a 选项,创建一个含附注类型的标签</li><li>-m 选项,指定了对应的标签说明</li></ul><h2 id="9-Git分支的使用"><a href="#9-Git分支的使用" class="headerlink" title="9. Git分支的使用"></a>9. Git分支的使用</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看本地分支</span><span class="token function">git</span> branch<span class="token comment" spellcheck="true"># 查看远程分支</span><span class="token function">git</span> branch -r<span class="token comment" spellcheck="true"># 创建本地分支(注意新分支创建后不会自动切换为当前分支)</span><span class="token function">git</span> branch <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 切换分支</span><span class="token function">git</span> checkout <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 创建新分支并立即切换到新分支</span><span class="token function">git</span> checkout -b <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 强制删除一个分支</span><span class="token function">git</span> branch -D <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 合并分支(将名称为[name]的分支与当前分支合并)</span><span class="token function">git</span> merge <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 查看各个分支最后提交信息</span><span class="token function">git</span> br -v<span class="token comment" spellcheck="true"># 查看已经被合并到当前分支的分支</span><span class="token function">git</span> br --merged<span class="token comment" spellcheck="true"># 查看尚未被合并到当前分支的分支</span><span class="token function">git</span> br --no-merged</code></pre><h2 id="10-介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。"><a href="#10-介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。" class="headerlink" title="10. 介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。"></a>10. 介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。</h2><p>merge和rebase对于ours和theirs的定义是完全相反的。在merge时，ours指代的是当前分支，theirs代表需要被合并的分支。而在rebase过程中，ours指向了修改参考分支，theirs却是当前分支。因为rebase 隐含了一个<code>git checkout upstream</code>的过程，将<code>HEAD</code>从local分支变成了upstream分支。git会在rebase结束后撤销这个改变，但它已经不可避免地影响了冲突的状态，使rebase中ours和theirs的定义与merge 截然相反。因此，在使用ours与theirs时请格外小心。</p><h2 id="11-Git远程操作相关"><a href="#11-Git远程操作相关" class="headerlink" title="11. Git远程操作相关"></a>11. Git远程操作相关</h2><h3 id="1-clone"><a href="#1-clone" class="headerlink" title="(1). clone"></a>(1). clone</h3><blockquote><p>git clone &lt;版本库的网址&gt;<br>git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 克隆jQuery的版本库</span> <span class="token function">git</span> clone https://github.com/jquery/jquery.git <span class="token function">git</span> clone -o jQuery https://github.com/jquery/jquery.git</code></pre><h3 id="2-remote"><a href="#2-remote" class="headerlink" title="(2). remote"></a>(2). remote</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出所有远程主机</span><span class="token function">git</span> remote<span class="token comment" spellcheck="true"># 使用-v选项，可以参看远程主机的网址</span><span class="token function">git</span> remote -v<span class="token comment" spellcheck="true"># 可以查看该主机的详细信息</span><span class="token function">git</span> remote show <span class="token operator">&lt;</span>主机名<span class="token operator">></span><span class="token comment" spellcheck="true"># 添加远程主机</span><span class="token function">git</span> remote add <span class="token operator">&lt;</span>主机名<span class="token operator">></span> <span class="token operator">&lt;</span>网址<span class="token operator">></span><span class="token comment" spellcheck="true"># 删除远程主机</span><span class="token function">git</span> remote <span class="token function">rm</span> <span class="token operator">&lt;</span>主机名<span class="token operator">></span><span class="token comment" spellcheck="true"># 修改远程主机名称</span><span class="token function">git</span> remote <span class="token function">rename</span> <span class="token operator">&lt;</span>原主机名<span class="token operator">></span> <span class="token operator">&lt;</span>新主机名<span class="token operator">></span></code></pre><h3 id="3-fetch"><a href="#3-fetch" class="headerlink" title="(3). fetch"></a>(3). fetch</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 取回所有分支(branch)的更新到本地</span><span class="token function">git</span> fetch <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span><span class="token comment" spellcheck="true"># 取回某的特定分支的更新</span><span class="token function">git</span> fetch <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span> <span class="token operator">&lt;</span>分支名<span class="token operator">></span><span class="token comment" spellcheck="true"># 取回origin主机的master分支的更新</span><span class="token function">git</span> fetch origin master<span class="token comment" spellcheck="true"># 所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支</span><span class="token function">git</span> merge origin/master<span class="token function">git</span> rebase origin/master</code></pre><h3 id="4-pull"><a href="#4-pull" class="headerlink" title="(4). pull"></a>(4). pull</h3><blockquote><p>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 取回origin主机的next分支，与本地的master分支合并</span><span class="token function">git</span> pull origin next:master<span class="token comment" spellcheck="true"># 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</span><span class="token function">git</span> pull origin next<span class="token comment" spellcheck="true"># 上面的命令实质上等同于先做git fetch，再做git merge。</span><span class="token function">git</span> fetch origin<span class="token function">git</span> merge origin/next<span class="token comment" spellcheck="true"># 合并需要采用rebase模式</span><span class="token function">git</span> pull --rebase <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span> <span class="token operator">&lt;</span>远程分支名<span class="token operator">></span>:<span class="token operator">&lt;</span>本地分支名<span class="token operator">></span></code></pre><h3 id="5-push"><a href="#5-push" class="headerlink" title="(5). push"></a>(5). push</h3><blockquote><p>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</p></blockquote><p><strong>注意</strong>:分支推送顺序的写法是”&lt;来源地&gt;:&lt;目的地&gt;”，所以git pull是”&lt;远程分支&gt;:&lt;本地分支&gt;”，而git push是”&lt;本地分支&gt;:&lt;远程分支&gt;”。</p><ul><li>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。</li><li>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建</span><span class="token function">git</span> push origin master<span class="token comment" spellcheck="true"># 省略了本地分支，以下等同，删除origin主机的master分支</span><span class="token function">git</span> push origin :master<span class="token function">git</span> push origin --delete master<span class="token comment" spellcheck="true"># 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略</span><span class="token function">git</span> push origin<span class="token comment" spellcheck="true"># 如果当前分支只有一个追踪分支，那么主机名都可以省略。</span><span class="token function">git</span> push<span class="token comment" spellcheck="true"># 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push</span><span class="token function">git</span> push -u origin master<span class="token comment" spellcheck="true"># 不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机</span><span class="token function">git</span> push --all origin<span class="token comment" spellcheck="true"># 强制推送</span><span class="token function">git</span> push --force origin<span class="token comment" spellcheck="true"># git push不会推送标签(tag)，除非使用–tags选项</span><span class="token function">git</span> push origin --tags</code></pre><h2 id="12-Git-Flow使用简介"><a href="#12-Git-Flow使用简介" class="headerlink" title="12. Git Flow使用简介"></a>12. Git Flow使用简介</h2><p>就像代码需要代码规范一样，代码管理同样需要一个清晰的流程和规范。三种广泛使用的工作流程：</p><ul><li>Git flow</li><li>Github flow</li><li>Gitlab flow</li></ul><p>三种工作流程，有一个共同点：都采用”功能驱动式开发”（Feature-driven development，简称FDD）。它指的是，需求是开发的起点，先有需求再有功能分支（feature branch）或者补丁分支（hotfix branch）。完成开发后，该分支就合并到主分支，然后被删除。最早诞生、并得到广泛采用的一种工作流程，就是<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">Git flow</a>。</p><p>它最主要的特点有两个。首先，项目存在两个长期分支，分别是：主分支master、开发分支develop。其次，项目存在三种短期分支，分别是：功能分支（feature branch）、补丁分支（hotfix branch）、预发分支（release branch），一旦完成开发，它们就会被合并进develop或master，然后被删除。</p><h3 id="1-Git-Flow流程图"><a href="#1-Git-Flow流程图" class="headerlink" title="(1). Git Flow流程图"></a>(1). Git Flow流程图</h3><p><img src="http://static.blinkfox.com/ghost/imagegit_flow.png" alt="Git Flow流程图"></p><h3 id="2-Git-Flow常用的分支"><a href="#2-Git-Flow常用的分支" class="headerlink" title="(2). Git Flow常用的分支"></a>(2). Git Flow常用的分支</h3><ul><li><code>Production</code>分支。也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改。</li><li><code>Develop</code>分支。这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支。</li><li><code>Feature</code>分支。这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release。</li><li><code>Release</code>分支。当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支。</li><li><code>Hotfix</code>分支。当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release。</li></ul><h3 id="3-Git-Flow代码示例"><a href="#3-Git-Flow代码示例" class="headerlink" title="(3). Git Flow代码示例"></a>(3). Git Flow代码示例</h3><h4 id="a-创建develop分支"><a href="#a-创建develop分支" class="headerlink" title="a. 创建develop分支"></a>a. 创建develop分支</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> branch develop<span class="token function">git</span> push -u origin develop</code></pre><h4 id="b-开始新Feature开发"><a href="#b-开始新Feature开发" class="headerlink" title="b. 开始新Feature开发"></a>b. 开始新Feature开发</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b some-feature develop<span class="token comment" spellcheck="true"># Optionally, push branch to origin:</span><span class="token function">git</span> push -u origin some-feature<span class="token comment" spellcheck="true"># 做一些改动</span><span class="token function">git</span> status<span class="token function">git</span> add some-file<span class="token function">git</span> commit</code></pre><h4 id="c-完成Feature"><a href="#c-完成Feature" class="headerlink" title="c. 完成Feature"></a>c. 完成Feature</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> pull origin develop<span class="token function">git</span> checkout develop<span class="token function">git</span> merge --no-ff some-feature<span class="token function">git</span> push origin develop<span class="token function">git</span> branch -d some-feature<span class="token comment" spellcheck="true"># If you pushed branch to origin:</span><span class="token function">git</span> push origin --delete some-feature</code></pre><h4 id="d-开始Relase"><a href="#d-开始Relase" class="headerlink" title="d. 开始Relase"></a>d. 开始Relase</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b release-0.1.0 develop<span class="token comment" spellcheck="true"># Optional: Bump version number, commit</span><span class="token comment" spellcheck="true"># Prepare release, commit</span></code></pre><h4 id="e-完成Release"><a href="#e-完成Release" class="headerlink" title="e. 完成Release"></a>e. 完成Release</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout master<span class="token function">git</span> merge --no-ff release-0.1.0<span class="token function">git</span> push<span class="token function">git</span> checkout develop<span class="token function">git</span> merge --no-ff release-0.1.0<span class="token function">git</span> push<span class="token function">git</span> branch -d release-0.1.0<span class="token comment" spellcheck="true"># If you pushed branch to origin:</span><span class="token function">git</span> push origin --delete release-0.1.0   <span class="token function">git</span> tag -a v0.1.0 master<span class="token function">git</span> push --tags</code></pre><h4 id="f-开始Hotfix"><a href="#f-开始Hotfix" class="headerlink" title="f. 开始Hotfix"></a>f. 开始Hotfix</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b hotfix-0.1.1 master</code></pre><h4 id="g-完成Hotfix"><a href="#g-完成Hotfix" class="headerlink" title="g. 完成Hotfix"></a>g. 完成Hotfix</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout master<span class="token function">git</span> merge --no-ff hotfix-0.1.1<span class="token function">git</span> push<span class="token function">git</span> checkout develop<span class="token function">git</span> merge --no-ff hotfix-0.1.1<span class="token function">git</span> push<span class="token function">git</span> branch -d hotfix-0.1.1<span class="token function">git</span> tag -a v0.1.1 master<span class="token function">git</span> push --tags</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之状态模式</title>
      <link href="/2018/09/21/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/09/21/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(<code>stateful</code>)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>状态模式(<code>State Pattern</code>)</strong>：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(<code>Objects for States</code>)，状态模式是一种对象行为型模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成："><a href="#1-角色组成：" class="headerlink" title="1. 角色组成："></a>1. 角色组成：</h3><p>状态模式包含如下角色：</p><ul><li><code>Context</code>: 环境类</li><li><code>State</code>: 抽象状态角色</li><li><code>ConcreteState</code>: 具体状态角色类</li></ul><h3 id="2-结构图："><a href="#2-结构图：" class="headerlink" title="2. 结构图："></a>2. 结构图：</h3><p><img src="http://static.blinkfox.com/State.jpg" alt="状态模式结构图"></p><h3 id="3-时序图："><a href="#3-时序图：" class="headerlink" title="3. 时序图："></a>3. 时序图：</h3><p><img src="http://static.blinkfox.com/seq_State.jpg" alt="状态模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的状态角色接口：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象状态角色 * Created by niww on 16/7/12. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IState</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 抽象方法1     */</span>    <span class="token keyword">void</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 抽象方法2     */</span>    <span class="token keyword">void</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>接下来，是多个具体的状态角色类，分别如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体状态角色类1 * Created by niww on 16/7/12. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteState1</span> <span class="token keyword">implements</span> <span class="token class-name">IState</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类1中的方法1     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类1中的方法1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类1中的方法2     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类1中的方法2..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体状态角色类2 * Created by niww on 16/7/12. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteState2</span> <span class="token keyword">implements</span> <span class="token class-name">IState</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类2中的方法1     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类2中的方法1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类2中的方法2     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类2中的方法2..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是环境类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 环境角色类 * Created by niww on 16/7/12. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当前状态</span>    <span class="token keyword">private</span> IState state<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造方法     * @param state     */</span>    <span class="token keyword">public</span> <span class="token function">Context</span><span class="token punctuation">(</span>IState state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 方法1     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span><span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 方法2     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span><span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是用于测试状态模式的客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 状态模式的客户端场景累 * Created by niww on 16/7/12. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StateClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Context context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteState1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><ul><li>状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。</li><li>状态模式的关键是引入了一个抽象接口来专门表示对象的状态，这个类我们叫做抽象状态接口，而对象的每一种具体状态类都实现了该类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。</li></ul><p>在状态模式结构中需要理解环境类与抽象状态类的作用：</p><ul><li>环境类实际上就是拥有状态的对象，环境类有时候可以充当状态管理器(State Manager)的角色，可以在环境类中对状态进行切换操作。</li><li>抽象状态类可以是抽象类，也可以是接口，不同状态类就是继承这个父类的不同子类，状态类的产生是由于环境类存在多个状态，同时还满足两个条件： 这些状态经常需要切换，在不同的状态下对象的行为不同。因此可以将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为，对象看起来似乎修改了它的类，而实际上是由于切换到不同的具体状态类实现的。由于环境类可以设置为任一具体状态类，因此它针对抽象状态类进行编程，在程序运行时可以将任一具体状态类的对象设置到环境类中，从而使得环境类可以改变内部状态，并且改变行为。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>状态模式的优点：</p><ul><li>封装了转换规则。</li><li>枚举可能的状态，在枚举状态之前需要确定状态种类。</li><li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li><li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li><li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>状态模式的缺点：</p><ul><li>状态模式的使用必然会增加系统类和对象的个数。</li><li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li><li>状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3.适用环境"></a>3.适用环境</h3><p>在以下情况下可以使用状态模式：</p><ul><li>对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。</li><li>代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。</li></ul><blockquote><p>状态模式在工作流或游戏等类型的软件中得以广泛使用，甚至可以用于这些系统的核心功能设计，如在政府OA办公系统中，一个批文的状态有多种：尚未办理；正在办理；正在批示；正在审核；已经完成等各种状态，而且批文状态不同时对批文的操作也有所差异。使用状态模式可以描述工作流对象（如批文）的状态转换以及不同状态下它所具有的行为。</p></blockquote><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>状态模式允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象，状态模式是一种对象行为型模式。</li><li>状态模式包含三个角色：环境类又称为上下文类，它是拥有状态的对象，在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象，可以定义初始状态；抽象状态类用于定义一个接口以封装与环境类的一个特定状态相关的行为；具体状态类是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。</li><li>状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。</li><li>状态模式的主要优点在于封装了转换规则，并枚举可能的状态，它将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为，还可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数；其缺点在于使用状态模式会增加系统类和对象的个数，且状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，对于可以切换状态的状态模式不满足“开闭原则”的要求。</li><li>状态模式适用情况包括：对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为；代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之代理模式</title>
      <link href="/2018/09/20/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/09/20/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。</p><p>通过引入一个新的对象来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一个对象，这就是代理模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>代理模式(<code>Proxy Pattern</code>)</strong>：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做<code>Proxy</code>或<code>Surrogate</code>，它是一种对象结构型模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>代理模式包含如下角色：</p><ul><li><code>Subject</code>: 抽象主题角色</li><li><code>RealSubject</code>: 真实主题角色</li><li><code>Proxy</code>: 代理主题角色</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/Proxy.jpg" alt="代理模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的主题接口和真实主题类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>niww<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 抽象主题类 * Created by niww on 2017/1/1. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ISubject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 定义一个方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>niww<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 真实主题类 * Created by niww on 2017/1/1. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RealSubject</span> <span class="token keyword">implements</span> <span class="token class-name">ISubject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 实现方法     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"真实主题类请求方法..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是代理类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>niww<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 代理类 * Created by niww on 2017/1/1. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Proxy</span> <span class="token keyword">implements</span> <span class="token class-name">ISubject</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> ISubject subject<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Proxy</span><span class="token punctuation">(</span>ISubject subject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subject <span class="token operator">=</span> subject<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subject<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 预处理     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行前(before)的处理..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 善后处理     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行后(after)的处理..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景测试类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>niww<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 代理模式客户端场景类 * Created by niww on 2017/1/1. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ISubject subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RealSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Proxy proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>subject<span class="token punctuation">)</span><span class="token punctuation">;</span>        proxy<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>代理模式的优点：</p><ul><li>代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。</li><li>远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li><li>虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</li><li>保护代理可以控制对真实对象的使用权限。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>代理模式的缺点：</p><ul><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。</li><li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>根据代理模式的使用目的，常见的代理模式有以下几种类型：</p><ul><li><strong>远程(Remote)代理</strong>：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又叫做大使(Ambassador)。</li><li><strong>虚拟(Virtual)代理</strong>：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li><li><strong>Copy-on-Write代理</strong>：它是虚拟代理的一种，把复制（克隆）操作延迟 到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li><li><strong>保护(Protect or Access)代理</strong>：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li><li><strong>缓冲(Cache)代理</strong>：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li><li><strong>防火墙(Firewall)代理</strong>：保护目标不让恶意用户接近。</li><li><strong>同步化(Synchronization)代理</strong>：使几个用户能够同时使用一个对象而没有冲突。</li><li><strong>智能引用(Smart Reference)代理</strong>：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</li></ul><h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><ul><li>在代理模式中，要求给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。</li><li>代理模式包含三个角色：抽象主题角色声明了真实主题和代理主题的共同接口；代理主题角色内部包含对真实主题的引用，从而可以在任何时候操作真实主题对象；真实主题角色定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的方法。</li><li>代理模式的优点在于能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；其缺点在于由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，并且实现代理模式需要额外的工作，有些代理模式的实现非常复杂。远程代理为一个位于不同的地址空间的对象提供一个本地的代表对象，它使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li><li>如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建，这个小对象称为虚拟代理。虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</li><li>保护代理可以控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之工厂方法模式</title>
      <link href="/2018/09/14/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/09/14/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式定义"><a href="#一、模式定义" class="headerlink" title="一、模式定义"></a>一、模式定义</h2><p>工厂方法模式(<code>Factory Method Pattern</code>)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><h2 id="二、模式结构"><a href="#二、模式结构" class="headerlink" title="二、模式结构"></a>二、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>工厂方法模式包含如下角色：</p><ul><li><code>Product</code>：抽象产品</li><li><code>ConcreteProduct</code>：具体产品</li><li><code>Factory</code>：抽象工厂</li><li><code>ConcreteFactory</code>：具体工厂</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://static.blinkfox.com/FactoryMethod.jpg" alt="工厂方法模式结构图"></p><h3 id="3-时序图"><a href="#3-时序图" class="headerlink" title="3. 时序图"></a>3. 时序图</h3><p><img src="http://static.blinkfox.com/seq_FactoryMethod.jpg" alt="工厂方法模式时序图"></p><h2 id="三、示例代码"><a href="#三、示例代码" class="headerlink" title="三、示例代码"></a>三、示例代码</h2><p>首先，是抽象的产品类和具体的产品类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象产品类 * Created by niww on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 产品类的公共方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是产品类的公共方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 抽象方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体产品类1 * Created by niww on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct1</span> <span class="token keyword">extends</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteProduct1的method2方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体产品类2 * Created by niww on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct2</span> <span class="token keyword">extends</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteProduct2的method2方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是抽象的工厂类和具体的工厂类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象的工厂类 * Created by niww on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 运用了Java中的泛型和反射技术,生成某种具体的产品     * 其输入类型可以自行设置     * @param c     * @param &lt;T>     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Product</span><span class="token operator">></span> T <span class="token function">createProduct</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体生产产品的工厂类 * Created by niww on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory</span> <span class="token keyword">extends</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 运用了Java中的泛型和反射技术,生成某种具体的产品     * 其输入类型可以自行设置     * @param c     * @param &lt;T>     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Product</span><span class="token operator">></span> T <span class="token function">createProduct</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token punctuation">(</span>Product<span class="token punctuation">)</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产产品出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 工厂方法模式客户端场景类 * Created by niww on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Factory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product1 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>ConcreteProduct1<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product1<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product1<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product2 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>ConcreteProduct2<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product2<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product2<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="四、模式分析"><a href="#四、模式分析" class="headerlink" title="四、模式分析"></a>四、模式分析</h2><p>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>工厂方法模式的优点：</p><ul><li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li><li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>工厂方法模式的缺点：</p><ul><li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用工厂方法模式：</p><ul><li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li><li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li><li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li></ul><h2 id="五、模式扩展"><a href="#五、模式扩展" class="headerlink" title="五、模式扩展"></a>五、模式扩展</h2><p>工厂方法模式有很多扩展，而且与其他模式结合使用威力更大，下面介绍4种常用扩展。</p><h3 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1. 简单工厂模式"></a>1. 简单工厂模式</h3><p>我们这样考虑一个问题：一个模块仅需要一个工厂类，没有必要把它产生出来，使用静态的方法就可以了。因此去掉工厂类中继承的抽象类，把方法改成静态即可。通用代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 简单工厂模式中的工厂类 * Created by niww on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 运用了Java中的泛型和反射技术,生成某种具体的产品     * 其输入类型可以自行设置     * @param c     * @param &lt;T>     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span>  <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Product</span><span class="token operator">></span> T <span class="token function">createProduct</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token punctuation">(</span>Product<span class="token punctuation">)</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产产品出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 简单工厂模式客户端场景类 * Created by niww on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product1 <span class="token operator">=</span> SimpleFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>ConcreteProduct1<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product1<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product1<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product2 <span class="token operator">=</span> SimpleFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>ConcreteProduct2<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product2<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product2<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果没有发生变化，但是类图简单了，调用者也比较简单，简单工厂模式是工厂方法模式的弱化，也叫做静态工厂模式。其缺点是工厂类的扩展比较困难，不符合“开闭原则”，但它仍然是一个非常实用的设计模式。</p><h3 id="2-多工厂类工厂方法模式"><a href="#2-多工厂类工厂方法模式" class="headerlink" title="2. 多工厂类工厂方法模式"></a>2. 多工厂类工厂方法模式</h3><p>当我们在一个比较复杂的项目时，经常会遇到初始化一个对象很耗费精力的情况，所有的产品类都放到一个工厂方法中进行初始化会使代码结构不清晰。为了让结构清晰，我们就为每类产品定义一个创造者，然后由调用者自己去选择与哪个工厂方法关联。多工厂模式的通用代码如下：</p><p>多工厂模式的抽象工厂类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 生成多个产品的抽象工厂类 * Created by niww on 16-7-2. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">MultiFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 生成某种产品的方法     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>第一种产品的创建工厂实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 生成产品1的具体工厂类1 * Created by niww on 16-7-2. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory1</span> <span class="token keyword">extends</span> <span class="token class-name">MultiFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 生成产品1的方法     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>第二种产品的创建工厂实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 生成产品2的具体工厂类2 * Created by niww on 16-7-2. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory2</span> <span class="token keyword">extends</span> <span class="token class-name">MultiFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 生成产品2的方法     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>多工厂模式的客户端场景类</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 多工厂方法模式客户端场景类 * Created by niww on 16-7-2. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MultiClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product concreteProduct1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteFactory1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteProduct1<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteProduct1<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product concreteProduct2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteFactory2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteProduct1<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteProduct1<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="3-工厂方法的单例模式"><a href="#3-工厂方法的单例模式" class="headerlink" title="3. 工厂方法的单例模式"></a>3. 工厂方法的单例模式</h3><p>单例模式的核心要求就是在内存中只有一个对象，通过工厂方法模式也可以只在内存中生成一个对象，从而实现单例的功能。</p><p>下面是单例类，其中定义了一个private的无参构造函数，目的是不允许通过new的方式创建对象，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 工厂方法模式中的单例类 * Created by niww on 16-7-4. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 私有化构造方法，不允许new产生一个对象     */</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 工厂方法模式中的单例模式业务方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"工厂方法模式中的单例模式方法。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以上单例类中不能通过正常的渠道建立一个对象，那单例的工厂类中如何建立一个单例对象呢？答案是通过反射方式创建，单例工厂类的代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 生成单例的工厂类 * Created by niww on 16-7-4. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Class <span class="token class-name">c</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 获得无参构造</span>            Constructor constructor <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 设置无参构造是可访问的</span>            constructor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 产生一个实例对象</span>            singleton <span class="token operator">=</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">)</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生成单例的工厂类方法中生成单例出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>zuihou        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后是工厂方法单例模式的客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 工厂方法单例模式客户端场景类 * Created by niww on 16-7-4. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingleClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Singleton singleton <span class="token operator">=</span> SingletonFactory<span class="token punctuation">.</span><span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        singleton<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="4-工厂方法的延迟初始化"><a href="#4-工厂方法的延迟初始化" class="headerlink" title="4. 工厂方法的延迟初始化"></a>4. 工厂方法的延迟初始化</h3><p>何为延迟初始化？一个对象被消费完毕后，并不立即释放，工厂类保持其初始状态，等待再次使用。延迟初始化是工厂模式的一个扩展应用，其通用代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 延迟加载的工厂类 * Created by niww on 16-7-4. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazyFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Product<span class="token operator">></span> lazyMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Product<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span>String type<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果map中已经有这个对象，则直接取出该对象即可，否则创建并放在缓存容器中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lazyMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> lazyMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 根据类型创建具体的产品对象</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"product1"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 同时把对象放到缓存容器中</span>        lazyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"type"</span><span class="token punctuation">,</span> product<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面即为延迟加载的工厂类。代码比较简单，通过定义一个<code>map</code>容器来容纳所有产生的对象，如果在<code>map</code>容器中已经有的对象，则直接取出返回；如果没有，则根据需要的类型产生一个对象并放入到<code>map</code>容器中，以便下次调用。</p><p>延迟加载的工厂模式客户端场景类代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 延迟加载的工厂模式客户端场景类 * Created by niww on 16-7-4. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazyClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product1 <span class="token operator">=</span> LazyFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token string">"product1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product11 <span class="token operator">=</span> LazyFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token string">"product1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>工厂方法模式又称为工厂模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</li><li>工厂方法模式包含四个角色：抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，即产品对象的共同父类或接口；具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，它们之间往往一一对应；抽象工厂中声明了工厂方法，用于返回一个产品，它是工厂方法模式的核心，任何在模式中创建对象的工厂类都必须实现该接口；具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例。</li><li>工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</li><li>工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</li><li>工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之装饰模式</title>
      <link href="/2018/09/14/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/09/14/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>一般有两种方式可以实现给一个类或对象增加行为：</p><ul><li><strong>继承机制</strong>，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</li><li><strong>关联机制</strong>，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)</li></ul><p><strong>装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任</strong>，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。<strong>装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展</strong>。这就是装饰模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)</strong>，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”。</p></blockquote><p>策略模式是一种<strong>对象结构型</strong>模式。</p><h2 id="三、-模式结构"><a href="#三、-模式结构" class="headerlink" title="三、 模式结构"></a>三、 模式结构</h2><p>装饰模式包含如下角色：</p><ul><li><code>Component</code>: 抽象构件</li><li><code>ConcreteComponent</code>: 具体构件</li><li><code>Decorator</code>: 抽象装饰类</li><li><code>ConcreteDecorator</code>: 具体装饰类</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="http://static.blinkfox.com/Decorator.jpg" alt="装饰模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="http://static.blinkfox.com/seq_Decorator.jpg" alt="装饰模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先定义一个抽象构件接口：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象构件 * Created by niww on 16-6-26. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 接口方法</span>    <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后是具体构件实现类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体构件 * Created by niww on 16-6-26. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteComponent</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体实现方法     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"do Something..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>接着是装饰角色：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 装饰角色 * 维持一个指向Component对象的引用，并定义一个与 Component接口一致的接口。 * Created by niww on 16-6-26. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Decorator</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Component component<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 通过构造函数传递被修饰者     * @param component     */</span>    <span class="token keyword">public</span> <span class="token function">Decorator</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>component <span class="token operator">=</span> component<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 委托给被修饰者执行     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>component<span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下面是具体的装饰类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的装饰类1 * Created by niww on 16-6-26. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteDecorator1</span> <span class="token keyword">extends</span> <span class="token class-name">Decorator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 通过构造函数传递被修饰者     * @param component     */</span>    <span class="token keyword">public</span> <span class="token function">ConcreteDecorator1</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 定义自己的修饰方法1     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"method1修饰..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 重写父类的operate方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的装饰类2 * Created by niww on 16-6-26. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteDecorator2</span> <span class="token keyword">extends</span> <span class="token class-name">Decorator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 通过构造函数传递被修饰者     * @param component     */</span>    <span class="token keyword">public</span> <span class="token function">ConcreteDecorator2</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 定义自己的修饰方法2     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"method2修饰..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 重写父类的operate方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后是客户端的场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 装饰模式的客户端场景类 * Created by niww on 16-6-26. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Component component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第一修饰</span>        component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteDecorator1</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第二修饰</span>        component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteDecorator2</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 修饰后运行</span>        component<span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><h3 id="总体分析"><a href="#总体分析" class="headerlink" title="总体分析"></a>总体分析</h3><ul><li><strong>与继承关系相比，关联关系的主要优势在于不会破坏类的封装性，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展</strong>。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得系统更加容易维护。当然，<em>关联关系的缺点是比继承关系要创建更多的对象</em>。</li><li><strong>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任</strong>。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>装饰模式的优点：</p><ul><li>装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。</li><li>可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。</li><li>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</li><li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>装饰模式的缺点：</p><ul><li>使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。</li><li>这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用装饰模式：</p><ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。</li><li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）。</li></ul><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>装饰模式的简化-需要注意的问题:</p><ul><li>一个装饰类的接口必须与被装饰类的接口保持相同，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。</li><li>尽量保持具体构件类Component作为一个“轻”类，也就是说不要把太多的逻辑和状态放在具体构件类中，可以通过装饰类。</li><li>如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类。</li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>装饰模式用于动态地给一个对象增加一些额外的职责，就增加对象功 能来说，装饰模式比生成子类实现更为灵活。它是一种对象结构型模式。</li><li>装饰模式包含四个角色：抽象构件定义了对象的接口，可以给这些对 象动态增加职责（方法）；具体构件定义了具体的构件对象，实现了 在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）； 抽象装饰类是抽象构件类的子类，用于给具体构件增加职责，但是具 体职责在其子类中实现；具体装饰类是抽象装饰类的子类，负责向构 件添加新的职责。</li><li>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动 态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子 类的情况下，将对象的功能加以扩展。</li><li>装饰模式的主要优点在于可以提供比继承更多的灵活性，可以通过一种动态的方式来扩展一个对象的功能，并通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，而且具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类；其主要缺点在于使用装饰模式进行系统设计时将产生很多小对象，而且装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li><li>装饰模式适用情况包括：在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；需要动态地给一个对象增加功能，这些功能也可以动态地被撤销；当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展 和维护时。</li><li>装饰模式可分为透明装饰模式和半透明装饰模式：在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型；半透明装饰模式允许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之策略模式</title>
      <link href="/2018/09/14/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/09/14/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。</p><p>在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(<code>Hard Coding</code>)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。</p><p>除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。</p><p>为了解决这些问题，可以<strong>定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类</strong>。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)</strong>。</p></blockquote><p>策略模式是一种对象行为型模式。</p><h2 id="三、-模式结构"><a href="#三、-模式结构" class="headerlink" title="三、 模式结构"></a>三、 模式结构</h2><p>策略模式包含如下角色：</p><ul><li>Context: 环境类</li><li>Strategy: 抽象策略类</li><li>ConcreteStrategy: 具体策略类</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="http://static.blinkfox.com/Strategy1.jpg" alt="策略模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="http://static.blinkfox.com/strategy2.jpg" alt="策略模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先定义一个策略接口：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IStrategy</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 策略模式的运算法则     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后是具体的策略实现类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteStrategy1</span> <span class="token keyword">implements</span> <span class="token class-name">IStrategy</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体策略的策略方法1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteStrategy2</span> <span class="token keyword">implements</span> <span class="token class-name">IStrategy</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体策略的策略方法2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>接着是封装角色的类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 抽象策略</span>    <span class="token keyword">private</span> IStrategy strategy<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造函数设置具体策略     * @param strategy     */</span>    <span class="token keyword">public</span> <span class="token function">Context</span><span class="token punctuation">(</span>IStrategy strategy<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>strategy <span class="token operator">=</span> strategy<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 封装后的策略方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>strategy<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后是客户端的调用策略类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 声明一个具体的策略</span>        IStrategy strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteStrategy1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 声明上下文对象</span>        Context context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span>strategy<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 执行封装后的方法</span>        context<span class="token punctuation">.</span><span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><h3 id="总体分析"><a href="#总体分析" class="headerlink" title="总体分析"></a>总体分析</h3><ul><li>策略模式是一个比较容易理解和使用的设计模式，策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是“<strong>准备一组算法，并将每一个算法封装起来，使得它们可以互换</strong>”。</li><li>在策略模式中，应当由客户端自己决定在什么情况下使用什么具体策略角色。</li><li>策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中“退休”的方便，策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。这在一定程度上提高了系统的灵活性，但是客户端需要理解所有具体策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，在一定程度上增加了客户端的使用难度。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>策略模式的优点：</p><ul><li>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基- 础上选择算法或行为，也可以灵活地增加新的算法或行为。</li><li>策略模式提供了管理相关的算法族的办法。</li><li>策略模式提供了可以替换继承关系的办法。</li><li>使用策略模式可以避免使用多重条件转移语句。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>策略模式的缺点：</p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li><li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用策略模式：</p><ul><li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li><li>一个系统需要动态地在几种算法中选择一种。</li><li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li><li>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。</li></ul><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>策略模式与状态模式：</p><ul><li>可以通过环境类状态的个数来决定是使用策略模式还是状态模式。</li><li>策略模式的环境类自己选择一个具体策略类，具体策略类无须关心环境类；而状态模式的环境类由于外在因素需要放进一个具体状态中，以便通过其方法实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系。</li><li>使用策略模式时，客户端需要知道所选的具体策略是哪一个，而使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换。</li><li>如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式；如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式。</li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>在策略模式中定义了一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式。策略模式是一种对象行为型模式。</li><li>策略模式包含三个角色：环境类在解决某个问题时可以采用多种策略，在环境类中维护一个对抽象策略类的引用实例；抽象策略类为所支持的算法声明了抽象方法，是所有策略类的父类；具体策略类实现了在抽象策略类中定义的算法。</li><li>策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。</li><li>策略模式主要优点在于对“开闭原则”的完美支持，在不修改原有系统的基础上可以更换算法或者增加新的算法，它很好地管理算法族，提高了代码的复用性，是一种替换继承，避免多重条件转移语句的实现方式；其缺点在于客户端必须知道所有的策略类，并理解其区别，同时在一定程度上增加了系统中类的个数，可能会存在很多策略类。</li><li>策略模式适用情况包括：在一个系统里面有许多类，它们之间的区别仅在于它们的行为，使用策略模式可以动态地让一个对象在许多行为中选择一种行为；一个系统需要动态地在几种算法中选择一种；避免使用难以维护的多重条件选择语句；希望在具体策略类中封装算法和与相关的数据结构。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8中关于日期和时间API的20个使用示例</title>
      <link href="/2018/09/13/Java8%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4API%E7%9A%8420%E4%B8%AA%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
      <url>/2018/09/13/Java8%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4API%E7%9A%8420%E4%B8%AA%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>随着<a href="http://javarevisited.blogspot.sg/2014/02/10-example-of-lambda-expressions-in-java8.html" target="_blank" rel="noopener"><code>lambda</code></a>表达式、<a href="http://java67.blogspot.sg/2014/04/java-8-stream-api-examples-filter-map.html" target="_blank" rel="noopener">streams</a>以及一系列小优化，Java8推出了全新的日期时间API，在一下的指南中我们将通过一些简单的示例来学习如何使用新API。Java处理日期、日历和时间的方式一直为社区所诟病，将<code>java.util.Date</code>设定为可变类型，以及<a href="http://javarevisited.blogspot.sg/2012/03/simpledateformat-in-java-is-not-thread.html" target="_blank" rel="noopener"><code>SimpleDateFormat</code>的非线程安全</a>使其应用非常受限。<code>Java</code>也意识到需要一个更好的<code>API</code>来满足社区中已经习惯了使用<code>JodaTime API</code>的人们。全新<code>API</code>的众多好处之一就是，明确了日期时间概念，例如：瞬时（instant）、期间（duration）、日期、时间、时区和周期。同时继承了<code>Joda</code>库按人类语言和计算机各自解析的时间处理方式。不同于老版本，新<code>API</code>基于ISO标准日历系统，<code>java.time</code>包下的所有类都是不可变类型而且线程安全。下面是新版API中<code>java.time</code>包里的一些关键类：</p><ul><li><code>Instant</code>：瞬时实例。</li><li><code>LocalDate</code>：本地日期，不包含具体时间。例如：<code>2014-01-14</code>可以用来记录生日、纪念日、加盟日等。</li><li><code>LocalTime</code>：本地时间，不包含日期。</li><li><code>LocalDateTime</code>：组合了日期和时间，但不包含时差和时区信息。</li><li><code>ZonedDateTime</code>：最完整的日期时间，包含时区和相对UTC或格林威治的时差。</li></ul><p>新API还引入了<code>ZoneOffSet</code>和<code>ZoneId</code>类，使得解决时区问题更为简便。<a href="http://javarevisited.blogspot.sg/2011/09/step-by-step-guide-to-convert-string-to.html" target="_blank" rel="noopener">解析和格式化时间</a>的<code>DateTimeFormatter</code>类也全部重新设计。<strong>注意，这篇文章是翻译自<a href="http://javarevisited.blogspot.sg/2015/03/20-examples-of-date-and-time-api-from-Java8.html" target="_blank" rel="noopener">Java 8 - 20 Examples of Date and Time API</a>，以下示例代码我做过一些简单的修改，当运行这些例子时会返回你当前的时间</strong>。</p><h2 id="二、在Java8中如何处理日期和时间"><a href="#二、在Java8中如何处理日期和时间" class="headerlink" title="二、在Java8中如何处理日期和时间"></a>二、在Java8中如何处理日期和时间</h2><p>常有人问我学习一个新库的最好方式是什么？我的答案是在实际项目中使用它。项目中有很多真正的需求驱使开发者去发掘并学习新库。简单得说就是任务驱动学习探索。这对Java8新日期时间<code>API</code>也不例外。我创建了20个基于任务的实例来学习Java8的新特性。从最简单创建当天的日期开始，然后创建时间及时区，接着模拟一个日期提醒应用中的任务——计算重要日期的到期天数，例如生日、纪念日、账单日、保费到期日、信用卡过期日等。</p><h3 id="示例-1、在Java8中获取今天的日期"><a href="#示例-1、在Java8中获取今天的日期" class="headerlink" title="示例 1、在Java8中获取今天的日期"></a>示例 1、在Java8中获取今天的日期</h3><p>Java8中的<code>LocalDate</code>用于表示当天日期。和<code>java.util.Date</code>不同，它只有日期，不包含时间。当你仅需要表示日期时就用这个类。</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"今天的日期是："</span> <span class="token operator">+</span> today<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 今天的日期是：2016-04-18</span></code></pre><p>上面的代码创建了当天的日期，不含时间信息。打印出的日期格式非常友好，不像老的<code>Date</code>类打印出一堆没有格式化的信息。</p><h3 id="示例-2、在Java8中获取当前的年、月、日信息"><a href="#示例-2、在Java8中获取当前的年、月、日信息" class="headerlink" title="示例 2、在Java8中获取当前的年、月、日信息"></a>示例 2、在Java8中获取当前的年、月、日信息</h3><p><code>LocalDate</code>类提供了获取年、月、日的快捷方法，其实例还包含很多其它的日期属性。通过调用这些方法就可以很方便的得到需要的日期信息，不用像以前一样需要依赖<code>java.util.Calendar</code>类了。</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> year <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> month <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getMonthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> day <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getDayOfMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"当前的年 : %d  月 : %d  日 : %d%n"</span><span class="token punctuation">,</span> year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> day<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当前的年 : 2016  月 : 4  日 : 18</span></code></pre><p>看到了吧，在Java8中得到年、月、日信息是这么简单直观，想用就用，没什么需要记的。对比看看以前Java是怎么处理年月日信息的吧。</p><h3 id="示例-3、在Java8中获取特定日期"><a href="#示例-3、在Java8中获取特定日期" class="headerlink" title="示例 3、在Java8中获取特定日期"></a>示例 3、在Java8中获取特定日期</h3><p>在第一个例子里，我们通过静态工厂方法<code>now()</code>非常容易地创建了当天日期，你还可以调用另一个有用的工厂方法<code>LocalDate.of()</code>创建任意日期，该方法需要传入年、月、日做参数，返回对应的<code>LocalDate</code>实例。这个方法的好处是没再犯老<code>API</code>的设计错误，比如年度起始于1900，月份是从0开始等等。日期所见即所得，就像下面这个例子表示了1月14日，没有任何隐藏机关。</p><pre class=" language-java"><code class="language-java">LocalDate dateOfBirth <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"你的出生日期是："</span> <span class="token operator">+</span> dateOfBirth<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 你的出生日期是：2016-04-18</span></code></pre><p>可以看到创建的日期完全符合预期，与你写入的2016年4月18日完全一致。</p><h3 id="示例-4、在Java8中判断两个日期是否相等"><a href="#示例-4、在Java8中判断两个日期是否相等" class="headerlink" title="示例 4、在Java8中判断两个日期是否相等"></a>示例 4、在Java8中判断两个日期是否相等</h3><p>现实生活中有一类时间处理就是判断两个日期是否相等。你常常会检查今天是不是个特殊的日子，比如生日、纪念日或非交易日。这时就需要把指定的日期与某个特定日期做比较，例如判断这一天是否是假期。下面这个例子会帮助你用Java8的方式去解决，你肯定已经想到了，<code>LocalDate</code>重载了<code>equal</code>方法，请看下面的例子：</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate date1 <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>date1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>today<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"今天 %s 和 date1 %s 是同一天!%n"</span><span class="token punctuation">,</span> today<span class="token punctuation">,</span> date1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 今天 2016-04-18 和 date1 2016-04-18 是同一天!</span></code></pre><p>这个例子中我们比较的两个日期相同。注意，如果比较的日期是字符型的，需要先解析成日期对象再作判断。对比<a href="http://javarevisited.blogspot.sg/2012/02/3-example-to-compare-two-dates-in-java.html" target="_blank" rel="noopener"><code>Java</code>老的日期比较方式</a>，你会感到清风拂面。</p><h3 id="示例-5、在Java8中检查像生日这种周期性事件"><a href="#示例-5、在Java8中检查像生日这种周期性事件" class="headerlink" title="示例 5、在Java8中检查像生日这种周期性事件"></a>示例 5、在Java8中检查像生日这种周期性事件</h3><p><code>Java</code>中另一个日期时间的处理就是检查类似每月账单、结婚纪念日、EMI日或保险缴费日这些周期性事件。如果你在电子商务网站工作，那么一定会有一个模块用来在圣诞节、感恩节这种节日时向客户发送问候邮件。<code>Java</code>中如何检查这些节日或其它周期性事件呢？答案就是<code>MonthDay</code>类。这个类组合了月份和日，去掉了年，这意味着你可以用它判断每年都会发生事件。和这个类相似的还有一个<code>YearMonth</code>类。这些类也都是不可变并且线程安全的值类型。下面我们通过<code>MonthDay</code>来检查周期性事件：</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate dateOfBirth <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MonthDay birthday <span class="token operator">=</span> MonthDay<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>dateOfBirth<span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dateOfBirth<span class="token punctuation">.</span><span class="token function">getDayOfMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MonthDay currentMonthDay <span class="token operator">=</span> MonthDay<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>today<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>currentMonthDay<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>birthday<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"好高兴今天是您的生日!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"对不起，今天不是您的生日!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 好高兴今天是您的生日!!</span></code></pre><p>只要当天的日期和生日匹配，无论是哪一年都会打印出祝贺信息。你可以把程序整合进系统时钟，看看生日时是否会受到提醒，或者写一个单元测试来检测代码是否运行正确。</p><h3 id="示例-6、在Java8中获取当前时间"><a href="#示例-6、在Java8中获取当前时间" class="headerlink" title="示例 6、在Java8中获取当前时间"></a>示例 6、在Java8中获取当前时间</h3><p>与Java8获取日期的例子很像，获取时间使用的是<code>LocalTime</code>类，一个只有时间没有日期的<code>LocalDate</code>的近亲。可以调用静态工厂方法<code>now()</code>来获取当前时间。默认的格式是<code>hh:mm:ss:nnn</code>。对比一下<a href="http://javarevisited.blogspot.sg/2012/01/get-current-date-timestamps-java.html" target="_blank" rel="noopener">Java8之前获取当前时间的方式</a>。</p><pre class=" language-java"><code class="language-java">LocalTime time <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前时间是:"</span> <span class="token operator">+</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当前时间是:23:43:42.200</span></code></pre><p>可以看到当前时间就只包含时间信息，没有日期。</p><h3 id="示例-7、如何在现有的时间上增加小时"><a href="#示例-7、如何在现有的时间上增加小时" class="headerlink" title="示例 7、如何在现有的时间上增加小时"></a>示例 7、如何在现有的时间上增加小时</h3><p>通过增加小时、分、秒来计算将来的时间很常见。Java8除了不变类型和线程安全的好处之外，还提供了更好的<code>plusHours()</code>方法替换<code>add()</code>，并且是兼容的。注意，这些方法返回一个全新的<code>LocalTime</code>实例，由于其不可变性，返回后一定要用变量赋值。</p><pre class=" language-java"><code class="language-java">LocalTime time <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalTime newTime <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">plusHours</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 添加两小时</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前时间:"</span> <span class="token operator">+</span> time <span class="token operator">+</span> <span class="token string">",两小时后的时间: "</span> <span class="token operator">+</span>  newTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当前时间:23:50:56.195,两小时后的时间: 01:50:56.195</span></code></pre><p>可以看到，新的时间在当前时间<code>23:50:56.195</code>的基础上增加了2个小时。和<a href="http://javarevisited.blogspot.sg/2012/12/how-to-add-subtract-days-months-years-to-date-time-java.html" target="_blank" rel="noopener">旧版<code>Java</code>的增减时间的处理方式</a>对比一下，看看哪种更好。</p><h3 id="示例-8、如何计算一周后的日期"><a href="#示例-8、如何计算一周后的日期" class="headerlink" title="示例 8、如何计算一周后的日期"></a>示例 8、如何计算一周后的日期</h3><p>和上个例子计算两小时以后的时间类似，这个例子会计算一周后的日期。<code>LocalDate</code>日期不包含时间信息，它的<code>plus()</code>方法用来增加天、周、月，<code>ChronoUnit</code>类声明了这些时间单位。由于<code>LocalDate</code>也是不变类型，返回后一定要用变量赋值。</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate nextWeek <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ChronoUnit<span class="token punctuation">.</span>WEEKS<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"今天是:"</span> <span class="token operator">+</span> today <span class="token operator">+</span> <span class="token string">",一周以后的日期: "</span> <span class="token operator">+</span> nextWeek<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 今天是:2016-04-18,一周以后的日期: 2016-04-25</span></code></pre><p>可以看到新日期离当天日期是7天，也就是一周。你可以用同样的方法增加1个月、1年、1小时、1分钟甚至一个世纪，更多选项可以查看<code>Java 8 API</code>中<code>的ChronoUnit</code>类。</p><h3 id="示例-9、计算一年前或一年后的日期"><a href="#示例-9、计算一年前或一年后的日期" class="headerlink" title="示例 9、计算一年前或一年后的日期"></a>示例 9、计算一年前或一年后的日期</h3><p>继续上面的例子，上个例子中我们通过<code>LocalDate</code>的<code>plus()</code>方法增加天数、周数或月数，这个例子我们利用<code>minus()</code>方法计算一年前的日期。</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate preYear <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">minus</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ChronoUnit<span class="token punctuation">.</span>YEARS<span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate nextYear <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ChronoUnit<span class="token punctuation">.</span>YEARS<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"今天是:"</span> <span class="token operator">+</span> today <span class="token operator">+</span> <span class="token string">",一年前的日期: "</span> <span class="token operator">+</span> preYear <span class="token operator">+</span> <span class="token string">",一年后的日期: "</span> <span class="token operator">+</span> nextYear<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 今天是:2016-04-18,一年前的日期: 2015-04-18,一年后的日期: 2017-04-18</span></code></pre><p>例子结果中得到了两个日期，一个2015年、一个2017年、分别是2016年的前一年和后一年。</p><h3 id="示例-10、使用Java8的Clock时钟类"><a href="#示例-10、使用Java8的Clock时钟类" class="headerlink" title="示例 10、使用Java8的Clock时钟类"></a>示例 10、使用Java8的Clock时钟类</h3><p>Java8增加了一个<code>Clock</code>时钟类用于获取当时的时间戳，或当前时区下的日期时间信息。以前用到<code>System.currentTimeInMillis()</code>和<code>TimeZone.getDefault()</code>的地方都可用<code>Clock</code>替换。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 得到UTC的时区的日期时间clock对象</span>Clock clock <span class="token operator">=</span> Clock<span class="token punctuation">.</span><span class="token function">systemUTC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Clock : "</span> <span class="token operator">+</span> clock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Clock : SystemClock[Z]</span><span class="token comment" spellcheck="true">// 得到基于当前时区的日期时间clock对象</span>Clock defaultClock <span class="token operator">=</span> Clock<span class="token punctuation">.</span><span class="token function">systemDefaultZone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Clock : "</span> <span class="token operator">+</span> clock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Clock : SystemClock[Z]</span></code></pre><p>还可以针对clock时钟做比较，像下面这个例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 依赖注入</span>    <span class="token keyword">private</span> Clock clock<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>LocalDate eventDate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventDate<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span>LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>clock<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这种方式在不同时区下处理日期时会非常管用。</p><h3 id="示例-11、如何用Java判断日期是早于还是晚于另一个日期"><a href="#示例-11、如何用Java判断日期是早于还是晚于另一个日期" class="headerlink" title="示例 11、如何用Java判断日期是早于还是晚于另一个日期"></a>示例 11、如何用Java判断日期是早于还是晚于另一个日期</h3><p>另一个工作中常见的操作就是如何判断给定的一个日期是大于某天还是小于某天？在Java8中，<code>LocalDate</code>类有两类方法<code>isBefore()</code>和<code>isAfter()</code>用于比较日期。调用<code>isBefore()</code>方法时，如果给定日期小于当前日期则返回<code>true</code>。</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate tomorrow <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>tomorrow<span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span>today<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"明天晚于今天！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 明天晚于今天！</span>LocalDate yesterday <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">minus</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ChronoUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>yesterday<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span>today<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"昨天先于今天！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 昨天先于今天！</span></code></pre><p>在Java 8中比较日期非常方便，不需要使用额外的<code>Calendar</code>类来做这些基础工作了。</p><h3 id="示例-12、在Java8中处理时区"><a href="#示例-12、在Java8中处理时区" class="headerlink" title="示例 12、在Java8中处理时区"></a>示例 12、在Java8中处理时区</h3><p>Java8不仅分离了日期和时间，也把时区分离出来了。现在有一系列单独的类如<code>ZoneId</code>来处理特定时区，<code>ZoneDateTime</code>类来表示某时区下的时间。这在Java8以前都是<a href="http://javarevisited.blogspot.sg/2013/02/convert-xmlgregoriancalendar-to-date-xmlgregoriancalendar-java-example-tutorial.html" target="_blank" rel="noopener"><code>GregorianCalendar</code>类</a>来做的。下面这个例子展示了如何把本时区的时间转换成另一个时区的时间。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Java 8中某时区下的日期和时间</span>ZoneId america <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"America/New_York"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDateTime localtDateAndTime <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ZonedDateTime dateAndTimeInNewYork  <span class="token operator">=</span> ZonedDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>localtDateAndTime<span class="token punctuation">,</span> america <span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Current date and time in a particular timezone : "</span> <span class="token operator">+</span> dateAndTimeInNewYork<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Current date and time in a particular timezone : 2016-04-19T23:10:09.251-04:00[America/New_York]</span></code></pre><p>和以前<a href="http://javarevisited.blogspot.sg/2012/04/how-to-convert-local-time-to-gmt-in.html" target="_blank" rel="noopener">使用<code>GMT</code>的方式转换本地时间</a>对比一下。注意，在Java8以前，一定要牢牢记住时区的名称，不然就会抛出下面的异常：</p><pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>zone<span class="token punctuation">.</span>ZoneRulesException<span class="token operator">:</span> Unknown time<span class="token operator">-</span>zone ID<span class="token operator">:</span> ASIA<span class="token operator">/</span>Tokyo        at java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>zone<span class="token punctuation">.</span>ZoneRulesProvider<span class="token punctuation">.</span><span class="token function">getProvider</span><span class="token punctuation">(</span>ZoneRulesProvider<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">272</span><span class="token punctuation">)</span>        at java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>zone<span class="token punctuation">.</span>ZoneRulesProvider<span class="token punctuation">.</span><span class="token function">getRules</span><span class="token punctuation">(</span>ZoneRulesProvider<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">227</span><span class="token punctuation">)</span>        at java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>ZoneRegion<span class="token punctuation">.</span><span class="token function">ofId</span><span class="token punctuation">(</span>ZoneRegion<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">120</span><span class="token punctuation">)</span>        at java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">403</span><span class="token punctuation">)</span>        at java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">351</span><span class="token punctuation">)</span></code></pre><h3 id="示例-13、如何表示信用卡到期这类固定日期，答案就在YearMonth"><a href="#示例-13、如何表示信用卡到期这类固定日期，答案就在YearMonth" class="headerlink" title="示例 13、如何表示信用卡到期这类固定日期，答案就在YearMonth"></a>示例 13、如何表示信用卡到期这类固定日期，答案就在<code>YearMonth</code></h3><p>与<code>MonthDay</code>检查重复事件的例子相似，<code>YearMonth</code>是另一个组合类，用于表示信用卡到期日、FD到期日、期货期权到期日等。还可以用这个类得到当月共有多少天，<code>YearMonth</code>实例的<code>lengthOfMonth()</code>方法可以返回当月的天数，在判断2月有28天还是29天时非常有用。</p><pre class=" language-java"><code class="language-java">YearMonth currentYearMonth <span class="token operator">=</span> YearMonth<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"该月的天数 %s: %d%n"</span><span class="token punctuation">,</span> currentYearMonth<span class="token punctuation">,</span> currentYearMonth<span class="token punctuation">.</span><span class="token function">lengthOfMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 该月的天数 2016-04: 30</span>YearMonth creditCardExpiry <span class="token operator">=</span> YearMonth<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2018</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>FEBRUARY<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"您的信用卡到期是： %s%n"</span><span class="token punctuation">,</span> creditCardExpiry<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 您的信用卡到期是： 2018-02</span></code></pre><p>根据上述数据，你可以提醒客户信用卡快要到期了，个人认为这个类非常有用。</p><h3 id="示例-14、如何在Java8中检查闰年"><a href="#示例-14、如何在Java8中检查闰年" class="headerlink" title="示例 14、如何在Java8中检查闰年"></a>示例 14、如何在Java8中检查闰年</h3><p><code>LocalDate</code>类有一个很实用的方法<code>isLeapYear()</code>判断该实例是否是一个闰年，如果你还是想重新发明轮子，这有一个代码示例，纯<a href="http://java67.blogspot.sg/2012/12/how-to-check-leap-year-in-java-program.html" target="_blank" rel="noopener">Java逻辑编写的判断闰年</a>的程序。</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>today<span class="token punctuation">.</span><span class="token function">isLeapYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"今年是闰年！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"今年不是闰年！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 今年是闰年！</span></code></pre><p>你可以多写几个日期来验证是否是闰年，最好是写<code>JUnit</code>单元测试做判断。</p><h3 id="示例-15、计算两个日期之间的天数和月数"><a href="#示例-15、计算两个日期之间的天数和月数" class="headerlink" title="示例 15、计算两个日期之间的天数和月数"></a>示例 15、计算两个日期之间的天数和月数</h3><p>有一个常见日期操作是计算两个日期之间的天数、周数或月数。在Java8中可以用<code>java.time.Period</code>类来做计算。下面这个例子中，我们计算了当天和将来某一天之间的月数。</p><pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LocalDate java8Release <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>APRIL<span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Period periodToNext <span class="token operator">=</span> Period<span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>today<span class="token punctuation">,</span> java8Release<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2016年4月21日距离今天的天数："</span> <span class="token operator">+</span> periodToNext<span class="token punctuation">.</span><span class="token function">getDays</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 2016年4月21日距离今天的天数：3</span></code></pre><p>从上面可以看到现在是一月，Java8的中计算的当前日期是4月18日，中间相隔3天。</p><h3 id="示例-16、包含时差信息的日期和时间"><a href="#示例-16、包含时差信息的日期和时间" class="headerlink" title="示例 16、包含时差信息的日期和时间"></a>示例 16、包含时差信息的日期和时间</h3><p>在Java8中，<code>ZoneOffset</code>类用来表示时区，举例来说印度与GMT或UTC标准时区相差<code>+05:30</code>，可以通过<code>ZoneOffset.of()</code>静态方法来 获取对应的时区。一旦得到了时差就可以通过传入<code>LocalDateTime</code>和<code>ZoneOffset</code>来创建一个<code>OffSetDateTime</code>对象。</p><pre class=" language-java"><code class="language-java">LocalDateTime datetime <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>APRIL<span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ZoneOffset offset <span class="token operator">=</span> ZoneOffset<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"+05:30"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>OffsetDateTime date <span class="token operator">=</span> OffsetDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>datetime<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"包含时差信息的日期和时间 : "</span> <span class="token operator">+</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包含时差信息的日期和时间 : 2016-04-19T23:35+05:30</span></code></pre><p>现在的时间信息里已经包含了时区信息了。注意：<code>OffSetDateTime</code>是对计算机友好的，<code>ZoneDateTime</code>则对人更友好。</p><h3 id="示例-17、在Java8中获取当前的时间戳"><a href="#示例-17、在Java8中获取当前的时间戳" class="headerlink" title="示例 17、在Java8中获取当前的时间戳"></a>示例 17、在Java8中获取当前的时间戳</h3><p>如果你还记得Java8以前是如何获得当前时间戳，那么现在你终于解脱了。<code>Instant</code>类有一个静态工厂方法<code>now()</code>会返回当前的时间戳，如下所示：</p><pre class=" language-java"><code class="language-java">Instant timestamp <span class="token operator">=</span> Instant<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"时间戳是："</span> <span class="token operator">+</span> timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 时间戳是：2016-04-18T15:41:06.876Z</span></code></pre><p>时间戳信息里同时包含了日期和时间，这和<code>java.util.Date</code>很像。实际上<code>Instant</code>类确实等同于Java8之前的<code>Date</code>类，你可以使用<code>Date</code>类和<code>Instant</code>类各自的转换方法互相转换，例如：<code>Date.from(Instant)</code> 将<code>Instant</code>转换成<code>java.util.Date</code>，<code>Date.toInstant()</code>则是将<code>Date</code>类转换成<code>Instant</code>类。</p><h3 id="示例-18、在Java8中如何使用预定义的格式化工具去解析或格式化日期"><a href="#示例-18、在Java8中如何使用预定义的格式化工具去解析或格式化日期" class="headerlink" title="示例 18、在Java8中如何使用预定义的格式化工具去解析或格式化日期"></a>示例 18、在Java8中如何使用预定义的格式化工具去解析或格式化日期</h3><p>在Java8以前的世界里，日期和时间的格式化非常诡异，唯一的帮助类<code>SimpleDateFormat</code>也是非线程安全的，而且用作局部变量解析和格式化日期时显得很笨重。幸好线程局部变量能使它在多线程环境中变得可用，不过这都是过去时了。Java8引入了全新的日期时间格式工具，线程安全而且使用方便。它自带了一些常用的内置格式化工具。下面这个例子使用了<code>BASIC_ISO_DATE</code>格式化工具将2016年4月18日格式化成20160418。</p><pre class=" language-java"><code class="language-java">String day <span class="token operator">=</span> <span class="token string">"20160418"</span><span class="token punctuation">;</span>LocalDate formatted <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>day<span class="token punctuation">,</span> DateTimeFormatter<span class="token punctuation">.</span>BASIC_ISO_DATE<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"从字符串中解析的日期: %s 是 %s %n"</span><span class="token punctuation">,</span> day<span class="token punctuation">,</span> formatted<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 从字符串中解析的日期: 20160418 是 2016-04-18 </span></code></pre><p>很明显的看出得到的日期和给出的日期是同一天，但是格式不同。</p><h3 id="示例-19、如何在Java中使用自定义格式化工具解析日期"><a href="#示例-19、如何在Java中使用自定义格式化工具解析日期" class="headerlink" title="示例 19、如何在Java中使用自定义格式化工具解析日期"></a>示例 19、如何在Java中使用自定义格式化工具解析日期</h3><p>上个例子使用了<a href="http://java67.blogspot.sg/2014/12/string-to-date-example-in-java-multithreading.html" target="_blank" rel="noopener"><code>Java</code>内置的格式化工具</a>去解析日期字符串。尽管内置格式化工具很好用，有时还是需要定义特定的日期格式，下面这个例子展示了如何创建自定义日期格式化工具。例子中的日期格式是“MMM dd yyyy”。可以调用<code>DateTimeFormatter</code>的<code>ofPattern()</code>静态方法并传入任意格式返回其实例，格式中的字符和以前代表的一样，M代表月，m代表分。如果格式不规范会抛出<code>DateTimeParseException</code>异常，不过如果只是把M写成m这种逻辑错误是不会抛异常的。</p><pre class=" language-java"><code class="language-java">String day <span class="token operator">=</span> <span class="token string">"2016 04 18"</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    DateTimeFormatter formatter <span class="token operator">=</span> DateTimeFormatter<span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"yyyy MM dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LocalDate holiday <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>day<span class="token punctuation">,</span> formatter<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"成功解析字符串：%s, 时间是：%s%n"</span><span class="token punctuation">,</span> day<span class="token punctuation">,</span> holiday<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">DateTimeParseException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s 解析失败!"</span><span class="token punctuation">,</span> day<span class="token punctuation">)</span><span class="token punctuation">;</span>    ex<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 成功解析字符串：2016 04 18, 时间是：2016-04-18</span></code></pre><p>日期值与传入的字符串是匹配的，只是格式不同而已。</p><h3 id="示例-20、在Java8中如何把日期转换成字符串"><a href="#示例-20、在Java8中如何把日期转换成字符串" class="headerlink" title="示例 20、在Java8中如何把日期转换成字符串"></a>示例 20、在Java8中如何把日期转换成字符串</h3><p>上 两个例子都用到了<code>DateTimeFormatter</code>类，主要是从字符串解析日期。现在我们反过来，把<code>LocalDateTime</code>日期实例转换成特定格式的字符串。这是迄今为止<a href="http://java67.blogspot.sg/2013/01/how-to-format-date-in-java-simpledateformat-example.html" target="_blank" rel="noopener"><code>Java</code>日期转字符串最为简单的方式</a>了。下面的例子将返回一个代表日期的格式化字符串。和前面类似，还是需要创建<code>DateTimeFormatter</code>实例并传入格式，但这回调用的是<code>format()</code>方法，而非<code>parse()</code>方法。这个方法会把传入的日期转化成指定格式的字符串。</p><pre class=" language-java"><code class="language-java">LocalDateTime arrivalDate  <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    DateTimeFormatter format <span class="token operator">=</span> DateTimeFormatter<span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"MMM dd yyyy  hh:mm a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String landing <span class="token operator">=</span> arrivalDate<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>format<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"格式化的日期时间:  %s %n"</span><span class="token punctuation">,</span> landing<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">DateTimeException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s 不能格式化!%n"</span><span class="token punctuation">,</span> arrivalDate<span class="token punctuation">)</span><span class="token punctuation">;</span>    ex<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 格式化的日期时间:  四月 19 2016  12:02 上午</span></code></pre><p>当前时间被指定的“MMM dd yyyy hh:mm a”格式格式化，格式包含3个代表月的字符串，时间后面带有AM和PM标记。</p><h2 id="Java-8日期时间API的重点"><a href="#Java-8日期时间API的重点" class="headerlink" title="Java 8日期时间API的重点"></a>Java 8日期时间API的重点</h2><p>通过这些例子，你肯定已经掌握了Java8日期时间API的新知识点。现在我们来回顾一下这个优雅<code>API</code>的使用要点：</p><ol><li>提供了<code>javax.time.ZoneId</code>获取时区。</li><li>提供了<code>LocalDate``和LocalTime</code>类。</li><li>Java8的所有日期和时间<code>API</code>都是不可变类并且线程安全，而现有的<code>Date</code>和<code>Calendar</code> API中的<code>java.util.Date</code>和<code>SimpleDateFormat</code>是非线程安全的。</li><li>主包是<code>java.time</code>,包含了表示日期、时间、时间间隔的一些类。里面有两个子包<code>java.time.format</code>用于格式化， <code>java.time.temporal</code>用于更底层的操作。</li><li>时区代表了地球上某个区域内普遍使用的标准时间。每个时区都有一个代号，格式通常由区域/城市构成（Asia/Tokyo），在加上与格林威治或<code>UTC</code>的时差。例如：东京的时差是+09:00。</li><li><code>OffsetDateTime</code>类实际上组合了<code>LocalDateTime</code>类和<code>ZoneOffset</code>类。用来表示包含和格林威治或UTC时差的完整日期（年、月、日）和时间（时、分、秒、纳秒）信息。</li><li><code>DateTimeFormatter</code>类用来格式化和解析时间。与<code>SimpleDateFormat</code>不同，这个类不可变并且线程安全，需要时可以给静态常量赋值。<code>DateTimeFormatter</code>类提供了大量的内置格式化工具，同时也允许你自定义。在转换方面也提供了<code>parse()</code>将字符串解析成日期，如果解析出错会抛出<code>DateTimeParseException</code>。<code>DateTimeFormatter</code>类同时还有<code>format()</code>用来格式化日期，如果出错会抛出<code>DateTimeException</code>异常。</li><li>再补充一点，日期格式“MMM d yyyy”和“MMM dd yyyy”有一些微妙的不同，第一个格式可以解析“Jan 2 2014”和“Jan 14 2014”，而第二个在解析“Jan 2 2014”就会抛异常，因为第二个格式里要求日必须是两位的。如果想修正，你必须在日期只有个位数时在前面补零，就是说“Jan 2 2014”应该写成 “Jan 02 2014”。</li></ol><p>如何使用Java8的全新日期时间API就介绍到这了。这些简单的例子对帮助理解新API非常有用。由于这些例子都基于真实任务，你在做<code>Java</code>日期编程时不用再东张西望了。我们学会了如何创建并操作日期实例，学习了纯日期、以及包含时间信息和时差信息的日期、学会了怎样计算两个日期的间隔，这些在计算当天与某个特定日期间隔的例子中都有所展示。 我们还学到了在Java8中如何线程安全地解析和格式化日期，不用再使用蹩脚的线程局部变量技巧，也不用依赖<code>Joda Time</code>第三方库。新<code>API</code>可以作为处理日期时间操作的标准。</p><p>如果你喜欢这个教程并希望看到更多关于Java 8的教程，下面这些精彩的文章都值得一看：</p><ul><li>如何在Java8中用一行代码搞定文件读取？(<a href="http://javarevisited.blogspot.sg/2015/02/how-to-read-file-in-one-line-java-8.html" target="_blank" rel="noopener">示例</a>)</li><li>学习Java8的十大教程（<a href="http://java67.blogspot.sg/2014/09/top-10-java-8-tutorials-best-of-lot.html" target="_blank" rel="noopener">教程</a>）</li><li>免费的Java8教程和图书 （<a href="http://javarevisited.blogspot.sg/2013/11/java-8-tutorials-resources-and-examples-lambda-expression-stream-api-functional-interfaces.html" target="_blank" rel="noopener">资源</a>）</li><li>Java 8 <code>Comparator</code>例子 （<a href="http://java67.blogspot.com/2014/11/java-8-comparator-example-using-lambda-expression.html" target="_blank" rel="noopener">示例</a>）</li><li>如何使用Java8的<code>Map</code>函数（<a href="http://java67.blogspot.sg/2015/01/java-8-map-function-examples.html" target="_blank" rel="noopener">示例</a>）</li><li>你准备好学习Java8的认证了吗 （<a href="http://javarevisited.blogspot.sg/2014/09/latest-OCPJP-exam-java-8-certification-oracle-java-se-8.html" target="_blank" rel="noopener">更多</a>）</li><li>如何使用Java8的默认方法。（<a href="http://javarevisited.blogspot.sg/2014/07/default-defender-or-extension-method-of-Java8-example-tutorial.html" target="_blank" rel="noopener">看这里</a>）</li><li>开始Java8之前需要温习的十个<code>Java 7</code>特性（<a href="http://javarevisited.blogspot.sg/2014/04/10-jdk-7-features-to-revisit-before-you.html" target="_blank" rel="noopener">更多</a>）</li><li>Java8学习<code>Stream API</code>十例（<a href="http://javarevisited.blogspot.sg/2014/03/2-examples-of-streams-with-Java8-collections.html" target="_blank" rel="noopener">示例</a>）</li><li>如何在匿名类中使用<code>Lambda</code>表达式（<a href="http://javarevisited.blogspot.sg/2015/01/how-to-use-lambda-expression-in-place-anonymous-class-java8.html" target="_blank" rel="noopener">答案</a>）</li><li>如何使用Java8的<code>Predicates</code>类过滤<code>Collection</code>？（<a href="http://javarevisited.blogspot.sg/2015/02/how-to-filter-collections-in-java-8.html" target="_blank" rel="noopener">答案</a>）</li><li><code>Java</code>中如何随即访问文件？（<a href="http://javarevisited.blogspot.sg/2015/02/randomaccessfile-example-in-java-read-write-String.html" target="_blank" rel="noopener">答案</a>）</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot下前后台分离时间处理</title>
      <link href="/2018/04/24/SpringBoot%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/"/>
      <url>/2018/04/24/SpringBoot%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前在前后端交互过程中，针对时间类型的字段，在DTO中使用<code>String</code>类型接收，在后台转成<code>Date</code>类型。但这样处理太麻烦。<br>JDK8的新特性中Time API，其包括<code>Clock</code>、<code>Duration</code>、<code>Instant</code>、<code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>、<code>ZonedDateTime</code>，这里介绍Spring Boot处理LocalDateTime格式。</p></blockquote><a id="more"></a><h1 id="Controller接收参数"><a href="#Controller接收参数" class="headerlink" title="Controller接收参数"></a>Controller接收参数</h1><p>在Spring中，接收LocalDateTime日期时间数据时，只需要使用@DateTimeFormat注解即可。@DateTimeFormat可以注解在字段、参数以及方法上，如果接收的为DTO，则需要将@DateTimeFormat注解在DTO中的字段上。(注意：前台传的参数格式必须与<code>pattern</code>定义格式一致)</p><pre><code>@GetMapping("date")public Object date(@RequestParam @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") LocalDateTime date) {    return date;}@GetMapping("date2")public Object date(@RequestParam @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate date) {    return date;}</code></pre><h1 id="ResponseBody格式化LocalDateTime"><a href="#ResponseBody格式化LocalDateTime" class="headerlink" title="ResponseBody格式化LocalDateTime"></a>ResponseBody格式化LocalDateTime</h1><p>Spring默认使用使用jackson来进行json格式转换。这里需要加入<code>jackson</code>的<code>jsr310</code>扩展包。</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;    &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;    &lt;version&gt;2.8.9&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="使用-JsonFormat注解"><a href="#使用-JsonFormat注解" class="headerlink" title="使用@JsonFormat注解"></a>使用@JsonFormat注解</h2><pre><code>public class InfoDTO {    /**     * 创建时间     */    @JsonFormat(shape=JsonFormat.Shape.STRING, pattern="yyyy-MM-dd HH:mm:ss")    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")    private LocalDateTime createDate;    //get/set方法省略}</code></pre><h2 id="使用ObjectMapper"><a href="#使用ObjectMapper" class="headerlink" title="使用ObjectMapper"></a>使用ObjectMapper</h2><p>使用<code>@Bean</code>注解创建一个ObjectMapperBean，并将<code>JavaTimeModule</code>注册到ObjectMapper中即可，<code>spring</code>会使用该bean创建<code>MappingJackson2HttpMessageConverter</code>进行<code>json</code>格式转换。</p><pre><code>@Bean(name = "mapperObject")@Primarypublic ObjectMapper getObjectMapper() {    ObjectMapper om = new ObjectMapper();    JavaTimeModule javaTimeModule = new JavaTimeModule();    javaTimeModule.addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));    javaTimeModule.addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern("yyyy-MM-dd")));    javaTimeModule.addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern("HH:mm:ss")));    om.registerModule(javaTimeModule);    return om;}</code></pre><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>在使用 <code>@DateFormat</code>进行参数转换的时候，只能接收url参数，或者表单提交参数。如果参数对象是以JSON传递过来的，这时使用该注解就无法进行转化。</p><pre><code>@RestControllerpublic class Controller {    @PostMapping("/")    public void post(@RequestBody InfoDTO infoDTO) {}}</code></pre><pre><code>public class InfoDTO {    /**     * 创建时间     */    @JsonDeserialize(using = LocalDateDeserializer.class)    @JsonFormat(pattern = "yyyyMMdd")    private LocalDateTime createDate;    //get/set方法省略}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud客户端FeignClient调用时传递Token</title>
      <link href="/2018/04/17/SpringCloud%E5%AE%A2%E6%88%B7%E7%AB%AFFeignClient%E8%B0%83%E7%94%A8%E6%97%B6%E4%BC%A0%E9%80%92Token/"/>
      <url>/2018/04/17/SpringCloud%E5%AE%A2%E6%88%B7%E7%AB%AFFeignClient%E8%B0%83%E7%94%A8%E6%97%B6%E4%BC%A0%E9%80%92Token/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Feign是一个声明式WebService客户端。在SpringCloud中可以通过FeignClient来进行服务间的调用。</p><p>而为了对API进行权限控制，项目中会进行权限认证，JWT或者Security。这时问题就会出现了，在加了授权认证之后，不管是JWT也好，Security也好，Feign调用总是没有权限。</p><p>其实我们知道不管是选择哪种，最终token都是放在请求头里面，访问时携带以通过认证。</p><p>可是当使用Feign时就会发现这样一个问题，外部请求到A服务的时候，A服务是可以拿到token(认证信息)的，然而当A使用Feign调用B服务时，token就会丢失，进而认证失败，权限不足。</p><a id="more"></a><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>这时候我们需要做的就是在Feign调用的时候，向其请求头里面添加上Token</p><h2 id="实现接口RequestInterceptor"><a href="#实现接口RequestInterceptor" class="headerlink" title="实现接口RequestInterceptor"></a>实现接口RequestInterceptor</h2><p>假设我们在验证权限的时候放在请求头里面的就叫token，我们先获取当前请求中的token，然后放到Feign的请求头上，当然具体还是要根据自己的业务来,这里就简单实现一下</p><pre><code>public class FeignConfigInterceptor implements RequestInterceptor{    @Value("${jwt.header}")    private String tokenHeader;    @Override    public void apply(RequestTemplate requestTemplate) {        requestTemplate.header(tokenHeader, getHeaders(getHttpServletRequest()).get(tokenHeader));    }    private HttpServletRequest getHttpServletRequest() {        try {            return ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();        } catch (Exception e) {            return null;        }    }    private Map&lt;String, String&gt; getHeaders(HttpServletRequest request) {        Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();        Enumeration&lt;String&gt; enumeration = request.getHeaderNames();        while (enumeration.hasMoreElements()) {            String key = enumeration.nextElement();            String value = request.getHeader(key);            map.put(key, value);        }        return map;    }}</code></pre><h2 id="使用创建的FeignConfigInterceptor"><a href="#使用创建的FeignConfigInterceptor" class="headerlink" title="使用创建的FeignConfigInterceptor"></a>使用创建的FeignConfigInterceptor</h2><p>在@FeignClient注解里面的属性加上configuration = FeignConfigInterceptor.class</p><pre><code>@FeignClient(name = "user",url = "localhost:8081",configuration = FeignConfigInterceptor.class)public interface UserServiceClient {}</code></pre><p>这时候再调用就会发现已经携带token了。</p><h2 id="插曲"><a href="#插曲" class="headerlink" title="插曲"></a>插曲</h2><p>在获取request所有的头信息的时候，使用 <code>request.getHeaderNames()</code>遍历后(即上文的<code>private Map&lt;String String&gt; getHeaders(HttpServletRequest request)</code>方法)，其中的key全部为小写。而我定义的<code>tokenHeader</code>是有大小写的，因此任然匹配不上。最后发现，直接使用<code>request.getHeader(String var1)</code>这个方法就可以获取到值。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>其实实现了RequestInterceptor后，直接使用@Configuration注解，不在FeignClient里面加属性也是可以的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Feign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win7 环境安装RabbitMQ</title>
      <link href="/2018/03/25/Win7%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85RabbitMQ/"/>
      <url>/2018/03/25/Win7%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85RabbitMQ/</url>
      
        <content type="html"><![CDATA[<p>在Windows环境下安装RabbitMQ时遇到了一个坑，当启动服务时(``rabbitmq-service start`)，出现一串乱码错误,<br>原因是需要以管理员身份运行cmd命令窗口。</p><a id="more"></a><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li><p>RabbitMQ依赖erlang,所以先安装erlang，然后再安装RabbitMQ;</p></li><li><p>下载RabbitMQ,下载地址： <a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/rabbitmq_v3_5_6/rabbitmq-server-3.5.6.exe" target="_blank" rel="noopener">rabbitmq-server-3.5.6.exe</a>和erlang，下载地址：<a href="http://www.erlang.org/download/otp_win64_18.1.exe" target="_blank" rel="noopener">otp_win64_18.1.exe</a></p></li><li><p>先安装erlang,双击erlang的安装文件即可，然后配置环境变量：<br> ERLANG_HOME=D:\Program Files\erl7.1<br> 追加到path=%ERLANG_HOME%\bin;</p></li><li><p>验证erlang是否安装成功， 打开cmd命令窗口，进入erlang的bin路径，输入erl命令，如果出现如下提示，则说明erlang安装成功：<br> D:\Program Files\erl7.1\bin&gt;erl<br> Eshell V7.1  (abort with ^G)</p></li><li><p>再安装RabbitMQ，双击安装文件即可，安装完毕后， 设置环境变量：<br>  RABBITMQ_SERVER=D:\Program Files\RabbitMQ Server\rabbitmq_server-3.5.6<br>  追加到path=%RABBITMQ_SERVER%\sbin;</p></li><li><p>验证RabbitMQ是否安装成功，在CMD命令窗口输入(注意：<a href="https://jingyan.baidu.com/album/fb48e8be1b785d6e622e1495.html?picindex=8" target="_blank" rel="noopener">这里启动CMD命令窗口需要以管理员身份运行</a>)：<br>C:\Windows\system32&gt;rabbitmq-service<br>出现以下命令，则说明安装成功：</p><pre><code>*********************Service control usage*********************rabbitmq-service help    - Display this helprabbitmq-service install - Install the RabbitMQ servicerabbitmq-service remove  - Remove the RabbitMQ serviceThe following actions can also be accomplished by usingWindows Services Management Console (services.msc):rabbitmq-service start   - Start the RabbitMQ servicerabbitmq-service stop    - Stop the RabbitMQ servicerabbitmq-service disable - Disable the RabbitMQ servicerabbitmq-service enable  - Enable the RabbitMQ service</code></pre></li><li><p>安装服务，打开cmd窗体，进入D:\Program Files\RabbitMQ Server\rabbitmq_server-3.5.6\sbin路径，然后执行 <code>rabbitmq-service install</code>，提示安装成功</p><pre><code> D:\Program Files\RabbitMQ Server\rabbitmq_server-3.5.6\sbin&gt;rabbitmq-service install D:\Program Files\erl7.1\erts-7.1\bin\erlsrv: Service RabbitMQ added to system.</code></pre><p> 然后启动：<code>rabbitmq-service start</code></p><pre><code> D:\Program Files\RabbitMQ Server\rabbitmq_server-3.5.6\sbin&gt; D:\Program Files\erl7.1\erts-7.1\bin\erlsrv: Service RabbitMQ started.</code></pre><p> 提示启动成功；<br> 然后安装web管理插件，执行命令如下：<br> <code>rabbitmq-plugins enable rabbitmq_management</code><br> 出现以下命令则说明安装成功：</p><pre><code> D:\Program Files\RabbitMQ Server\rabbitmq_server-3.5.6\sbin&gt;rabbitmq-plugins enable rabbitmq_management The following plugins have been enabled: mochiweb webmachine rabbitmq_web_dispatch amqp_client rabbitmq_management_agent rabbitmq_management</code></pre></li><li><p>测试 访问<a href="http://localhost:15672" target="_blank" rel="noopener">http://localhost:15672</a>,出现登录页面，默认的登陆账号为：guest，密码为：guest</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 问题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat发布Web项目</title>
      <link href="/2018/03/13/Tomcat%E5%8F%91%E5%B8%83Web%E9%A1%B9%E7%9B%AE/"/>
      <url>/2018/03/13/Tomcat%E5%8F%91%E5%B8%83Web%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、将war包丢进webapps"><a href="#一、将war包丢进webapps" class="headerlink" title="一、将war包丢进webapps"></a>一、将war包丢进webapps</h1><p>这是最简单粗暴的方式：将web工程打成war，丢进tomcat/webapps目录即可，tomcat会自动解压。无需修改任何配置文件即可完成部署。<br><strong>注：</strong> 此时访问路径为：<a href="http://localhost:8080/war包名" target="_blank" rel="noopener">http://localhost:8080/war包名</a></p><h1 id="二、配置Server-xml部署Web工程"><a href="#二、配置Server-xml部署Web工程" class="headerlink" title="二、配置Server.xml部署Web工程"></a>二、配置Server.xml部署Web工程</h1><p>配置$CATALINA_HOME/conf/server.xml文件，在Host节点下添加Context节点，内容如下：</p><pre class=" language-xml"><code class="language-xml">&lt;Context  path ="/"  reloadable ="true"  docBase ="/home/test"/></code></pre><p>path：是访问时的根地址，表示访问的路径；上述例子中，如果Path=”/test”，则访问该应用程序地址如下：<a href="http://localhost:8080/test/" target="_blank" rel="noopener">http://localhost:8080/test/</a></p><p>reloadable：表示可以在运行时在classes与lib文件夹下自动加载类包。其中reloadable=”false”表示当应用程序 中的内容发生更改之后服务器不会自动加载，这个属性在开发阶段通常都设为true，方便开发，在发布阶段应该设置为false，提高应用程序的访问速度。</p><p>docbase：表示应用程序的路径，注意斜杠的方向“/”。 docBase可以使用绝对路径，也可以使用相对路径，相对路径相对于webapps。</p><p><strong>注：</strong> 这种方式不需要打war包，只需将编译好的文件拷贝到docBase指定的目录中</p><h1 id="三、增加自定义web部署文件"><a href="#三、增加自定义web部署文件" class="headerlink" title="三、增加自定义web部署文件"></a>三、增加自定义web部署文件</h1><p>这种方式和方法2差不多，但不是在Server.xml文件中添加Context标签，而是在$CATALINA_HOME/conf /Catalina/localhost中添加一个xml文件，如Pet.xml.在Tomcat安装目录conf/Catalina/localhost下，里面有Tomcat自带的三个应用，随意复制其中的一个XML文件，然后修改docbase指向你自己的应用程序，并把文件名改名，<br>各参数参见方法2中的<context>标签的参数，或者你也可以自己新建一个XML文件。(注意此文件名将作为Context中的path属性值,不管文件里的path属性值如何设置也是无效的 )，将以下内容复制过去，修改相应路径即可。</context></p><pre class=" language-xml"><code class="language-xml">&lt;Context  path ="/test"  docBase ="/home/test"          debug ="0"  privileged ="true"  reloadable ="false"  />  </code></pre><p><strong>注：</strong>  此时访问地址如下：<a href="http://localhost:8080/test/" target="_blank" rel="noopener">http://localhost:8080/test/</a>  </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm 安装express npm ERR!</title>
      <link href="/2018/03/12/npm%E5%AE%89%E8%A3%85express%20npm%20ERR!/"/>
      <url>/2018/03/12/npm%E5%AE%89%E8%A3%85express%20npm%20ERR!/</url>
      
        <content type="html"><![CDATA[<p>换了台电脑，想把博客环境在本机搭建起来，在执行npm时报错了。</p><p>npm  安装 express  出现</p><pre><code>npm ERR! code UNABLE_TO_VERIFY_LEAF_SIGNATUREnpm ERR! errno UNABLE_TO_VERIFY_LEAF_SIGNATUREnpm ERR! request to https://registry.npmjs.org/express failed, reason: unable to verify the first certificate</code></pre><p>解决方案</p><p>设置下 <code>npm  config set strict-ssl  false</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 问题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Error </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改.gitignore文件没有生效</title>
      <link href="/2018/03/09/%E4%BF%AE%E6%94%B9.gitignore%E6%96%87%E4%BB%B6%E6%B2%A1%E6%9C%89%E7%94%9F%E6%95%88/"/>
      <url>/2018/03/09/%E4%BF%AE%E6%94%B9.gitignore%E6%96%87%E4%BB%B6%E6%B2%A1%E6%9C%89%E7%94%9F%E6%95%88/</url>
      
        <content type="html"><![CDATA[<p>在使用git的时候我们有时候需要忽略一些文件或者文件夹。我们一般在仓库的根目录创建.gitignore文件<br>在提交之前，修改.gitignore文件，添加需要忽略的文件。然后再做add/commit/push等。<br>但是有时在使用过称中，需要对.gitignore文件进行再次的修改。这时我们需要清除一下缓存cache，才能是.gitignore 生效。</p><a id="more"></a><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><pre><code>git rm -r --cached .  #清除缓存git add . #重新trace filegit commit -m "update .gitignore" #提交和注释git push origin master #可选，如果需要同步到remote上的话</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 问题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客添加Gitalk评论</title>
      <link href="/2018/03/05/Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Gitalk%E8%AF%84%E8%AE%BA/"/>
      <url>/2018/03/05/Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Gitalk%E8%AF%84%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>Hexo支持本身多款评论插件，但是多说，网易云跟贴都已经下线。Disqus也被挡在墙外，友言貌似也不行。<br><a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">Gitalk</a>:一个基于 Github Issue 和 Preact 开发的评论插件，类似<a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">Gitment</a><br>详情Demo可见：<a href="https://gitalk.github.io/" target="_blank" rel="noopener">https://gitalk.github.io/</a></p><a id="more"></a><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2><p>在GitHub上注册新应用，链接：<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a><br><img src="http://oxzz60egu.bkt.clouddn.com/hexo/image/gitalk-step1.png" alt=""><br>点击注册后，查看 Client ID和Client Secret在后面的配置中需要用到(也可到Settings/Devoloper settings找到自己创建的应用)<br><img src="http://oxzz60egu.bkt.clouddn.com/hexo/image/gitalk-step2.png" alt=""></p><h2 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h2><h3 id="新建gitalk-swig"><a href="#新建gitalk-swig" class="headerlink" title="新建gitalk.swig"></a>新建gitalk.swig</h3><p>在主题文件下，新建<code>/layout/_third-party/comments/gitalk.swig</code>文件，内容如下：</p><pre><code>{% if page.comments &amp;&amp; theme.gitalk.enable %}  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>   <script type="text/javascript">        var gitalk = new Gitalk({          clientID: '{{ theme.gitalk.ClientID }}',          clientSecret: '{{ theme.gitalk.ClientSecret }}',          repo: '{{ theme.gitalk.repo }}',          owner: '{{ theme.gitalk.githubID }}',          admin: ['{{ theme.gitalk.adminUser }}'],          id: location.pathname,          distractionFreeMode: '{{ theme.gitalk.distractionFreeMode }}'        })        gitalk.render('gitalk-container')       </script>{% endif %}</code></pre><h3 id="修改comments-swig"><a href="#修改comments-swig" class="headerlink" title="修改comments.swig"></a>修改comments.swig</h3><p>修改 <code>/layout/_partials/comments.swig</code>,并添加以下内容：</p><pre><code>{% elseif theme.gitalk.enable %} &lt;div id="gitalk-container"&gt;&lt;/div&gt;</code></pre><h3 id="修改index-swig"><a href="#修改index-swig" class="headerlink" title="修改index.swig"></a>修改index.swig</h3><p>修改<code>layout/_third-party/comments/index.swig</code>，在最后一行添加内容：</p><pre><code>{% include 'gitalk.swig' %}</code></pre><h3 id="新建gitalk-styl"><a href="#新建gitalk-styl" class="headerlink" title="新建gitalk.styl"></a>新建gitalk.styl</h3><p>新建<code>/source/css/_common/components/third-party/gitalk.styl</code>文件，添加内容：</p><pre><code>.gt-header a, .gt-comments a, .gt-popup a  border-bottom: none;.gt-container .gt-popup .gt-action.is--active:before  top: 0.7em;</code></pre><h3 id="修改third-party-styl"><a href="#修改third-party-styl" class="headerlink" title="修改third-party.styl"></a>修改third-party.styl</h3><p>修改<code>/source/css/_common/components/third-party/third-party.styl</code>，在最后一行上添加内容，引入样式：</p><pre><code>@import "gitalk";</code></pre><h3 id="最后，修改主题配置文件"><a href="#最后，修改主题配置文件" class="headerlink" title="最后，修改主题配置文件"></a>最后，修改主题配置文件</h3><p>在<code>next/_config.yml</code>中添加如下内容：</p><pre><code>gitalk:  enable: true  githubID: github帐号  # 例：nww57  repo: 仓库名称   # 例：nww57.github.io  ClientID: Client ID  ClientSecret: Client Secret  adminUser: github帐号 #指定可初始化评论账户  distractionFreeMode: true</code></pre><p>到此，Gitalk配置完成。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo添加在线联系功能</title>
      <link href="/2018/03/02/Hexo%E6%B7%BB%E5%8A%A0%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/03/02/Hexo%E6%B7%BB%E5%8A%A0%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>最近在浏览博客的时候，发现了一个在线联系功能 <a href="http://www.daovoice.io/" target="_blank" rel="noopener">DaoVoice</a>：当有用户在网页上给你留言后会通过邮件或者微信通知你。于是也想整合一下。最终效果是在右下角生成了一聊天按钮，点击即可进行交流。<br><img src="http://oxzz60egu.bkt.clouddn.com/hexo/image/daovoice.png" alt=""></p><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><h2 id="注册DaoVoice，获取app-id"><a href="#注册DaoVoice，获取app-id" class="headerlink" title="注册DaoVoice，获取app_id"></a>注册DaoVoice，获取app_id</h2><p>首先到DaoVoice上注册一个账号,注册完成后会得到一个app_id，获取appid的步骤如下图所示:<br><img src="http://oxzz60egu.bkt.clouddn.com/hexo/image/daovoice-step4.png" alt=""></p><a id="more"></a><h2 id="主题集成"><a href="#主题集成" class="headerlink" title="主题集成"></a>主题集成</h2><p>打开/themes/next/layout/_partials/head.swig文件添加如下代码：</p><pre><code>{% if theme.daovoice %}  <script>  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")  daovoice('init', {      app_id: "{{theme.daovoice_app_id}}"    });  daovoice('update');  </script>{% endif %}</code></pre><p>接着打开主题配置文件_config.yml，添加如下代码：</p><pre><code># Online contactdaovoice: truedaovoice_app_id: 这里输入前面获取的app_id</code></pre><p>最后执行hexo cl &amp;&amp; hexo d -g 就能看到效果了。</p><h2 id="定制聊天窗口样式"><a href="#定制聊天窗口样式" class="headerlink" title="定制聊天窗口样式"></a>定制聊天窗口样式</h2><p>集成DaoVoice后，聊天按钮的位置跟颜色是可以自定义的，到DaoVoice的控制台进行修改<br><img src="http://oxzz60egu.bkt.clouddn.com/hexo/image/daovoice-step2.png" alt=""></p><h2 id="微信通知"><a href="#微信通知" class="headerlink" title="微信通知"></a>微信通知</h2><p>最后到右上角选择管理员，微信绑定,可以绑定你的微信号，关注公众号后打开小程序，就可以实时收发消息，有新的消息也会通过微信通知，设置页面如下:<br><img src="http://oxzz60egu.bkt.clouddn.com/hexo/image/daovoice-step3.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo添加站内搜索</title>
      <link href="/2018/03/01/Hexo%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"/>
      <url>/2018/03/01/Hexo%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia。Swiftype开始收费，而且只对企业邮箱开放注册。本篇将讲述Algolia和Local Search两种方式进行站内搜索。</p><h1 id="一、Algolia"><a href="#一、Algolia" class="headerlink" title="一、Algolia"></a>一、Algolia</h1><p>Next主题在 <code>5.1.0</code>版本中就已经引入了Algolia,因此省去很多配置。如需按照以下步骤执行，请确保所使用的 NexT 版本在此之后。</p><h2 id="注册Algolia-创建Index"><a href="#注册Algolia-创建Index" class="headerlink" title="注册Algolia,创建Index"></a>注册Algolia,创建Index</h2><p>前往 <a href="https://www.algolia.com/" target="_blank" rel="noopener">Algolia注册页面</a> 注册一个新账户。 可以使用 GitHub 或者 Google 账户直接登录，注册后的 14 天内拥有所有功能（包括收费类别的）免费。之后若未续费会自动降级为免费账户，免费账户 总共有 10,000 条记录，每月有 100,000 的可以操作数。注册完成后，创建一个新的 Index，这个 Index 将在后面使用。<br><img src="http://oxzz60egu.bkt.clouddn.com/hexo/image/hexo-algolia-step1.png" alt=""></p><a id="more"></a><h2 id="安装-Hexo-Algolia"><a href="#安装-Hexo-Algolia" class="headerlink" title="安装 Hexo Algolia"></a>安装 Hexo Algolia</h2><p>Index 创建完成后，此时这个 Index 里未包含任何数据。 接下来需要安装 Hexo Algolia 扩展， 这个扩展的功能是搜集站点的内容并通过 API 发送给 Algolia。前往站点根目录，执行命令安装：<br><code>npm install --save hexo-algolia</code></p><h2 id="获取Algolia中的Key-更新站点配置"><a href="#获取Algolia中的Key-更新站点配置" class="headerlink" title="获取Algolia中的Key,更新站点配置"></a>获取Algolia中的Key,更新站点配置</h2><p>在 Algolia服务站点上 点击菜单中的 <code>API Keys</code> ，里面有需要使用的配置key，包括 ApplicationID、Search-Only API Key、 Admin API Key。注意，Admin API Key 需要保密保存。点击ALL API KEYS 找到新建INDEX对应的key， 编辑权限，在弹出框中找到ACL选择勾选Add records, Delete records, List indices, Delete index权限，点击update更新。<br><img src="http://oxzz60egu.bkt.clouddn.com/hexo/image/hexo-algolia-step2.png" alt=""><br><img src="http://oxzz60egu.bkt.clouddn.com/hexo/image/hexo-algolia-step3.png" alt=""></p><h2 id="更新Index"><a href="#更新Index" class="headerlink" title="更新Index"></a>更新Index</h2><p>回到你的博客站点目录，在根目录下执行：</p><pre><code>export(windows 为 set) HEXO_ALGOLIA_INDEXING_KEY=Search-Only API keyhexo algolia</code></pre><p>来更新 Index。</p><h2 id="主题集成"><a href="#主题集成" class="headerlink" title="主题集成"></a>主题集成</h2><p>更改主题配置文件，找到 Algolia Search 配置部分：</p><pre><code># Algolia Searchalgolia_search:  enable: false  hits:    per_page: 10  labels:    input_placeholder: Search for Posts    hits_empty: "We didn't find any results for the search: ${query}"    hits_stats: "${hits} results found in ${time} ms"</code></pre><p>将 enable 改为 true 即可，根据需要你可以调整 labels 中的文本。</p><h2 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h2><p>到上一步已经可以进行全局搜索，不过发现不支持全文搜索。查看Algolia控制台，发现只有文章的基本信息，并没有把文章的内容推送到Algolia。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>找到hexo-algolia插件的配置文件，添加 <code>content</code> 配置。<br>文件路径 <code>node_modules/hexo-algolia/lib/command.js</code></p><pre><code>var INDEXED_PROPERTIES = [  'title',  'date',  'updated',  'slug',  'excerpt',  'permalink',  'layout',  'content'];</code></pre><h1 id="二、Local-Search"><a href="#二、Local-Search" class="headerlink" title="二、Local Search"></a>二、Local Search</h1><p>Local Search,原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。</p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="安装-hexo-generator-searchdb"><a href="#安装-hexo-generator-searchdb" class="headerlink" title="安装 hexo-generator-searchdb"></a>安装 hexo-generator-searchdb</h3><p>在站点的根目录下执行以下命令：<br>    <code>npm install hexo-generator-searchdb --save</code></p><h3 id="站点文件配置"><a href="#站点文件配置" class="headerlink" title="站点文件配置"></a>站点文件配置</h3><p>编辑 站点配置文件，新增以下内容到任意位置：<br>    <code>search:      path: search.xml      field: post      format: html      limit: 10000</code></p><h3 id="主题文件配置"><a href="#主题文件配置" class="headerlink" title="主题文件配置"></a>主题文件配置</h3><p>找到local search配置<br>    <code># Local search    # Dependencies: https://github.com/flashlab/hexo-generator-search    local_search:      enable: true</code></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>以上两种方式都能实现全局搜索，不过相比较与Algolia，使用Local Search更加简便一些。想折腾的同学也可以去尝试下。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
